(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{104:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Group\", function() { return Group; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(93);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nfunction Group(_ref) {\n  var _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      transform = _ref.transform,\n      className = _ref.className,\n      children = _ref.children,\n      restProps = objectWithoutProperties(_ref, ['top', 'left', 'transform', 'className', 'children']);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    'g',\n    _extends({\n      className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-group', className),\n      transform: transform || 'translate(' + left + ', ' + top + ')'\n    }, restProps),\n    children\n  );\n}\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ4L2dyb3VwL2Rpc3QvdngtZ3JvdXAuZXMuanM/ZTBiMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMEI7QUFDRTs7QUFFNUI7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDRDQUFLO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQixpREFBRTtBQUNuQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRWlCIiwiZmlsZSI6IjEwNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmZ1bmN0aW9uIEdyb3VwKF9yZWYpIHtcbiAgdmFyIF9yZWYkdG9wID0gX3JlZi50b3AsXG4gICAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdG9wLFxuICAgICAgX3JlZiRsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbGVmdCA9IF9yZWYkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkbGVmdCxcbiAgICAgIHRyYW5zZm9ybSA9IF9yZWYudHJhbnNmb3JtLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3RvcCcsICdsZWZ0JywgJ3RyYW5zZm9ybScsICdjbGFzc05hbWUnLCAnY2hpbGRyZW4nXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2cnLFxuICAgIF9leHRlbmRzKHtcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWdyb3VwJywgY2xhc3NOYW1lKSxcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtIHx8ICd0cmFuc2xhdGUoJyArIGxlZnQgKyAnLCAnICsgdG9wICsgJyknXG4gICAgfSwgcmVzdFByb3BzKSxcbiAgICBjaGlsZHJlblxuICApO1xufVxuXG5leHBvcnQgeyBHcm91cCB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///104\n")},265:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/cluster.js\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\nfunction meanX(children) {\n  return children.reduce(meanXReduce, 0) / children.length;\n}\n\nfunction meanXReduce(x, c) {\n  return x + c.x;\n}\n\nfunction maxY(children) {\n  return 1 + children.reduce(maxYReduce, 0);\n}\n\nfunction maxYReduce(y, c) {\n  return Math.max(y, c.y);\n}\n\nfunction leafLeft(node) {\n  var children;\n  while (children = node.children) node = children[0];\n  return node;\n}\n\nfunction leafRight(node) {\n  var children;\n  while (children = node.children) node = children[children.length - 1];\n  return node;\n}\n\n/* harmony default export */ var cluster = (function() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = false;\n\n  function cluster(root) {\n    var previousNode,\n        x = 0;\n\n    // First walk, computing the initial x & y values.\n    root.eachAfter(function(node) {\n      var children = node.children;\n      if (children) {\n        node.x = meanX(children);\n        node.y = maxY(children);\n      } else {\n        node.x = previousNode ? x += separation(node, previousNode) : 0;\n        node.y = 0;\n        previousNode = node;\n      }\n    });\n\n    var left = leafLeft(root),\n        right = leafRight(root),\n        x0 = left.x - separation(left, right) / 2,\n        x1 = right.x + separation(right, left) / 2;\n\n    // Second walk, normalizing x & y to the desired size.\n    return root.eachAfter(nodeSize ? function(node) {\n      node.x = (node.x - root.x) * dx;\n      node.y = (root.y - node.y) * dy;\n    } : function(node) {\n      node.x = (node.x - x0) / (x1 - x0) * dx;\n      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;\n    });\n  }\n\n  cluster.separation = function(x) {\n    return arguments.length ? (separation = x, cluster) : separation;\n  };\n\n  cluster.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);\n  };\n\n  cluster.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return cluster;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/count.js\nfunction count(node) {\n  var sum = 0,\n      children = node.children,\n      i = children && children.length;\n  if (!i) sum = 1;\n  else while (--i >= 0) sum += children[i].value;\n  node.value = sum;\n}\n\n/* harmony default export */ var hierarchy_count = (function() {\n  return this.eachAfter(count);\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/each.js\n/* harmony default export */ var each = (function(callback) {\n  var node = this, current, next = [node], children, i, n;\n  do {\n    current = next.reverse(), next = [];\n    while (node = current.pop()) {\n      callback(node), children = node.children;\n      if (children) for (i = 0, n = children.length; i < n; ++i) {\n        next.push(children[i]);\n      }\n    }\n  } while (next.length);\n  return this;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/eachBefore.js\n/* harmony default export */ var eachBefore = (function(callback) {\n  var node = this, nodes = [node], children, i;\n  while (node = nodes.pop()) {\n    callback(node), children = node.children;\n    if (children) for (i = children.length - 1; i >= 0; --i) {\n      nodes.push(children[i]);\n    }\n  }\n  return this;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/eachAfter.js\n/* harmony default export */ var eachAfter = (function(callback) {\n  var node = this, nodes = [node], next = [], children, i, n;\n  while (node = nodes.pop()) {\n    next.push(node), children = node.children;\n    if (children) for (i = 0, n = children.length; i < n; ++i) {\n      nodes.push(children[i]);\n    }\n  }\n  while (node = next.pop()) {\n    callback(node);\n  }\n  return this;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/sum.js\n/* harmony default export */ var sum = (function(value) {\n  return this.eachAfter(function(node) {\n    var sum = +value(node.data) || 0,\n        children = node.children,\n        i = children && children.length;\n    while (--i >= 0) sum += children[i].value;\n    node.value = sum;\n  });\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/sort.js\n/* harmony default export */ var sort = (function(compare) {\n  return this.eachBefore(function(node) {\n    if (node.children) {\n      node.children.sort(compare);\n    }\n  });\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/path.js\n/* harmony default export */ var path = (function(end) {\n  var start = this,\n      ancestor = leastCommonAncestor(start, end),\n      nodes = [start];\n  while (start !== ancestor) {\n    start = start.parent;\n    nodes.push(start);\n  }\n  var k = nodes.length;\n  while (end !== ancestor) {\n    nodes.splice(k, 0, end);\n    end = end.parent;\n  }\n  return nodes;\n});\n\nfunction leastCommonAncestor(a, b) {\n  if (a === b) return a;\n  var aNodes = a.ancestors(),\n      bNodes = b.ancestors(),\n      c = null;\n  a = aNodes.pop();\n  b = bNodes.pop();\n  while (a === b) {\n    c = a;\n    a = aNodes.pop();\n    b = bNodes.pop();\n  }\n  return c;\n}\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/ancestors.js\n/* harmony default export */ var ancestors = (function() {\n  var node = this, nodes = [node];\n  while (node = node.parent) {\n    nodes.push(node);\n  }\n  return nodes;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/descendants.js\n/* harmony default export */ var descendants = (function() {\n  var nodes = [];\n  this.each(function(node) {\n    nodes.push(node);\n  });\n  return nodes;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/leaves.js\n/* harmony default export */ var leaves = (function() {\n  var leaves = [];\n  this.eachBefore(function(node) {\n    if (!node.children) {\n      leaves.push(node);\n    }\n  });\n  return leaves;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/links.js\n/* harmony default export */ var links = (function() {\n  var root = this, links = [];\n  root.each(function(node) {\n    if (node !== root) { // Don’t include the root’s parent, if any.\n      links.push({source: node.parent, target: node});\n    }\n  });\n  return links;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/index.js\n\n\n\n\n\n\n\n\n\n\n\n\nfunction hierarchy(data, children) {\n  var root = new Node(data),\n      valued = +data.value && (root.value = data.value),\n      node,\n      nodes = [root],\n      child,\n      childs,\n      i,\n      n;\n\n  if (children == null) children = defaultChildren;\n\n  while (node = nodes.pop()) {\n    if (valued) node.value = +node.data.value;\n    if ((childs = children(node.data)) && (n = childs.length)) {\n      node.children = new Array(n);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new Node(childs[i]));\n        child.parent = node;\n        child.depth = node.depth + 1;\n      }\n    }\n  }\n\n  return root.eachBefore(computeHeight);\n}\n\nfunction node_copy() {\n  return hierarchy(this).eachBefore(copyData);\n}\n\nfunction defaultChildren(d) {\n  return d.children;\n}\n\nfunction copyData(node) {\n  node.data = node.data.data;\n}\n\nfunction computeHeight(node) {\n  var height = 0;\n  do node.height = height;\n  while ((node = node.parent) && (node.height < ++height));\n}\n\nfunction Node(data) {\n  this.data = data;\n  this.depth =\n  this.height = 0;\n  this.parent = null;\n}\n\nNode.prototype = hierarchy.prototype = {\n  constructor: Node,\n  count: hierarchy_count,\n  each: each,\n  eachAfter: eachAfter,\n  eachBefore: eachBefore,\n  sum: sum,\n  sort: sort,\n  path: path,\n  ancestors: ancestors,\n  descendants: descendants,\n  leaves: leaves,\n  links: links,\n  copy: node_copy\n};\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/array.js\nvar slice = Array.prototype.slice;\n\nfunction shuffle(array) {\n  var m = array.length,\n      t,\n      i;\n\n  while (m) {\n    i = Math.random() * m-- | 0;\n    t = array[m];\n    array[m] = array[i];\n    array[i] = t;\n  }\n\n  return array;\n}\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/pack/enclose.js\n\n\n/* harmony default export */ var enclose = (function(circles) {\n  var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;\n\n  while (i < n) {\n    p = circles[i];\n    if (e && enclosesWeak(e, p)) ++i;\n    else e = encloseBasis(B = extendBasis(B, p)), i = 0;\n  }\n\n  return e;\n});\n\nfunction extendBasis(B, p) {\n  var i, j;\n\n  if (enclosesWeakAll(p, B)) return [p];\n\n  // If we get here then B must have at least one element.\n  for (i = 0; i < B.length; ++i) {\n    if (enclosesNot(p, B[i])\n        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {\n      return [B[i], p];\n    }\n  }\n\n  // If we get here then B must have at least two elements.\n  for (i = 0; i < B.length - 1; ++i) {\n    for (j = i + 1; j < B.length; ++j) {\n      if (enclosesNot(encloseBasis2(B[i], B[j]), p)\n          && enclosesNot(encloseBasis2(B[i], p), B[j])\n          && enclosesNot(encloseBasis2(B[j], p), B[i])\n          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {\n        return [B[i], B[j], p];\n      }\n    }\n  }\n\n  // If we get here then something is very wrong.\n  throw new Error;\n}\n\nfunction enclosesNot(a, b) {\n  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;\n  return dr < 0 || dr * dr < dx * dx + dy * dy;\n}\n\nfunction enclosesWeak(a, b) {\n  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\n\nfunction enclosesWeakAll(a, B) {\n  for (var i = 0; i < B.length; ++i) {\n    if (!enclosesWeak(a, B[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction encloseBasis(B) {\n  switch (B.length) {\n    case 1: return encloseBasis1(B[0]);\n    case 2: return encloseBasis2(B[0], B[1]);\n    case 3: return encloseBasis3(B[0], B[1], B[2]);\n  }\n}\n\nfunction encloseBasis1(a) {\n  return {\n    x: a.x,\n    y: a.y,\n    r: a.r\n  };\n}\n\nfunction encloseBasis2(a, b) {\n  var x1 = a.x, y1 = a.y, r1 = a.r,\n      x2 = b.x, y2 = b.y, r2 = b.r,\n      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,\n      l = Math.sqrt(x21 * x21 + y21 * y21);\n  return {\n    x: (x1 + x2 + x21 / l * r21) / 2,\n    y: (y1 + y2 + y21 / l * r21) / 2,\n    r: (l + r1 + r2) / 2\n  };\n}\n\nfunction encloseBasis3(a, b, c) {\n  var x1 = a.x, y1 = a.y, r1 = a.r,\n      x2 = b.x, y2 = b.y, r2 = b.r,\n      x3 = c.x, y3 = c.y, r3 = c.r,\n      a2 = x1 - x2,\n      a3 = x1 - x3,\n      b2 = y1 - y2,\n      b3 = y1 - y3,\n      c2 = r2 - r1,\n      c3 = r3 - r1,\n      d1 = x1 * x1 + y1 * y1 - r1 * r1,\n      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,\n      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,\n      ab = a3 * b2 - a2 * b3,\n      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,\n      xb = (b3 * c2 - b2 * c3) / ab,\n      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,\n      yb = (a2 * c3 - a3 * c2) / ab,\n      A = xb * xb + yb * yb - 1,\n      B = 2 * (r1 + xa * xb + ya * yb),\n      C = xa * xa + ya * ya - r1 * r1,\n      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);\n  return {\n    x: x1 + xa + xb * r,\n    y: y1 + ya + yb * r,\n    r: r\n  };\n}\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/pack/siblings.js\n\n\nfunction place(b, a, c) {\n  var dx = b.x - a.x, x, a2,\n      dy = b.y - a.y, y, b2,\n      d2 = dx * dx + dy * dy;\n  if (d2) {\n    a2 = a.r + c.r, a2 *= a2;\n    b2 = b.r + c.r, b2 *= b2;\n    if (a2 > b2) {\n      x = (d2 + b2 - a2) / (2 * d2);\n      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));\n      c.x = b.x - x * dx - y * dy;\n      c.y = b.y - x * dy + y * dx;\n    } else {\n      x = (d2 + a2 - b2) / (2 * d2);\n      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));\n      c.x = a.x + x * dx - y * dy;\n      c.y = a.y + x * dy + y * dx;\n    }\n  } else {\n    c.x = a.x + c.r;\n    c.y = a.y;\n  }\n}\n\nfunction intersects(a, b) {\n  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\n\nfunction score(node) {\n  var a = node._,\n      b = node.next._,\n      ab = a.r + b.r,\n      dx = (a.x * b.r + b.x * a.r) / ab,\n      dy = (a.y * b.r + b.y * a.r) / ab;\n  return dx * dx + dy * dy;\n}\n\nfunction siblings_Node(circle) {\n  this._ = circle;\n  this.next = null;\n  this.previous = null;\n}\n\nfunction packEnclose(circles) {\n  if (!(n = circles.length)) return 0;\n\n  var a, b, c, n, aa, ca, i, j, k, sj, sk;\n\n  // Place the first circle.\n  a = circles[0], a.x = 0, a.y = 0;\n  if (!(n > 1)) return a.r;\n\n  // Place the second circle.\n  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;\n  if (!(n > 2)) return a.r + b.r;\n\n  // Place the third circle.\n  place(b, a, c = circles[2]);\n\n  // Initialize the front-chain using the first three circles a, b and c.\n  a = new siblings_Node(a), b = new siblings_Node(b), c = new siblings_Node(c);\n  a.next = c.previous = b;\n  b.next = a.previous = c;\n  c.next = b.previous = a;\n\n  // Attempt to place each remaining circle…\n  pack: for (i = 3; i < n; ++i) {\n    place(a._, b._, c = circles[i]), c = new siblings_Node(c);\n\n    // Find the closest intersecting circle on the front-chain, if any.\n    // “Closeness” is determined by linear distance along the front-chain.\n    // “Ahead” or “behind” is likewise determined by linear distance.\n    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;\n    do {\n      if (sj <= sk) {\n        if (intersects(j._, c._)) {\n          b = j, a.next = b, b.previous = a, --i;\n          continue pack;\n        }\n        sj += j._.r, j = j.next;\n      } else {\n        if (intersects(k._, c._)) {\n          a = k, a.next = b, b.previous = a, --i;\n          continue pack;\n        }\n        sk += k._.r, k = k.previous;\n      }\n    } while (j !== k.next);\n\n    // Success! Insert the new circle c between a and b.\n    c.previous = a, c.next = b, a.next = b.previous = b = c;\n\n    // Compute the new closest circle pair to the centroid.\n    aa = score(a);\n    while ((c = c.next) !== b) {\n      if ((ca = score(c)) < aa) {\n        a = c, aa = ca;\n      }\n    }\n    b = a.next;\n  }\n\n  // Compute the enclosing circle of the front chain.\n  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);\n\n  // Translate the circles to put the enclosing circle around the origin.\n  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;\n\n  return c.r;\n}\n\n/* harmony default export */ var siblings = (function(circles) {\n  packEnclose(circles);\n  return circles;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/accessors.js\nfunction optional(f) {\n  return f == null ? null : required(f);\n}\n\nfunction required(f) {\n  if (typeof f !== "function") throw new Error;\n  return f;\n}\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/constant.js\nfunction constantZero() {\n  return 0;\n}\n\n/* harmony default export */ var constant = (function(x) {\n  return function() {\n    return x;\n  };\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/pack/index.js\n\n\n\n\nfunction defaultRadius(d) {\n  return Math.sqrt(d.value);\n}\n\n/* harmony default export */ var src_pack = (function() {\n  var radius = null,\n      dx = 1,\n      dy = 1,\n      padding = constantZero;\n\n  function pack(root) {\n    root.x = dx / 2, root.y = dy / 2;\n    if (radius) {\n      root.eachBefore(radiusLeaf(radius))\n          .eachAfter(packChildren(padding, 0.5))\n          .eachBefore(translateChild(1));\n    } else {\n      root.eachBefore(radiusLeaf(defaultRadius))\n          .eachAfter(packChildren(constantZero, 1))\n          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))\n          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));\n    }\n    return root;\n  }\n\n  pack.radius = function(x) {\n    return arguments.length ? (radius = optional(x), pack) : radius;\n  };\n\n  pack.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];\n  };\n\n  pack.padding = function(x) {\n    return arguments.length ? (padding = typeof x === "function" ? x : constant(+x), pack) : padding;\n  };\n\n  return pack;\n});\n\nfunction radiusLeaf(radius) {\n  return function(node) {\n    if (!node.children) {\n      node.r = Math.max(0, +radius(node) || 0);\n    }\n  };\n}\n\nfunction packChildren(padding, k) {\n  return function(node) {\n    if (children = node.children) {\n      var children,\n          i,\n          n = children.length,\n          r = padding(node) * k || 0,\n          e;\n\n      if (r) for (i = 0; i < n; ++i) children[i].r += r;\n      e = packEnclose(children);\n      if (r) for (i = 0; i < n; ++i) children[i].r -= r;\n      node.r = e + r;\n    }\n  };\n}\n\nfunction translateChild(k) {\n  return function(node) {\n    var parent = node.parent;\n    node.r *= k;\n    if (parent) {\n      node.x = parent.x + k * node.x;\n      node.y = parent.y + k * node.y;\n    }\n  };\n}\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/treemap/round.js\n/* harmony default export */ var treemap_round = (function(node) {\n  node.x0 = Math.round(node.x0);\n  node.y0 = Math.round(node.y0);\n  node.x1 = Math.round(node.x1);\n  node.y1 = Math.round(node.y1);\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/treemap/dice.js\n/* harmony default export */ var dice = (function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (x1 - x0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.y0 = y0, node.y1 = y1;\n    node.x0 = x0, node.x1 = x0 += node.value * k;\n  }\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/partition.js\n\n\n\n/* harmony default export */ var src_partition = (function() {\n  var dx = 1,\n      dy = 1,\n      padding = 0,\n      round = false;\n\n  function partition(root) {\n    var n = root.height + 1;\n    root.x0 =\n    root.y0 = padding;\n    root.x1 = dx;\n    root.y1 = dy / n;\n    root.eachBefore(positionNode(dy, n));\n    if (round) root.eachBefore(treemap_round);\n    return root;\n  }\n\n  function positionNode(dy, n) {\n    return function(node) {\n      if (node.children) {\n        dice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);\n      }\n      var x0 = node.x0,\n          y0 = node.y0,\n          x1 = node.x1 - padding,\n          y1 = node.y1 - padding;\n      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n      node.x0 = x0;\n      node.y0 = y0;\n      node.x1 = x1;\n      node.y1 = y1;\n    };\n  }\n\n  partition.round = function(x) {\n    return arguments.length ? (round = !!x, partition) : round;\n  };\n\n  partition.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];\n  };\n\n  partition.padding = function(x) {\n    return arguments.length ? (padding = +x, partition) : padding;\n  };\n\n  return partition;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/stratify.js\n\n\n\nvar keyPrefix = "$", // Protect against keys like “__proto__”.\n    preroot = {depth: -1},\n    ambiguous = {};\n\nfunction defaultId(d) {\n  return d.id;\n}\n\nfunction defaultParentId(d) {\n  return d.parentId;\n}\n\n/* harmony default export */ var src_stratify = (function() {\n  var id = defaultId,\n      parentId = defaultParentId;\n\n  function stratify(data) {\n    var d,\n        i,\n        n = data.length,\n        root,\n        parent,\n        node,\n        nodes = new Array(n),\n        nodeId,\n        nodeKey,\n        nodeByKey = {};\n\n    for (i = 0; i < n; ++i) {\n      d = data[i], node = nodes[i] = new Node(d);\n      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {\n        nodeKey = keyPrefix + (node.id = nodeId);\n        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;\n      }\n    }\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i], nodeId = parentId(data[i], i, data);\n      if (nodeId == null || !(nodeId += "")) {\n        if (root) throw new Error("multiple roots");\n        root = node;\n      } else {\n        parent = nodeByKey[keyPrefix + nodeId];\n        if (!parent) throw new Error("missing: " + nodeId);\n        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);\n        if (parent.children) parent.children.push(node);\n        else parent.children = [node];\n        node.parent = parent;\n      }\n    }\n\n    if (!root) throw new Error("no root");\n    root.parent = preroot;\n    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);\n    root.parent = null;\n    if (n > 0) throw new Error("cycle");\n\n    return root;\n  }\n\n  stratify.id = function(x) {\n    return arguments.length ? (id = required(x), stratify) : id;\n  };\n\n  stratify.parentId = function(x) {\n    return arguments.length ? (parentId = required(x), stratify) : parentId;\n  };\n\n  return stratify;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/tree.js\n\n\nfunction tree_defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\n// function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n}\n\n// This function works analogously to nextLeft.\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n}\n\n// Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\n\n// All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\n\n// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,\n// returns the specified (default) ancestor.\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n  this.a = this; // ancestor\n  this.z = 0; // prelim\n  this.m = 0; // mod\n  this.c = 0; // change\n  this.s = 0; // shift\n  this.t = null; // thread\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n}\n\n// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm\n/* harmony default export */ var tree = (function() {\n  var separation = tree_defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root);\n\n    // Compute the layout using Buchheim et al.’s algorithm.\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk);\n\n    // If a fixed node size is specified, scale x and y.\n    if (nodeSize) root.eachBefore(sizeNode);\n\n    // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n      var left = root,\n          right = root,\n          bottom = root;\n      root.eachBefore(function(node) {\n        if (node.x < left.x) left = node;\n        if (node.x > right.x) right = node;\n        if (node.depth > bottom.depth) bottom = node;\n      });\n      var s = left === right ? 1 : separation(left, right) / 2,\n          tx = s - left.x,\n          kx = dx / (right.x + s + tx),\n          ky = dy / (bottom.depth || 1);\n      root.eachBefore(function(node) {\n        node.x = (node.x + tx) * kx;\n        node.y = node.depth * ky;\n      });\n    }\n\n    return root;\n  }\n\n  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  }\n\n  // Computes all real x-coordinates by summing up the modifiers recursively.\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  }\n\n  // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function(x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\n  };\n\n  tree.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return tree;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/treemap/slice.js\n/* harmony default export */ var treemap_slice = (function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (y1 - y0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.x0 = x0, node.x1 = x1;\n    node.y0 = y0, node.y1 = y0 += node.value * k;\n  }\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/treemap/squarify.js\n\n\n\nvar phi = (1 + Math.sqrt(5)) / 2;\n\nfunction squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n  var rows = [],\n      nodes = parent.children,\n      row,\n      nodeValue,\n      i0 = 0,\n      i1 = 0,\n      n = nodes.length,\n      dx, dy,\n      value = parent.value,\n      sumValue,\n      minValue,\n      maxValue,\n      newRatio,\n      minRatio,\n      alpha,\n      beta;\n\n  while (i0 < n) {\n    dx = x1 - x0, dy = y1 - y0;\n\n    // Find the next non-empty node.\n    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n\n    // Keep adding nodes while the aspect ratio maintains or improves.\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue) minValue = nodeValue;\n      if (nodeValue > maxValue) maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) { sumValue -= nodeValue; break; }\n      minRatio = newRatio;\n    }\n\n    // Position and record the row orientation.\n    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});\n    if (row.dice) dice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n    else treemap_slice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n    value -= sumValue, i0 = i1;\n  }\n\n  return rows;\n}\n\n/* harmony default export */ var squarify = ((function custom(ratio) {\n\n  function squarify(parent, x0, y0, x1, y1) {\n    squarifyRatio(ratio, parent, x0, y0, x1, y1);\n  }\n\n  squarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return squarify;\n})(phi));\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/treemap/index.js\n\n\n\n\n\n/* harmony default export */ var src_treemap = (function() {\n  var tile = squarify,\n      round = false,\n      dx = 1,\n      dy = 1,\n      paddingStack = [0],\n      paddingInner = constantZero,\n      paddingTop = constantZero,\n      paddingRight = constantZero,\n      paddingBottom = constantZero,\n      paddingLeft = constantZero;\n\n  function treemap(root) {\n    root.x0 =\n    root.y0 = 0;\n    root.x1 = dx;\n    root.y1 = dy;\n    root.eachBefore(positionNode);\n    paddingStack = [0];\n    if (round) root.eachBefore(treemap_round);\n    return root;\n  }\n\n  function positionNode(node) {\n    var p = paddingStack[node.depth],\n        x0 = node.x0 + p,\n        y0 = node.y0 + p,\n        x1 = node.x1 - p,\n        y1 = node.y1 - p;\n    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n    node.x0 = x0;\n    node.y0 = y0;\n    node.x1 = x1;\n    node.y1 = y1;\n    if (node.children) {\n      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;\n      x0 += paddingLeft(node) - p;\n      y0 += paddingTop(node) - p;\n      x1 -= paddingRight(node) - p;\n      y1 -= paddingBottom(node) - p;\n      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n      tile(node, x0, y0, x1, y1);\n    }\n  }\n\n  treemap.round = function(x) {\n    return arguments.length ? (round = !!x, treemap) : round;\n  };\n\n  treemap.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];\n  };\n\n  treemap.tile = function(x) {\n    return arguments.length ? (tile = required(x), treemap) : tile;\n  };\n\n  treemap.padding = function(x) {\n    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();\n  };\n\n  treemap.paddingInner = function(x) {\n    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant(+x), treemap) : paddingInner;\n  };\n\n  treemap.paddingOuter = function(x) {\n    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();\n  };\n\n  treemap.paddingTop = function(x) {\n    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant(+x), treemap) : paddingTop;\n  };\n\n  treemap.paddingRight = function(x) {\n    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant(+x), treemap) : paddingRight;\n  };\n\n  treemap.paddingBottom = function(x) {\n    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant(+x), treemap) : paddingBottom;\n  };\n\n  treemap.paddingLeft = function(x) {\n    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant(+x), treemap) : paddingLeft;\n  };\n\n  return treemap;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/treemap/binary.js\n/* harmony default export */ var binary = (function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      i, n = nodes.length,\n      sum, sums = new Array(n + 1);\n\n  for (sums[0] = sum = i = 0; i < n; ++i) {\n    sums[i + 1] = sum += nodes[i].value;\n  }\n\n  partition(0, n, parent.value, x0, y0, x1, y1);\n\n  function partition(i, j, value, x0, y0, x1, y1) {\n    if (i >= j - 1) {\n      var node = nodes[i];\n      node.x0 = x0, node.y0 = y0;\n      node.x1 = x1, node.y1 = y1;\n      return;\n    }\n\n    var valueOffset = sums[i],\n        valueTarget = (value / 2) + valueOffset,\n        k = i + 1,\n        hi = j - 1;\n\n    while (k < hi) {\n      var mid = k + hi >>> 1;\n      if (sums[mid] < valueTarget) k = mid + 1;\n      else hi = mid;\n    }\n\n    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;\n\n    var valueLeft = sums[k] - valueOffset,\n        valueRight = value - valueLeft;\n\n    if ((x1 - x0) > (y1 - y0)) {\n      var xk = (x0 * valueRight + x1 * valueLeft) / value;\n      partition(i, k, valueLeft, x0, y0, xk, y1);\n      partition(k, j, valueRight, xk, y0, x1, y1);\n    } else {\n      var yk = (y0 * valueRight + y1 * valueLeft) / value;\n      partition(i, k, valueLeft, x0, y0, x1, yk);\n      partition(k, j, valueRight, x0, yk, x1, y1);\n    }\n  }\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/treemap/sliceDice.js\n\n\n\n/* harmony default export */ var sliceDice = (function(parent, x0, y0, x1, y1) {\n  (parent.depth & 1 ? treemap_slice : dice)(parent, x0, y0, x1, y1);\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/treemap/resquarify.js\n\n\n\n\n/* harmony default export */ var treemap_resquarify = ((function custom(ratio) {\n\n  function resquarify(parent, x0, y0, x1, y1) {\n    if ((rows = parent._squarify) && (rows.ratio === ratio)) {\n      var rows,\n          row,\n          nodes,\n          i,\n          j = -1,\n          n,\n          m = rows.length,\n          value = parent.value;\n\n      while (++j < m) {\n        row = rows[j], nodes = row.children;\n        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;\n        if (row.dice) dice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);\n        else treemap_slice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);\n        value -= row.value;\n      }\n    } else {\n      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);\n      rows.ratio = ratio;\n    }\n  }\n\n  resquarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return resquarify;\n})(phi));\n\n// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/index.js\n/* concated harmony reexport cluster */__webpack_require__.d(__webpack_exports__, "cluster", function() { return cluster; });\n/* concated harmony reexport hierarchy */__webpack_require__.d(__webpack_exports__, "hierarchy", function() { return hierarchy; });\n/* concated harmony reexport pack */__webpack_require__.d(__webpack_exports__, "pack", function() { return src_pack; });\n/* concated harmony reexport packSiblings */__webpack_require__.d(__webpack_exports__, "packSiblings", function() { return siblings; });\n/* concated harmony reexport packEnclose */__webpack_require__.d(__webpack_exports__, "packEnclose", function() { return enclose; });\n/* concated harmony reexport partition */__webpack_require__.d(__webpack_exports__, "partition", function() { return src_partition; });\n/* concated harmony reexport stratify */__webpack_require__.d(__webpack_exports__, "stratify", function() { return src_stratify; });\n/* concated harmony reexport tree */__webpack_require__.d(__webpack_exports__, "tree", function() { return tree; });\n/* concated harmony reexport treemap */__webpack_require__.d(__webpack_exports__, "treemap", function() { return src_treemap; });\n/* concated harmony reexport treemapBinary */__webpack_require__.d(__webpack_exports__, "treemapBinary", function() { return binary; });\n/* concated harmony reexport treemapDice */__webpack_require__.d(__webpack_exports__, "treemapDice", function() { return dice; });\n/* concated harmony reexport treemapSlice */__webpack_require__.d(__webpack_exports__, "treemapSlice", function() { return treemap_slice; });\n/* concated harmony reexport treemapSliceDice */__webpack_require__.d(__webpack_exports__, "treemapSliceDice", function() { return sliceDice; });\n/* concated harmony reexport treemapSquarify */__webpack_require__.d(__webpack_exports__, "treemapSquarify", function() { return squarify; });\n/* concated harmony reexport treemapResquarify */__webpack_require__.d(__webpack_exports__, "treemapResquarify", function() { return treemap_resquarify; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9jbHVzdGVyLmpzP2NlOTciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2NvdW50LmpzP2RlOTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2VhY2guanM/ZWIxZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvZWFjaEJlZm9yZS5qcz8zZDg3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL2hpZXJhcmNoeS9lYWNoQWZ0ZXIuanM/OWUzMiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvc3VtLmpzPzZjOTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L3NvcnQuanM/YmE2NiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvcGF0aC5qcz8yNzZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL2hpZXJhcmNoeS9hbmNlc3RvcnMuanM/NGJmYSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvZGVzY2VuZGFudHMuanM/ZjkzOCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvbGVhdmVzLmpzP2JmZmEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2xpbmtzLmpzPzRhMGIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2luZGV4LmpzPzZiY2IiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvYXJyYXkuanM/OGY1MCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9wYWNrL2VuY2xvc2UuanM/ZWNjYiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9wYWNrL3NpYmxpbmdzLmpzPzViZTIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvYWNjZXNzb3JzLmpzPzIxZTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvY29uc3RhbnQuanM/MDkyYiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9wYWNrL2luZGV4LmpzPzIzNzMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvdHJlZW1hcC9yb3VuZC5qcz8wZGQ0Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL3RyZWVtYXAvZGljZS5qcz8xNGYzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL3BhcnRpdGlvbi5qcz9mOGQ3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL3N0cmF0aWZ5LmpzPzM1NGUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvdHJlZS5qcz81MDcwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL3RyZWVtYXAvc2xpY2UuanM/ZWM4MyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy90cmVlbWFwL3NxdWFyaWZ5LmpzPzIzODgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvdHJlZW1hcC9pbmRleC5qcz9iNmY0Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL3RyZWVtYXAvYmluYXJ5LmpzPzhhZjMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvdHJlZW1hcC9zbGljZURpY2UuanM/MDgzMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy90cmVlbWFwL3Jlc3F1YXJpZnkuanM/ZDQyNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9pbmRleC5qcz9jOTQ3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQ25GRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQSxDQUFDOzs7QUNYYztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUNaYztBQUNmO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxR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O0FBQ2xDLENBQUM7OztBQ0xnQztBQUNFO0FBQ1c7O0FBRS9COztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RCxzQkFBc0IsSUFBVztBQUNqQyxhQUFhLGFBQVk7QUFDekI7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFDOzs7QUNuQ1I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTZDO0FBQ1U7QUFDVjtBQUNXO0FBQ0Y7QUFDTDtBQUNGO0FBQ1I7QUFDWTtBQUNPO0FBQ0o7QUFDRTtBQUNRO0FBQ0Y7QUFDSSIsImZpbGUiOiIyNjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBkZWZhdWx0U2VwYXJhdGlvbihhLCBiKSB7XG4gIHJldHVybiBhLnBhcmVudCA9PT0gYi5wYXJlbnQgPyAxIDogMjtcbn1cblxuZnVuY3Rpb24gbWVhblgoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGNoaWxkcmVuLnJlZHVjZShtZWFuWFJlZHVjZSwgMCkgLyBjaGlsZHJlbi5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIG1lYW5YUmVkdWNlKHgsIGMpIHtcbiAgcmV0dXJuIHggKyBjLng7XG59XG5cbmZ1bmN0aW9uIG1heFkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIDEgKyBjaGlsZHJlbi5yZWR1Y2UobWF4WVJlZHVjZSwgMCk7XG59XG5cbmZ1bmN0aW9uIG1heFlSZWR1Y2UoeSwgYykge1xuICByZXR1cm4gTWF0aC5tYXgoeSwgYy55KTtcbn1cblxuZnVuY3Rpb24gbGVhZkxlZnQobm9kZSkge1xuICB2YXIgY2hpbGRyZW47XG4gIHdoaWxlIChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pIG5vZGUgPSBjaGlsZHJlblswXTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGxlYWZSaWdodChub2RlKSB7XG4gIHZhciBjaGlsZHJlbjtcbiAgd2hpbGUgKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikgbm9kZSA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBzZXBhcmF0aW9uID0gZGVmYXVsdFNlcGFyYXRpb24sXG4gICAgICBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBub2RlU2l6ZSA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGNsdXN0ZXIocm9vdCkge1xuICAgIHZhciBwcmV2aW91c05vZGUsXG4gICAgICAgIHggPSAwO1xuXG4gICAgLy8gRmlyc3Qgd2FsaywgY29tcHV0aW5nIHRoZSBpbml0aWFsIHggJiB5IHZhbHVlcy5cbiAgICByb290LmVhY2hBZnRlcihmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIG5vZGUueCA9IG1lYW5YKGNoaWxkcmVuKTtcbiAgICAgICAgbm9kZS55ID0gbWF4WShjaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnggPSBwcmV2aW91c05vZGUgPyB4ICs9IHNlcGFyYXRpb24obm9kZSwgcHJldmlvdXNOb2RlKSA6IDA7XG4gICAgICAgIG5vZGUueSA9IDA7XG4gICAgICAgIHByZXZpb3VzTm9kZSA9IG5vZGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgbGVmdCA9IGxlYWZMZWZ0KHJvb3QpLFxuICAgICAgICByaWdodCA9IGxlYWZSaWdodChyb290KSxcbiAgICAgICAgeDAgPSBsZWZ0LnggLSBzZXBhcmF0aW9uKGxlZnQsIHJpZ2h0KSAvIDIsXG4gICAgICAgIHgxID0gcmlnaHQueCArIHNlcGFyYXRpb24ocmlnaHQsIGxlZnQpIC8gMjtcblxuICAgIC8vIFNlY29uZCB3YWxrLCBub3JtYWxpemluZyB4ICYgeSB0byB0aGUgZGVzaXJlZCBzaXplLlxuICAgIHJldHVybiByb290LmVhY2hBZnRlcihub2RlU2l6ZSA/IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUueCA9IChub2RlLnggLSByb290LngpICogZHg7XG4gICAgICBub2RlLnkgPSAocm9vdC55IC0gbm9kZS55KSAqIGR5O1xuICAgIH0gOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLnggPSAobm9kZS54IC0geDApIC8gKHgxIC0geDApICogZHg7XG4gICAgICBub2RlLnkgPSAoMSAtIChyb290LnkgPyBub2RlLnkgLyByb290LnkgOiAxKSkgKiBkeTtcbiAgICB9KTtcbiAgfVxuXG4gIGNsdXN0ZXIuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzZXBhcmF0aW9uID0geCwgY2x1c3RlcikgOiBzZXBhcmF0aW9uO1xuICB9O1xuXG4gIGNsdXN0ZXIuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IGZhbHNlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCBjbHVzdGVyKSA6IChub2RlU2l6ZSA/IG51bGwgOiBbZHgsIGR5XSk7XG4gIH07XG5cbiAgY2x1c3Rlci5ub2RlU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IHRydWUsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIGNsdXN0ZXIpIDogKG5vZGVTaXplID8gW2R4LCBkeV0gOiBudWxsKTtcbiAgfTtcblxuICByZXR1cm4gY2x1c3Rlcjtcbn1cbiIsImZ1bmN0aW9uIGNvdW50KG5vZGUpIHtcbiAgdmFyIHN1bSA9IDAsXG4gICAgICBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4sXG4gICAgICBpID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAoIWkpIHN1bSA9IDE7XG4gIGVsc2Ugd2hpbGUgKC0taSA+PSAwKSBzdW0gKz0gY2hpbGRyZW5baV0udmFsdWU7XG4gIG5vZGUudmFsdWUgPSBzdW07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoQWZ0ZXIoY291bnQpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIG5vZGUgPSB0aGlzLCBjdXJyZW50LCBuZXh0ID0gW25vZGVdLCBjaGlsZHJlbiwgaSwgbjtcbiAgZG8ge1xuICAgIGN1cnJlbnQgPSBuZXh0LnJldmVyc2UoKSwgbmV4dCA9IFtdO1xuICAgIHdoaWxlIChub2RlID0gY3VycmVudC5wb3AoKSkge1xuICAgICAgY2FsbGJhY2sobm9kZSksIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbikgZm9yIChpID0gMCwgbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBuZXh0LnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAobmV4dC5sZW5ndGgpO1xuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBub2RlID0gdGhpcywgbm9kZXMgPSBbbm9kZV0sIGNoaWxkcmVuLCBpO1xuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgY2FsbGJhY2sobm9kZSksIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4pIGZvciAoaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBub2Rlcy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVzID0gW25vZGVdLCBuZXh0ID0gW10sIGNoaWxkcmVuLCBpLCBuO1xuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgbmV4dC5wdXNoKG5vZGUpLCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuKSBmb3IgKGkgPSAwLCBuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2Rlcy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKG5vZGUgPSBuZXh0LnBvcCgpKSB7XG4gICAgY2FsbGJhY2sobm9kZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5lYWNoQWZ0ZXIoZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBzdW0gPSArdmFsdWUobm9kZS5kYXRhKSB8fCAwLFxuICAgICAgICBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4sXG4gICAgICAgIGkgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7XG4gICAgd2hpbGUgKC0taSA+PSAwKSBzdW0gKz0gY2hpbGRyZW5baV0udmFsdWU7XG4gICAgbm9kZS52YWx1ZSA9IHN1bTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb21wYXJlKSB7XG4gIHJldHVybiB0aGlzLmVhY2hCZWZvcmUoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZSk7XG4gICAgfVxuICB9KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGVuZCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLFxuICAgICAgYW5jZXN0b3IgPSBsZWFzdENvbW1vbkFuY2VzdG9yKHN0YXJ0LCBlbmQpLFxuICAgICAgbm9kZXMgPSBbc3RhcnRdO1xuICB3aGlsZSAoc3RhcnQgIT09IGFuY2VzdG9yKSB7XG4gICAgc3RhcnQgPSBzdGFydC5wYXJlbnQ7XG4gICAgbm9kZXMucHVzaChzdGFydCk7XG4gIH1cbiAgdmFyIGsgPSBub2Rlcy5sZW5ndGg7XG4gIHdoaWxlIChlbmQgIT09IGFuY2VzdG9yKSB7XG4gICAgbm9kZXMuc3BsaWNlKGssIDAsIGVuZCk7XG4gICAgZW5kID0gZW5kLnBhcmVudDtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5cbmZ1bmN0aW9uIGxlYXN0Q29tbW9uQW5jZXN0b3IoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIGE7XG4gIHZhciBhTm9kZXMgPSBhLmFuY2VzdG9ycygpLFxuICAgICAgYk5vZGVzID0gYi5hbmNlc3RvcnMoKSxcbiAgICAgIGMgPSBudWxsO1xuICBhID0gYU5vZGVzLnBvcCgpO1xuICBiID0gYk5vZGVzLnBvcCgpO1xuICB3aGlsZSAoYSA9PT0gYikge1xuICAgIGMgPSBhO1xuICAgIGEgPSBhTm9kZXMucG9wKCk7XG4gICAgYiA9IGJOb2Rlcy5wb3AoKTtcbiAgfVxuICByZXR1cm4gYztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVzID0gW25vZGVdO1xuICB3aGlsZSAobm9kZSA9IG5vZGUucGFyZW50KSB7XG4gICAgbm9kZXMucHVzaChub2RlKTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGVzID0gW107XG4gIHRoaXMuZWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgbm9kZXMucHVzaChub2RlKTtcbiAgfSk7XG4gIHJldHVybiBub2Rlcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgbGVhdmVzID0gW107XG4gIHRoaXMuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICBsZWF2ZXMucHVzaChub2RlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbGVhdmVzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciByb290ID0gdGhpcywgbGlua3MgPSBbXTtcbiAgcm9vdC5lYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZSAhPT0gcm9vdCkgeyAvLyBEb27igJl0IGluY2x1ZGUgdGhlIHJvb3TigJlzIHBhcmVudCwgaWYgYW55LlxuICAgICAgbGlua3MucHVzaCh7c291cmNlOiBub2RlLnBhcmVudCwgdGFyZ2V0OiBub2RlfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGxpbmtzO1xufVxuIiwiaW1wb3J0IG5vZGVfY291bnQgZnJvbSBcIi4vY291bnRcIjtcbmltcG9ydCBub2RlX2VhY2ggZnJvbSBcIi4vZWFjaFwiO1xuaW1wb3J0IG5vZGVfZWFjaEJlZm9yZSBmcm9tIFwiLi9lYWNoQmVmb3JlXCI7XG5pbXBvcnQgbm9kZV9lYWNoQWZ0ZXIgZnJvbSBcIi4vZWFjaEFmdGVyXCI7XG5pbXBvcnQgbm9kZV9zdW0gZnJvbSBcIi4vc3VtXCI7XG5pbXBvcnQgbm9kZV9zb3J0IGZyb20gXCIuL3NvcnRcIjtcbmltcG9ydCBub2RlX3BhdGggZnJvbSBcIi4vcGF0aFwiO1xuaW1wb3J0IG5vZGVfYW5jZXN0b3JzIGZyb20gXCIuL2FuY2VzdG9yc1wiO1xuaW1wb3J0IG5vZGVfZGVzY2VuZGFudHMgZnJvbSBcIi4vZGVzY2VuZGFudHNcIjtcbmltcG9ydCBub2RlX2xlYXZlcyBmcm9tIFwiLi9sZWF2ZXNcIjtcbmltcG9ydCBub2RlX2xpbmtzIGZyb20gXCIuL2xpbmtzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhpZXJhcmNoeShkYXRhLCBjaGlsZHJlbikge1xuICB2YXIgcm9vdCA9IG5ldyBOb2RlKGRhdGEpLFxuICAgICAgdmFsdWVkID0gK2RhdGEudmFsdWUgJiYgKHJvb3QudmFsdWUgPSBkYXRhLnZhbHVlKSxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlcyA9IFtyb290XSxcbiAgICAgIGNoaWxkLFxuICAgICAgY2hpbGRzLFxuICAgICAgaSxcbiAgICAgIG47XG5cbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIGNoaWxkcmVuID0gZGVmYXVsdENoaWxkcmVuO1xuXG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBpZiAodmFsdWVkKSBub2RlLnZhbHVlID0gK25vZGUuZGF0YS52YWx1ZTtcbiAgICBpZiAoKGNoaWxkcyA9IGNoaWxkcmVuKG5vZGUuZGF0YSkpICYmIChuID0gY2hpbGRzLmxlbmd0aCkpIHtcbiAgICAgIG5vZGUuY2hpbGRyZW4gPSBuZXcgQXJyYXkobik7XG4gICAgICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbm9kZXMucHVzaChjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV0gPSBuZXcgTm9kZShjaGlsZHNbaV0pKTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gbm9kZTtcbiAgICAgICAgY2hpbGQuZGVwdGggPSBub2RlLmRlcHRoICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm9vdC5lYWNoQmVmb3JlKGNvbXB1dGVIZWlnaHQpO1xufVxuXG5mdW5jdGlvbiBub2RlX2NvcHkoKSB7XG4gIHJldHVybiBoaWVyYXJjaHkodGhpcykuZWFjaEJlZm9yZShjb3B5RGF0YSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDaGlsZHJlbihkKSB7XG4gIHJldHVybiBkLmNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjb3B5RGF0YShub2RlKSB7XG4gIG5vZGUuZGF0YSA9IG5vZGUuZGF0YS5kYXRhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhlaWdodChub2RlKSB7XG4gIHZhciBoZWlnaHQgPSAwO1xuICBkbyBub2RlLmhlaWdodCA9IGhlaWdodDtcbiAgd2hpbGUgKChub2RlID0gbm9kZS5wYXJlbnQpICYmIChub2RlLmhlaWdodCA8ICsraGVpZ2h0KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBOb2RlKGRhdGEpIHtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5kZXB0aCA9XG4gIHRoaXMuaGVpZ2h0ID0gMDtcbiAgdGhpcy5wYXJlbnQgPSBudWxsO1xufVxuXG5Ob2RlLnByb3RvdHlwZSA9IGhpZXJhcmNoeS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBOb2RlLFxuICBjb3VudDogbm9kZV9jb3VudCxcbiAgZWFjaDogbm9kZV9lYWNoLFxuICBlYWNoQWZ0ZXI6IG5vZGVfZWFjaEFmdGVyLFxuICBlYWNoQmVmb3JlOiBub2RlX2VhY2hCZWZvcmUsXG4gIHN1bTogbm9kZV9zdW0sXG4gIHNvcnQ6IG5vZGVfc29ydCxcbiAgcGF0aDogbm9kZV9wYXRoLFxuICBhbmNlc3RvcnM6IG5vZGVfYW5jZXN0b3JzLFxuICBkZXNjZW5kYW50czogbm9kZV9kZXNjZW5kYW50cyxcbiAgbGVhdmVzOiBub2RlX2xlYXZlcyxcbiAgbGlua3M6IG5vZGVfbGlua3MsXG4gIGNvcHk6IG5vZGVfY29weVxufTtcbiIsImV4cG9ydCB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaHVmZmxlKGFycmF5KSB7XG4gIHZhciBtID0gYXJyYXkubGVuZ3RoLFxuICAgICAgdCxcbiAgICAgIGk7XG5cbiAgd2hpbGUgKG0pIHtcbiAgICBpID0gTWF0aC5yYW5kb20oKSAqIG0tLSB8IDA7XG4gICAgdCA9IGFycmF5W21dO1xuICAgIGFycmF5W21dID0gYXJyYXlbaV07XG4gICAgYXJyYXlbaV0gPSB0O1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuIiwiaW1wb3J0IHtzaHVmZmxlLCBzbGljZX0gZnJvbSBcIi4uL2FycmF5XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNpcmNsZXMpIHtcbiAgdmFyIGkgPSAwLCBuID0gKGNpcmNsZXMgPSBzaHVmZmxlKHNsaWNlLmNhbGwoY2lyY2xlcykpKS5sZW5ndGgsIEIgPSBbXSwgcCwgZTtcblxuICB3aGlsZSAoaSA8IG4pIHtcbiAgICBwID0gY2lyY2xlc1tpXTtcbiAgICBpZiAoZSAmJiBlbmNsb3Nlc1dlYWsoZSwgcCkpICsraTtcbiAgICBlbHNlIGUgPSBlbmNsb3NlQmFzaXMoQiA9IGV4dGVuZEJhc2lzKEIsIHApKSwgaSA9IDA7XG4gIH1cblxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kQmFzaXMoQiwgcCkge1xuICB2YXIgaSwgajtcblxuICBpZiAoZW5jbG9zZXNXZWFrQWxsKHAsIEIpKSByZXR1cm4gW3BdO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIHRoZW4gQiBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVsZW1lbnQuXG4gIGZvciAoaSA9IDA7IGkgPCBCLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGVuY2xvc2VzTm90KHAsIEJbaV0pXG4gICAgICAgICYmIGVuY2xvc2VzV2Vha0FsbChlbmNsb3NlQmFzaXMyKEJbaV0sIHApLCBCKSkge1xuICAgICAgcmV0dXJuIFtCW2ldLCBwXTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIEIgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBlbGVtZW50cy5cbiAgZm9yIChpID0gMDsgaSA8IEIubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgZm9yIChqID0gaSArIDE7IGogPCBCLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoZW5jbG9zZXNOb3QoZW5jbG9zZUJhc2lzMihCW2ldLCBCW2pdKSwgcClcbiAgICAgICAgICAmJiBlbmNsb3Nlc05vdChlbmNsb3NlQmFzaXMyKEJbaV0sIHApLCBCW2pdKVxuICAgICAgICAgICYmIGVuY2xvc2VzTm90KGVuY2xvc2VCYXNpczIoQltqXSwgcCksIEJbaV0pXG4gICAgICAgICAgJiYgZW5jbG9zZXNXZWFrQWxsKGVuY2xvc2VCYXNpczMoQltpXSwgQltqXSwgcCksIEIpKSB7XG4gICAgICAgIHJldHVybiBbQltpXSwgQltqXSwgcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgdGhlbiBzb21ldGhpbmcgaXMgdmVyeSB3cm9uZy5cbiAgdGhyb3cgbmV3IEVycm9yO1xufVxuXG5mdW5jdGlvbiBlbmNsb3Nlc05vdChhLCBiKSB7XG4gIHZhciBkciA9IGEuciAtIGIuciwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPCAwIHx8IGRyICogZHIgPCBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZXNXZWFrKGEsIGIpIHtcbiAgdmFyIGRyID0gYS5yIC0gYi5yICsgMWUtNiwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPiAwICYmIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZXNXZWFrQWxsKGEsIEIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBCLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFlbmNsb3Nlc1dlYWsoYSwgQltpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VCYXNpcyhCKSB7XG4gIHN3aXRjaCAoQi5sZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBlbmNsb3NlQmFzaXMxKEJbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGVuY2xvc2VCYXNpczIoQlswXSwgQlsxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZW5jbG9zZUJhc2lzMyhCWzBdLCBCWzFdLCBCWzJdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMxKGEpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBhLngsXG4gICAgeTogYS55LFxuICAgIHI6IGEuclxuICB9O1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMyKGEsIGIpIHtcbiAgdmFyIHgxID0gYS54LCB5MSA9IGEueSwgcjEgPSBhLnIsXG4gICAgICB4MiA9IGIueCwgeTIgPSBiLnksIHIyID0gYi5yLFxuICAgICAgeDIxID0geDIgLSB4MSwgeTIxID0geTIgLSB5MSwgcjIxID0gcjIgLSByMSxcbiAgICAgIGwgPSBNYXRoLnNxcnQoeDIxICogeDIxICsgeTIxICogeTIxKTtcbiAgcmV0dXJuIHtcbiAgICB4OiAoeDEgKyB4MiArIHgyMSAvIGwgKiByMjEpIC8gMixcbiAgICB5OiAoeTEgKyB5MiArIHkyMSAvIGwgKiByMjEpIC8gMixcbiAgICByOiAobCArIHIxICsgcjIpIC8gMlxuICB9O1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMzKGEsIGIsIGMpIHtcbiAgdmFyIHgxID0gYS54LCB5MSA9IGEueSwgcjEgPSBhLnIsXG4gICAgICB4MiA9IGIueCwgeTIgPSBiLnksIHIyID0gYi5yLFxuICAgICAgeDMgPSBjLngsIHkzID0gYy55LCByMyA9IGMucixcbiAgICAgIGEyID0geDEgLSB4MixcbiAgICAgIGEzID0geDEgLSB4MyxcbiAgICAgIGIyID0geTEgLSB5MixcbiAgICAgIGIzID0geTEgLSB5MyxcbiAgICAgIGMyID0gcjIgLSByMSxcbiAgICAgIGMzID0gcjMgLSByMSxcbiAgICAgIGQxID0geDEgKiB4MSArIHkxICogeTEgLSByMSAqIHIxLFxuICAgICAgZDIgPSBkMSAtIHgyICogeDIgLSB5MiAqIHkyICsgcjIgKiByMixcbiAgICAgIGQzID0gZDEgLSB4MyAqIHgzIC0geTMgKiB5MyArIHIzICogcjMsXG4gICAgICBhYiA9IGEzICogYjIgLSBhMiAqIGIzLFxuICAgICAgeGEgPSAoYjIgKiBkMyAtIGIzICogZDIpIC8gKGFiICogMikgLSB4MSxcbiAgICAgIHhiID0gKGIzICogYzIgLSBiMiAqIGMzKSAvIGFiLFxuICAgICAgeWEgPSAoYTMgKiBkMiAtIGEyICogZDMpIC8gKGFiICogMikgLSB5MSxcbiAgICAgIHliID0gKGEyICogYzMgLSBhMyAqIGMyKSAvIGFiLFxuICAgICAgQSA9IHhiICogeGIgKyB5YiAqIHliIC0gMSxcbiAgICAgIEIgPSAyICogKHIxICsgeGEgKiB4YiArIHlhICogeWIpLFxuICAgICAgQyA9IHhhICogeGEgKyB5YSAqIHlhIC0gcjEgKiByMSxcbiAgICAgIHIgPSAtKEEgPyAoQiArIE1hdGguc3FydChCICogQiAtIDQgKiBBICogQykpIC8gKDIgKiBBKSA6IEMgLyBCKTtcbiAgcmV0dXJuIHtcbiAgICB4OiB4MSArIHhhICsgeGIgKiByLFxuICAgIHk6IHkxICsgeWEgKyB5YiAqIHIsXG4gICAgcjogclxuICB9O1xufVxuIiwiaW1wb3J0IGVuY2xvc2UgZnJvbSBcIi4vZW5jbG9zZVwiO1xuXG5mdW5jdGlvbiBwbGFjZShiLCBhLCBjKSB7XG4gIHZhciBkeCA9IGIueCAtIGEueCwgeCwgYTIsXG4gICAgICBkeSA9IGIueSAtIGEueSwgeSwgYjIsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICBpZiAoZDIpIHtcbiAgICBhMiA9IGEuciArIGMuciwgYTIgKj0gYTI7XG4gICAgYjIgPSBiLnIgKyBjLnIsIGIyICo9IGIyO1xuICAgIGlmIChhMiA+IGIyKSB7XG4gICAgICB4ID0gKGQyICsgYjIgLSBhMikgLyAoMiAqIGQyKTtcbiAgICAgIHkgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgYjIgLyBkMiAtIHggKiB4KSk7XG4gICAgICBjLnggPSBiLnggLSB4ICogZHggLSB5ICogZHk7XG4gICAgICBjLnkgPSBiLnkgLSB4ICogZHkgKyB5ICogZHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAoZDIgKyBhMiAtIGIyKSAvICgyICogZDIpO1xuICAgICAgeSA9IE1hdGguc3FydChNYXRoLm1heCgwLCBhMiAvIGQyIC0geCAqIHgpKTtcbiAgICAgIGMueCA9IGEueCArIHggKiBkeCAtIHkgKiBkeTtcbiAgICAgIGMueSA9IGEueSArIHggKiBkeSArIHkgKiBkeDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYy54ID0gYS54ICsgYy5yO1xuICAgIGMueSA9IGEueTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcbiAgdmFyIGRyID0gYS5yICsgYi5yIC0gMWUtNiwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPiAwICYmIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gc2NvcmUobm9kZSkge1xuICB2YXIgYSA9IG5vZGUuXyxcbiAgICAgIGIgPSBub2RlLm5leHQuXyxcbiAgICAgIGFiID0gYS5yICsgYi5yLFxuICAgICAgZHggPSAoYS54ICogYi5yICsgYi54ICogYS5yKSAvIGFiLFxuICAgICAgZHkgPSAoYS55ICogYi5yICsgYi55ICogYS5yKSAvIGFiO1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbmZ1bmN0aW9uIE5vZGUoY2lyY2xlKSB7XG4gIHRoaXMuXyA9IGNpcmNsZTtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWNrRW5jbG9zZShjaXJjbGVzKSB7XG4gIGlmICghKG4gPSBjaXJjbGVzLmxlbmd0aCkpIHJldHVybiAwO1xuXG4gIHZhciBhLCBiLCBjLCBuLCBhYSwgY2EsIGksIGosIGssIHNqLCBzaztcblxuICAvLyBQbGFjZSB0aGUgZmlyc3QgY2lyY2xlLlxuICBhID0gY2lyY2xlc1swXSwgYS54ID0gMCwgYS55ID0gMDtcbiAgaWYgKCEobiA+IDEpKSByZXR1cm4gYS5yO1xuXG4gIC8vIFBsYWNlIHRoZSBzZWNvbmQgY2lyY2xlLlxuICBiID0gY2lyY2xlc1sxXSwgYS54ID0gLWIuciwgYi54ID0gYS5yLCBiLnkgPSAwO1xuICBpZiAoIShuID4gMikpIHJldHVybiBhLnIgKyBiLnI7XG5cbiAgLy8gUGxhY2UgdGhlIHRoaXJkIGNpcmNsZS5cbiAgcGxhY2UoYiwgYSwgYyA9IGNpcmNsZXNbMl0pO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIGZyb250LWNoYWluIHVzaW5nIHRoZSBmaXJzdCB0aHJlZSBjaXJjbGVzIGEsIGIgYW5kIGMuXG4gIGEgPSBuZXcgTm9kZShhKSwgYiA9IG5ldyBOb2RlKGIpLCBjID0gbmV3IE5vZGUoYyk7XG4gIGEubmV4dCA9IGMucHJldmlvdXMgPSBiO1xuICBiLm5leHQgPSBhLnByZXZpb3VzID0gYztcbiAgYy5uZXh0ID0gYi5wcmV2aW91cyA9IGE7XG5cbiAgLy8gQXR0ZW1wdCB0byBwbGFjZSBlYWNoIHJlbWFpbmluZyBjaXJjbGXigKZcbiAgcGFjazogZm9yIChpID0gMzsgaSA8IG47ICsraSkge1xuICAgIHBsYWNlKGEuXywgYi5fLCBjID0gY2lyY2xlc1tpXSksIGMgPSBuZXcgTm9kZShjKTtcblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW5nIGNpcmNsZSBvbiB0aGUgZnJvbnQtY2hhaW4sIGlmIGFueS5cbiAgICAvLyDigJxDbG9zZW5lc3PigJ0gaXMgZGV0ZXJtaW5lZCBieSBsaW5lYXIgZGlzdGFuY2UgYWxvbmcgdGhlIGZyb250LWNoYWluLlxuICAgIC8vIOKAnEFoZWFk4oCdIG9yIOKAnGJlaGluZOKAnSBpcyBsaWtld2lzZSBkZXRlcm1pbmVkIGJ5IGxpbmVhciBkaXN0YW5jZS5cbiAgICBqID0gYi5uZXh0LCBrID0gYS5wcmV2aW91cywgc2ogPSBiLl8uciwgc2sgPSBhLl8ucjtcbiAgICBkbyB7XG4gICAgICBpZiAoc2ogPD0gc2spIHtcbiAgICAgICAgaWYgKGludGVyc2VjdHMoai5fLCBjLl8pKSB7XG4gICAgICAgICAgYiA9IGosIGEubmV4dCA9IGIsIGIucHJldmlvdXMgPSBhLCAtLWk7XG4gICAgICAgICAgY29udGludWUgcGFjaztcbiAgICAgICAgfVxuICAgICAgICBzaiArPSBqLl8uciwgaiA9IGoubmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbnRlcnNlY3RzKGsuXywgYy5fKSkge1xuICAgICAgICAgIGEgPSBrLCBhLm5leHQgPSBiLCBiLnByZXZpb3VzID0gYSwgLS1pO1xuICAgICAgICAgIGNvbnRpbnVlIHBhY2s7XG4gICAgICAgIH1cbiAgICAgICAgc2sgKz0gay5fLnIsIGsgPSBrLnByZXZpb3VzO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGogIT09IGsubmV4dCk7XG5cbiAgICAvLyBTdWNjZXNzISBJbnNlcnQgdGhlIG5ldyBjaXJjbGUgYyBiZXR3ZWVuIGEgYW5kIGIuXG4gICAgYy5wcmV2aW91cyA9IGEsIGMubmV4dCA9IGIsIGEubmV4dCA9IGIucHJldmlvdXMgPSBiID0gYztcblxuICAgIC8vIENvbXB1dGUgdGhlIG5ldyBjbG9zZXN0IGNpcmNsZSBwYWlyIHRvIHRoZSBjZW50cm9pZC5cbiAgICBhYSA9IHNjb3JlKGEpO1xuICAgIHdoaWxlICgoYyA9IGMubmV4dCkgIT09IGIpIHtcbiAgICAgIGlmICgoY2EgPSBzY29yZShjKSkgPCBhYSkge1xuICAgICAgICBhID0gYywgYWEgPSBjYTtcbiAgICAgIH1cbiAgICB9XG4gICAgYiA9IGEubmV4dDtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGVuY2xvc2luZyBjaXJjbGUgb2YgdGhlIGZyb250IGNoYWluLlxuICBhID0gW2IuX10sIGMgPSBiOyB3aGlsZSAoKGMgPSBjLm5leHQpICE9PSBiKSBhLnB1c2goYy5fKTsgYyA9IGVuY2xvc2UoYSk7XG5cbiAgLy8gVHJhbnNsYXRlIHRoZSBjaXJjbGVzIHRvIHB1dCB0aGUgZW5jbG9zaW5nIGNpcmNsZSBhcm91bmQgdGhlIG9yaWdpbi5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgYSA9IGNpcmNsZXNbaV0sIGEueCAtPSBjLngsIGEueSAtPSBjLnk7XG5cbiAgcmV0dXJuIGMucjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2lyY2xlcykge1xuICBwYWNrRW5jbG9zZShjaXJjbGVzKTtcbiAgcmV0dXJuIGNpcmNsZXM7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gb3B0aW9uYWwoZikge1xuICByZXR1cm4gZiA9PSBudWxsID8gbnVsbCA6IHJlcXVpcmVkKGYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZWQoZikge1xuICBpZiAodHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZjtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjb25zdGFudFplcm8oKSB7XG4gIHJldHVybiAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImltcG9ydCB7cGFja0VuY2xvc2V9IGZyb20gXCIuL3NpYmxpbmdzXCI7XG5pbXBvcnQge29wdGlvbmFsfSBmcm9tIFwiLi4vYWNjZXNzb3JzXCI7XG5pbXBvcnQgY29uc3RhbnQsIHtjb25zdGFudFplcm99IGZyb20gXCIuLi9jb25zdGFudFwiO1xuXG5mdW5jdGlvbiBkZWZhdWx0UmFkaXVzKGQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChkLnZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciByYWRpdXMgPSBudWxsLFxuICAgICAgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgcGFkZGluZyA9IGNvbnN0YW50WmVybztcblxuICBmdW5jdGlvbiBwYWNrKHJvb3QpIHtcbiAgICByb290LnggPSBkeCAvIDIsIHJvb3QueSA9IGR5IC8gMjtcbiAgICBpZiAocmFkaXVzKSB7XG4gICAgICByb290LmVhY2hCZWZvcmUocmFkaXVzTGVhZihyYWRpdXMpKVxuICAgICAgICAgIC5lYWNoQWZ0ZXIocGFja0NoaWxkcmVuKHBhZGRpbmcsIDAuNSkpXG4gICAgICAgICAgLmVhY2hCZWZvcmUodHJhbnNsYXRlQ2hpbGQoMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290LmVhY2hCZWZvcmUocmFkaXVzTGVhZihkZWZhdWx0UmFkaXVzKSlcbiAgICAgICAgICAuZWFjaEFmdGVyKHBhY2tDaGlsZHJlbihjb25zdGFudFplcm8sIDEpKVxuICAgICAgICAgIC5lYWNoQWZ0ZXIocGFja0NoaWxkcmVuKHBhZGRpbmcsIHJvb3QuciAvIE1hdGgubWluKGR4LCBkeSkpKVxuICAgICAgICAgIC5lYWNoQmVmb3JlKHRyYW5zbGF0ZUNoaWxkKE1hdGgubWluKGR4LCBkeSkgLyAoMiAqIHJvb3QucikpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cblxuICBwYWNrLnJhZGl1cyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYWRpdXMgPSBvcHRpb25hbCh4KSwgcGFjaykgOiByYWRpdXM7XG4gIH07XG5cbiAgcGFjay5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHBhY2spIDogW2R4LCBkeV07XG4gIH07XG5cbiAgcGFjay5wYWRkaW5nID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmcgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgcGFjaykgOiBwYWRkaW5nO1xuICB9O1xuXG4gIHJldHVybiBwYWNrO1xufVxuXG5mdW5jdGlvbiByYWRpdXNMZWFmKHJhZGl1cykge1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgbm9kZS5yID0gTWF0aC5tYXgoMCwgK3JhZGl1cyhub2RlKSB8fCAwKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhY2tDaGlsZHJlbihwYWRkaW5nLCBrKSB7XG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikge1xuICAgICAgdmFyIGNoaWxkcmVuLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbiA9IGNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICByID0gcGFkZGluZyhub2RlKSAqIGsgfHwgMCxcbiAgICAgICAgICBlO1xuXG4gICAgICBpZiAocikgZm9yIChpID0gMDsgaSA8IG47ICsraSkgY2hpbGRyZW5baV0uciArPSByO1xuICAgICAgZSA9IHBhY2tFbmNsb3NlKGNoaWxkcmVuKTtcbiAgICAgIGlmIChyKSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGlsZHJlbltpXS5yIC09IHI7XG4gICAgICBub2RlLnIgPSBlICsgcjtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUNoaWxkKGspIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgbm9kZS5yICo9IGs7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgbm9kZS54ID0gcGFyZW50LnggKyBrICogbm9kZS54O1xuICAgICAgbm9kZS55ID0gcGFyZW50LnkgKyBrICogbm9kZS55O1xuICAgIH1cbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUpIHtcbiAgbm9kZS54MCA9IE1hdGgucm91bmQobm9kZS54MCk7XG4gIG5vZGUueTAgPSBNYXRoLnJvdW5kKG5vZGUueTApO1xuICBub2RlLngxID0gTWF0aC5yb3VuZChub2RlLngxKTtcbiAgbm9kZS55MSA9IE1hdGgucm91bmQobm9kZS55MSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBub2RlcyA9IHBhcmVudC5jaGlsZHJlbixcbiAgICAgIG5vZGUsXG4gICAgICBpID0gLTEsXG4gICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgayA9IHBhcmVudC52YWx1ZSAmJiAoeDEgLSB4MCkgLyBwYXJlbnQudmFsdWU7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUueTAgPSB5MCwgbm9kZS55MSA9IHkxO1xuICAgIG5vZGUueDAgPSB4MCwgbm9kZS54MSA9IHgwICs9IG5vZGUudmFsdWUgKiBrO1xuICB9XG59XG4iLCJpbXBvcnQgcm91bmROb2RlIGZyb20gXCIuL3RyZWVtYXAvcm91bmRcIjtcbmltcG9ydCB0cmVlbWFwRGljZSBmcm9tIFwiLi90cmVlbWFwL2RpY2VcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBwYWRkaW5nID0gMCxcbiAgICAgIHJvdW5kID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gcGFydGl0aW9uKHJvb3QpIHtcbiAgICB2YXIgbiA9IHJvb3QuaGVpZ2h0ICsgMTtcbiAgICByb290LngwID1cbiAgICByb290LnkwID0gcGFkZGluZztcbiAgICByb290LngxID0gZHg7XG4gICAgcm9vdC55MSA9IGR5IC8gbjtcbiAgICByb290LmVhY2hCZWZvcmUocG9zaXRpb25Ob2RlKGR5LCBuKSk7XG4gICAgaWYgKHJvdW5kKSByb290LmVhY2hCZWZvcmUocm91bmROb2RlKTtcbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uTm9kZShkeSwgbikge1xuICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICB0cmVlbWFwRGljZShub2RlLCBub2RlLngwLCBkeSAqIChub2RlLmRlcHRoICsgMSkgLyBuLCBub2RlLngxLCBkeSAqIChub2RlLmRlcHRoICsgMikgLyBuKTtcbiAgICAgIH1cbiAgICAgIHZhciB4MCA9IG5vZGUueDAsXG4gICAgICAgICAgeTAgPSBub2RlLnkwLFxuICAgICAgICAgIHgxID0gbm9kZS54MSAtIHBhZGRpbmcsXG4gICAgICAgICAgeTEgPSBub2RlLnkxIC0gcGFkZGluZztcbiAgICAgIGlmICh4MSA8IHgwKSB4MCA9IHgxID0gKHgwICsgeDEpIC8gMjtcbiAgICAgIGlmICh5MSA8IHkwKSB5MCA9IHkxID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIG5vZGUueDAgPSB4MDtcbiAgICAgIG5vZGUueTAgPSB5MDtcbiAgICAgIG5vZGUueDEgPSB4MTtcbiAgICAgIG5vZGUueTEgPSB5MTtcbiAgICB9O1xuICB9XG5cbiAgcGFydGl0aW9uLnJvdW5kID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJvdW5kID0gISF4LCBwYXJ0aXRpb24pIDogcm91bmQ7XG4gIH07XG5cbiAgcGFydGl0aW9uLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZHggPSAreFswXSwgZHkgPSAreFsxXSwgcGFydGl0aW9uKSA6IFtkeCwgZHldO1xuICB9O1xuXG4gIHBhcnRpdGlvbi5wYWRkaW5nID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmcgPSAreCwgcGFydGl0aW9uKSA6IHBhZGRpbmc7XG4gIH07XG5cbiAgcmV0dXJuIHBhcnRpdGlvbjtcbn1cbiIsImltcG9ydCB7cmVxdWlyZWR9IGZyb20gXCIuL2FjY2Vzc29yc1wiO1xuaW1wb3J0IHtOb2RlLCBjb21wdXRlSGVpZ2h0fSBmcm9tIFwiLi9oaWVyYXJjaHkvaW5kZXhcIjtcblxudmFyIGtleVByZWZpeCA9IFwiJFwiLCAvLyBQcm90ZWN0IGFnYWluc3Qga2V5cyBsaWtlIOKAnF9fcHJvdG9fX+KAnS5cbiAgICBwcmVyb290ID0ge2RlcHRoOiAtMX0sXG4gICAgYW1iaWd1b3VzID0ge307XG5cbmZ1bmN0aW9uIGRlZmF1bHRJZChkKSB7XG4gIHJldHVybiBkLmlkO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UGFyZW50SWQoZCkge1xuICByZXR1cm4gZC5wYXJlbnRJZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBpZCA9IGRlZmF1bHRJZCxcbiAgICAgIHBhcmVudElkID0gZGVmYXVsdFBhcmVudElkO1xuXG4gIGZ1bmN0aW9uIHN0cmF0aWZ5KGRhdGEpIHtcbiAgICB2YXIgZCxcbiAgICAgICAgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICByb290LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGVzID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBub2RlSWQsXG4gICAgICAgIG5vZGVLZXksXG4gICAgICAgIG5vZGVCeUtleSA9IHt9O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZCA9IGRhdGFbaV0sIG5vZGUgPSBub2Rlc1tpXSA9IG5ldyBOb2RlKGQpO1xuICAgICAgaWYgKChub2RlSWQgPSBpZChkLCBpLCBkYXRhKSkgIT0gbnVsbCAmJiAobm9kZUlkICs9IFwiXCIpKSB7XG4gICAgICAgIG5vZGVLZXkgPSBrZXlQcmVmaXggKyAobm9kZS5pZCA9IG5vZGVJZCk7XG4gICAgICAgIG5vZGVCeUtleVtub2RlS2V5XSA9IG5vZGVLZXkgaW4gbm9kZUJ5S2V5ID8gYW1iaWd1b3VzIDogbm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGVJZCA9IHBhcmVudElkKGRhdGFbaV0sIGksIGRhdGEpO1xuICAgICAgaWYgKG5vZGVJZCA9PSBudWxsIHx8ICEobm9kZUlkICs9IFwiXCIpKSB7XG4gICAgICAgIGlmIChyb290KSB0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSByb290c1wiKTtcbiAgICAgICAgcm9vdCA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQgPSBub2RlQnlLZXlba2V5UHJlZml4ICsgbm9kZUlkXTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmc6IFwiICsgbm9kZUlkKTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gYW1iaWd1b3VzKSB0aHJvdyBuZXcgRXJyb3IoXCJhbWJpZ3VvdXM6IFwiICsgbm9kZUlkKTtcbiAgICAgICAgaWYgKHBhcmVudC5jaGlsZHJlbikgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIGVsc2UgcGFyZW50LmNoaWxkcmVuID0gW25vZGVdO1xuICAgICAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJvb3QpIHRocm93IG5ldyBFcnJvcihcIm5vIHJvb3RcIik7XG4gICAgcm9vdC5wYXJlbnQgPSBwcmVyb290O1xuICAgIHJvb3QuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7IG5vZGUuZGVwdGggPSBub2RlLnBhcmVudC5kZXB0aCArIDE7IC0tbjsgfSkuZWFjaEJlZm9yZShjb21wdXRlSGVpZ2h0KTtcbiAgICByb290LnBhcmVudCA9IG51bGw7XG4gICAgaWYgKG4gPiAwKSB0aHJvdyBuZXcgRXJyb3IoXCJjeWNsZVwiKTtcblxuICAgIHJldHVybiByb290O1xuICB9XG5cbiAgc3RyYXRpZnkuaWQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaWQgPSByZXF1aXJlZCh4KSwgc3RyYXRpZnkpIDogaWQ7XG4gIH07XG5cbiAgc3RyYXRpZnkucGFyZW50SWQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFyZW50SWQgPSByZXF1aXJlZCh4KSwgc3RyYXRpZnkpIDogcGFyZW50SWQ7XG4gIH07XG5cbiAgcmV0dXJuIHN0cmF0aWZ5O1xufVxuIiwiaW1wb3J0IHtOb2RlfSBmcm9tIFwiLi9oaWVyYXJjaHkvaW5kZXhcIjtcblxuZnVuY3Rpb24gZGVmYXVsdFNlcGFyYXRpb24oYSwgYikge1xuICByZXR1cm4gYS5wYXJlbnQgPT09IGIucGFyZW50ID8gMSA6IDI7XG59XG5cbi8vIGZ1bmN0aW9uIHJhZGlhbFNlcGFyYXRpb24oYSwgYikge1xuLy8gICByZXR1cm4gKGEucGFyZW50ID09PSBiLnBhcmVudCA/IDEgOiAyKSAvIGEuZGVwdGg7XG4vLyB9XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byB0cmF2ZXJzZSB0aGUgbGVmdCBjb250b3VyIG9mIGEgc3VidHJlZSAob3Jcbi8vIHN1YmZvcmVzdCkuIEl0IHJldHVybnMgdGhlIHN1Y2Nlc3NvciBvZiB2IG9uIHRoaXMgY29udG91ci4gVGhpcyBzdWNjZXNzb3IgaXNcbi8vIGVpdGhlciBnaXZlbiBieSB0aGUgbGVmdG1vc3QgY2hpbGQgb2YgdiBvciBieSB0aGUgdGhyZWFkIG9mIHYuIFRoZSBmdW5jdGlvblxuLy8gcmV0dXJucyBudWxsIGlmIGFuZCBvbmx5IGlmIHYgaXMgb24gdGhlIGhpZ2hlc3QgbGV2ZWwgb2YgaXRzIHN1YnRyZWUuXG5mdW5jdGlvbiBuZXh0TGVmdCh2KSB7XG4gIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW47XG4gIHJldHVybiBjaGlsZHJlbiA/IGNoaWxkcmVuWzBdIDogdi50O1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHdvcmtzIGFuYWxvZ291c2x5IHRvIG5leHRMZWZ0LlxuZnVuY3Rpb24gbmV4dFJpZ2h0KHYpIHtcbiAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbjtcbiAgcmV0dXJuIGNoaWxkcmVuID8gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0gOiB2LnQ7XG59XG5cbi8vIFNoaWZ0cyB0aGUgY3VycmVudCBzdWJ0cmVlIHJvb3RlZCBhdCB3Ky4gVGhpcyBpcyBkb25lIGJ5IGluY3JlYXNpbmdcbi8vIHByZWxpbSh3KykgYW5kIG1vZCh3KykgYnkgc2hpZnQuXG5mdW5jdGlvbiBtb3ZlU3VidHJlZSh3bSwgd3AsIHNoaWZ0KSB7XG4gIHZhciBjaGFuZ2UgPSBzaGlmdCAvICh3cC5pIC0gd20uaSk7XG4gIHdwLmMgLT0gY2hhbmdlO1xuICB3cC5zICs9IHNoaWZ0O1xuICB3bS5jICs9IGNoYW5nZTtcbiAgd3AueiArPSBzaGlmdDtcbiAgd3AubSArPSBzaGlmdDtcbn1cblxuLy8gQWxsIG90aGVyIHNoaWZ0cywgYXBwbGllZCB0byB0aGUgc21hbGxlciBzdWJ0cmVlcyBiZXR3ZWVuIHctIGFuZCB3KywgYXJlXG4vLyBwZXJmb3JtZWQgYnkgdGhpcyBmdW5jdGlvbi4gVG8gcHJlcGFyZSB0aGUgc2hpZnRzLCB3ZSBoYXZlIHRvIGFkanVzdFxuLy8gY2hhbmdlKHcrKSwgc2hpZnQodyspLCBhbmQgY2hhbmdlKHctKS5cbmZ1bmN0aW9uIGV4ZWN1dGVTaGlmdHModikge1xuICB2YXIgc2hpZnQgPSAwLFxuICAgICAgY2hhbmdlID0gMCxcbiAgICAgIGNoaWxkcmVuID0gdi5jaGlsZHJlbixcbiAgICAgIGkgPSBjaGlsZHJlbi5sZW5ndGgsXG4gICAgICB3O1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICB3ID0gY2hpbGRyZW5baV07XG4gICAgdy56ICs9IHNoaWZ0O1xuICAgIHcubSArPSBzaGlmdDtcbiAgICBzaGlmdCArPSB3LnMgKyAoY2hhbmdlICs9IHcuYyk7XG4gIH1cbn1cblxuLy8gSWYgdmkt4oCZcyBhbmNlc3RvciBpcyBhIHNpYmxpbmcgb2YgdiwgcmV0dXJucyB2aS3igJlzIGFuY2VzdG9yLiBPdGhlcndpc2UsXG4vLyByZXR1cm5zIHRoZSBzcGVjaWZpZWQgKGRlZmF1bHQpIGFuY2VzdG9yLlxuZnVuY3Rpb24gbmV4dEFuY2VzdG9yKHZpbSwgdiwgYW5jZXN0b3IpIHtcbiAgcmV0dXJuIHZpbS5hLnBhcmVudCA9PT0gdi5wYXJlbnQgPyB2aW0uYSA6IGFuY2VzdG9yO1xufVxuXG5mdW5jdGlvbiBUcmVlTm9kZShub2RlLCBpKSB7XG4gIHRoaXMuXyA9IG5vZGU7XG4gIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuQSA9IG51bGw7IC8vIGRlZmF1bHQgYW5jZXN0b3JcbiAgdGhpcy5hID0gdGhpczsgLy8gYW5jZXN0b3JcbiAgdGhpcy56ID0gMDsgLy8gcHJlbGltXG4gIHRoaXMubSA9IDA7IC8vIG1vZFxuICB0aGlzLmMgPSAwOyAvLyBjaGFuZ2VcbiAgdGhpcy5zID0gMDsgLy8gc2hpZnRcbiAgdGhpcy50ID0gbnVsbDsgLy8gdGhyZWFkXG4gIHRoaXMuaSA9IGk7IC8vIG51bWJlclxufVxuXG5UcmVlTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gdHJlZVJvb3Qocm9vdCkge1xuICB2YXIgdHJlZSA9IG5ldyBUcmVlTm9kZShyb290LCAwKSxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlcyA9IFt0cmVlXSxcbiAgICAgIGNoaWxkLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBpLFxuICAgICAgbjtcblxuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgaWYgKGNoaWxkcmVuID0gbm9kZS5fLmNoaWxkcmVuKSB7XG4gICAgICBub2RlLmNoaWxkcmVuID0gbmV3IEFycmF5KG4gPSBjaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG5vZGVzLnB1c2goY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldID0gbmV3IFRyZWVOb2RlKGNoaWxkcmVuW2ldLCBpKSk7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgKHRyZWUucGFyZW50ID0gbmV3IFRyZWVOb2RlKG51bGwsIDApKS5jaGlsZHJlbiA9IFt0cmVlXTtcbiAgcmV0dXJuIHRyZWU7XG59XG5cbi8vIE5vZGUtbGluayB0cmVlIGRpYWdyYW0gdXNpbmcgdGhlIFJlaW5nb2xkLVRpbGZvcmQgXCJ0aWR5XCIgYWxnb3JpdGhtXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHNlcGFyYXRpb24gPSBkZWZhdWx0U2VwYXJhdGlvbixcbiAgICAgIGR4ID0gMSxcbiAgICAgIGR5ID0gMSxcbiAgICAgIG5vZGVTaXplID0gbnVsbDtcblxuICBmdW5jdGlvbiB0cmVlKHJvb3QpIHtcbiAgICB2YXIgdCA9IHRyZWVSb290KHJvb3QpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbGF5b3V0IHVzaW5nIEJ1Y2hoZWltIGV0IGFsLuKAmXMgYWxnb3JpdGhtLlxuICAgIHQuZWFjaEFmdGVyKGZpcnN0V2FsayksIHQucGFyZW50Lm0gPSAtdC56O1xuICAgIHQuZWFjaEJlZm9yZShzZWNvbmRXYWxrKTtcblxuICAgIC8vIElmIGEgZml4ZWQgbm9kZSBzaXplIGlzIHNwZWNpZmllZCwgc2NhbGUgeCBhbmQgeS5cbiAgICBpZiAobm9kZVNpemUpIHJvb3QuZWFjaEJlZm9yZShzaXplTm9kZSk7XG5cbiAgICAvLyBJZiBhIGZpeGVkIHRyZWUgc2l6ZSBpcyBzcGVjaWZpZWQsIHNjYWxlIHggYW5kIHkgYmFzZWQgb24gdGhlIGV4dGVudC5cbiAgICAvLyBDb21wdXRlIHRoZSBsZWZ0LW1vc3QsIHJpZ2h0LW1vc3QsIGFuZCBkZXB0aC1tb3N0IG5vZGVzIGZvciBleHRlbnRzLlxuICAgIGVsc2Uge1xuICAgICAgdmFyIGxlZnQgPSByb290LFxuICAgICAgICAgIHJpZ2h0ID0gcm9vdCxcbiAgICAgICAgICBib3R0b20gPSByb290O1xuICAgICAgcm9vdC5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUueCA8IGxlZnQueCkgbGVmdCA9IG5vZGU7XG4gICAgICAgIGlmIChub2RlLnggPiByaWdodC54KSByaWdodCA9IG5vZGU7XG4gICAgICAgIGlmIChub2RlLmRlcHRoID4gYm90dG9tLmRlcHRoKSBib3R0b20gPSBub2RlO1xuICAgICAgfSk7XG4gICAgICB2YXIgcyA9IGxlZnQgPT09IHJpZ2h0ID8gMSA6IHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMixcbiAgICAgICAgICB0eCA9IHMgLSBsZWZ0LngsXG4gICAgICAgICAga3ggPSBkeCAvIChyaWdodC54ICsgcyArIHR4KSxcbiAgICAgICAgICBreSA9IGR5IC8gKGJvdHRvbS5kZXB0aCB8fCAxKTtcbiAgICAgIHJvb3QuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIG5vZGUueCA9IChub2RlLnggKyB0eCkgKiBreDtcbiAgICAgICAgbm9kZS55ID0gbm9kZS5kZXB0aCAqIGt5O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cblxuICAvLyBDb21wdXRlcyBhIHByZWxpbWluYXJ5IHgtY29vcmRpbmF0ZSBmb3Igdi4gQmVmb3JlIHRoYXQsIEZJUlNUIFdBTEsgaXNcbiAgLy8gYXBwbGllZCByZWN1cnNpdmVseSB0byB0aGUgY2hpbGRyZW4gb2YgdiwgYXMgd2VsbCBhcyB0aGUgZnVuY3Rpb25cbiAgLy8gQVBQT1JUSU9OLiBBZnRlciBzcGFjaW5nIG91dCB0aGUgY2hpbGRyZW4gYnkgY2FsbGluZyBFWEVDVVRFIFNISUZUUywgdGhlXG4gIC8vIG5vZGUgdiBpcyBwbGFjZWQgdG8gdGhlIG1pZHBvaW50IG9mIGl0cyBvdXRlcm1vc3QgY2hpbGRyZW4uXG4gIGZ1bmN0aW9uIGZpcnN0V2Fsayh2KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbixcbiAgICAgICAgc2libGluZ3MgPSB2LnBhcmVudC5jaGlsZHJlbixcbiAgICAgICAgdyA9IHYuaSA/IHNpYmxpbmdzW3YuaSAtIDFdIDogbnVsbDtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGV4ZWN1dGVTaGlmdHModik7XG4gICAgICB2YXIgbWlkcG9pbnQgPSAoY2hpbGRyZW5bMF0ueiArIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnopIC8gMjtcbiAgICAgIGlmICh3KSB7XG4gICAgICAgIHYueiA9IHcueiArIHNlcGFyYXRpb24odi5fLCB3Ll8pO1xuICAgICAgICB2Lm0gPSB2LnogLSBtaWRwb2ludDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYueiA9IG1pZHBvaW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodykge1xuICAgICAgdi56ID0gdy56ICsgc2VwYXJhdGlvbih2Ll8sIHcuXyk7XG4gICAgfVxuICAgIHYucGFyZW50LkEgPSBhcHBvcnRpb24odiwgdywgdi5wYXJlbnQuQSB8fCBzaWJsaW5nc1swXSk7XG4gIH1cblxuICAvLyBDb21wdXRlcyBhbGwgcmVhbCB4LWNvb3JkaW5hdGVzIGJ5IHN1bW1pbmcgdXAgdGhlIG1vZGlmaWVycyByZWN1cnNpdmVseS5cbiAgZnVuY3Rpb24gc2Vjb25kV2Fsayh2KSB7XG4gICAgdi5fLnggPSB2LnogKyB2LnBhcmVudC5tO1xuICAgIHYubSArPSB2LnBhcmVudC5tO1xuICB9XG5cbiAgLy8gVGhlIGNvcmUgb2YgdGhlIGFsZ29yaXRobS4gSGVyZSwgYSBuZXcgc3VidHJlZSBpcyBjb21iaW5lZCB3aXRoIHRoZVxuICAvLyBwcmV2aW91cyBzdWJ0cmVlcy4gVGhyZWFkcyBhcmUgdXNlZCB0byB0cmF2ZXJzZSB0aGUgaW5zaWRlIGFuZCBvdXRzaWRlXG4gIC8vIGNvbnRvdXJzIG9mIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlIHVwIHRvIHRoZSBoaWdoZXN0IGNvbW1vbiBsZXZlbC4gVGhlXG4gIC8vIHZlcnRpY2VzIHVzZWQgZm9yIHRoZSB0cmF2ZXJzYWxzIGFyZSB2aSssIHZpLSwgdm8tLCBhbmQgdm8rLCB3aGVyZSB0aGVcbiAgLy8gc3VwZXJzY3JpcHQgbyBtZWFucyBvdXRzaWRlIGFuZCBpIG1lYW5zIGluc2lkZSwgdGhlIHN1YnNjcmlwdCAtIG1lYW5zIGxlZnRcbiAgLy8gc3VidHJlZSBhbmQgKyBtZWFucyByaWdodCBzdWJ0cmVlLiBGb3Igc3VtbWluZyB1cCB0aGUgbW9kaWZpZXJzIGFsb25nIHRoZVxuICAvLyBjb250b3VyLCB3ZSB1c2UgcmVzcGVjdGl2ZSB2YXJpYWJsZXMgc2krLCBzaS0sIHNvLSwgYW5kIHNvKy4gV2hlbmV2ZXIgdHdvXG4gIC8vIG5vZGVzIG9mIHRoZSBpbnNpZGUgY29udG91cnMgY29uZmxpY3QsIHdlIGNvbXB1dGUgdGhlIGxlZnQgb25lIG9mIHRoZVxuICAvLyBncmVhdGVzdCB1bmNvbW1vbiBhbmNlc3RvcnMgdXNpbmcgdGhlIGZ1bmN0aW9uIEFOQ0VTVE9SIGFuZCBjYWxsIE1PVkVcbiAgLy8gU1VCVFJFRSB0byBzaGlmdCB0aGUgc3VidHJlZSBhbmQgcHJlcGFyZSB0aGUgc2hpZnRzIG9mIHNtYWxsZXIgc3VidHJlZXMuXG4gIC8vIEZpbmFsbHksIHdlIGFkZCBhIG5ldyB0aHJlYWQgKGlmIG5lY2Vzc2FyeSkuXG4gIGZ1bmN0aW9uIGFwcG9ydGlvbih2LCB3LCBhbmNlc3Rvcikge1xuICAgIGlmICh3KSB7XG4gICAgICB2YXIgdmlwID0gdixcbiAgICAgICAgICB2b3AgPSB2LFxuICAgICAgICAgIHZpbSA9IHcsXG4gICAgICAgICAgdm9tID0gdmlwLnBhcmVudC5jaGlsZHJlblswXSxcbiAgICAgICAgICBzaXAgPSB2aXAubSxcbiAgICAgICAgICBzb3AgPSB2b3AubSxcbiAgICAgICAgICBzaW0gPSB2aW0ubSxcbiAgICAgICAgICBzb20gPSB2b20ubSxcbiAgICAgICAgICBzaGlmdDtcbiAgICAgIHdoaWxlICh2aW0gPSBuZXh0UmlnaHQodmltKSwgdmlwID0gbmV4dExlZnQodmlwKSwgdmltICYmIHZpcCkge1xuICAgICAgICB2b20gPSBuZXh0TGVmdCh2b20pO1xuICAgICAgICB2b3AgPSBuZXh0UmlnaHQodm9wKTtcbiAgICAgICAgdm9wLmEgPSB2O1xuICAgICAgICBzaGlmdCA9IHZpbS56ICsgc2ltIC0gdmlwLnogLSBzaXAgKyBzZXBhcmF0aW9uKHZpbS5fLCB2aXAuXyk7XG4gICAgICAgIGlmIChzaGlmdCA+IDApIHtcbiAgICAgICAgICBtb3ZlU3VidHJlZShuZXh0QW5jZXN0b3IodmltLCB2LCBhbmNlc3RvciksIHYsIHNoaWZ0KTtcbiAgICAgICAgICBzaXAgKz0gc2hpZnQ7XG4gICAgICAgICAgc29wICs9IHNoaWZ0O1xuICAgICAgICB9XG4gICAgICAgIHNpbSArPSB2aW0ubTtcbiAgICAgICAgc2lwICs9IHZpcC5tO1xuICAgICAgICBzb20gKz0gdm9tLm07XG4gICAgICAgIHNvcCArPSB2b3AubTtcbiAgICAgIH1cbiAgICAgIGlmICh2aW0gJiYgIW5leHRSaWdodCh2b3ApKSB7XG4gICAgICAgIHZvcC50ID0gdmltO1xuICAgICAgICB2b3AubSArPSBzaW0gLSBzb3A7XG4gICAgICB9XG4gICAgICBpZiAodmlwICYmICFuZXh0TGVmdCh2b20pKSB7XG4gICAgICAgIHZvbS50ID0gdmlwO1xuICAgICAgICB2b20ubSArPSBzaXAgLSBzb207XG4gICAgICAgIGFuY2VzdG9yID0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFuY2VzdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gc2l6ZU5vZGUobm9kZSkge1xuICAgIG5vZGUueCAqPSBkeDtcbiAgICBub2RlLnkgPSBub2RlLmRlcHRoICogZHk7XG4gIH1cblxuICB0cmVlLnNlcGFyYXRpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2VwYXJhdGlvbiA9IHgsIHRyZWUpIDogc2VwYXJhdGlvbjtcbiAgfTtcblxuICB0cmVlLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZVNpemUgPSBmYWxzZSwgZHggPSAreFswXSwgZHkgPSAreFsxXSwgdHJlZSkgOiAobm9kZVNpemUgPyBudWxsIDogW2R4LCBkeV0pO1xuICB9O1xuXG4gIHRyZWUubm9kZVNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZVNpemUgPSB0cnVlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCB0cmVlKSA6IChub2RlU2l6ZSA/IFtkeCwgZHldIDogbnVsbCk7XG4gIH07XG5cbiAgcmV0dXJuIHRyZWU7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBub2RlcyA9IHBhcmVudC5jaGlsZHJlbixcbiAgICAgIG5vZGUsXG4gICAgICBpID0gLTEsXG4gICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgayA9IHBhcmVudC52YWx1ZSAmJiAoeTEgLSB5MCkgLyBwYXJlbnQudmFsdWU7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUueDAgPSB4MCwgbm9kZS54MSA9IHgxO1xuICAgIG5vZGUueTAgPSB5MCwgbm9kZS55MSA9IHkwICs9IG5vZGUudmFsdWUgKiBrO1xuICB9XG59XG4iLCJpbXBvcnQgdHJlZW1hcERpY2UgZnJvbSBcIi4vZGljZVwiO1xuaW1wb3J0IHRyZWVtYXBTbGljZSBmcm9tIFwiLi9zbGljZVwiO1xuXG5leHBvcnQgdmFyIHBoaSA9ICgxICsgTWF0aC5zcXJ0KDUpKSAvIDI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmlmeVJhdGlvKHJhdGlvLCBwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciByb3dzID0gW10sXG4gICAgICBub2RlcyA9IHBhcmVudC5jaGlsZHJlbixcbiAgICAgIHJvdyxcbiAgICAgIG5vZGVWYWx1ZSxcbiAgICAgIGkwID0gMCxcbiAgICAgIGkxID0gMCxcbiAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBkeCwgZHksXG4gICAgICB2YWx1ZSA9IHBhcmVudC52YWx1ZSxcbiAgICAgIHN1bVZhbHVlLFxuICAgICAgbWluVmFsdWUsXG4gICAgICBtYXhWYWx1ZSxcbiAgICAgIG5ld1JhdGlvLFxuICAgICAgbWluUmF0aW8sXG4gICAgICBhbHBoYSxcbiAgICAgIGJldGE7XG5cbiAgd2hpbGUgKGkwIDwgbikge1xuICAgIGR4ID0geDEgLSB4MCwgZHkgPSB5MSAtIHkwO1xuXG4gICAgLy8gRmluZCB0aGUgbmV4dCBub24tZW1wdHkgbm9kZS5cbiAgICBkbyBzdW1WYWx1ZSA9IG5vZGVzW2kxKytdLnZhbHVlOyB3aGlsZSAoIXN1bVZhbHVlICYmIGkxIDwgbik7XG4gICAgbWluVmFsdWUgPSBtYXhWYWx1ZSA9IHN1bVZhbHVlO1xuICAgIGFscGhhID0gTWF0aC5tYXgoZHkgLyBkeCwgZHggLyBkeSkgLyAodmFsdWUgKiByYXRpbyk7XG4gICAgYmV0YSA9IHN1bVZhbHVlICogc3VtVmFsdWUgKiBhbHBoYTtcbiAgICBtaW5SYXRpbyA9IE1hdGgubWF4KG1heFZhbHVlIC8gYmV0YSwgYmV0YSAvIG1pblZhbHVlKTtcblxuICAgIC8vIEtlZXAgYWRkaW5nIG5vZGVzIHdoaWxlIHRoZSBhc3BlY3QgcmF0aW8gbWFpbnRhaW5zIG9yIGltcHJvdmVzLlxuICAgIGZvciAoOyBpMSA8IG47ICsraTEpIHtcbiAgICAgIHN1bVZhbHVlICs9IG5vZGVWYWx1ZSA9IG5vZGVzW2kxXS52YWx1ZTtcbiAgICAgIGlmIChub2RlVmFsdWUgPCBtaW5WYWx1ZSkgbWluVmFsdWUgPSBub2RlVmFsdWU7XG4gICAgICBpZiAobm9kZVZhbHVlID4gbWF4VmFsdWUpIG1heFZhbHVlID0gbm9kZVZhbHVlO1xuICAgICAgYmV0YSA9IHN1bVZhbHVlICogc3VtVmFsdWUgKiBhbHBoYTtcbiAgICAgIG5ld1JhdGlvID0gTWF0aC5tYXgobWF4VmFsdWUgLyBiZXRhLCBiZXRhIC8gbWluVmFsdWUpO1xuICAgICAgaWYgKG5ld1JhdGlvID4gbWluUmF0aW8pIHsgc3VtVmFsdWUgLT0gbm9kZVZhbHVlOyBicmVhazsgfVxuICAgICAgbWluUmF0aW8gPSBuZXdSYXRpbztcbiAgICB9XG5cbiAgICAvLyBQb3NpdGlvbiBhbmQgcmVjb3JkIHRoZSByb3cgb3JpZW50YXRpb24uXG4gICAgcm93cy5wdXNoKHJvdyA9IHt2YWx1ZTogc3VtVmFsdWUsIGRpY2U6IGR4IDwgZHksIGNoaWxkcmVuOiBub2Rlcy5zbGljZShpMCwgaTEpfSk7XG4gICAgaWYgKHJvdy5kaWNlKSB0cmVlbWFwRGljZShyb3csIHgwLCB5MCwgeDEsIHZhbHVlID8geTAgKz0gZHkgKiBzdW1WYWx1ZSAvIHZhbHVlIDogeTEpO1xuICAgIGVsc2UgdHJlZW1hcFNsaWNlKHJvdywgeDAsIHkwLCB2YWx1ZSA/IHgwICs9IGR4ICogc3VtVmFsdWUgLyB2YWx1ZSA6IHgxLCB5MSk7XG4gICAgdmFsdWUgLT0gc3VtVmFsdWUsIGkwID0gaTE7XG4gIH1cblxuICByZXR1cm4gcm93cztcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShyYXRpbykge1xuXG4gIGZ1bmN0aW9uIHNxdWFyaWZ5KHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICBzcXVhcmlmeVJhdGlvKHJhdGlvLCBwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKTtcbiAgfVxuXG4gIHNxdWFyaWZ5LnJhdGlvID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjdXN0b20oKHggPSAreCkgPiAxID8geCA6IDEpO1xuICB9O1xuXG4gIHJldHVybiBzcXVhcmlmeTtcbn0pKHBoaSk7XG4iLCJpbXBvcnQgcm91bmROb2RlIGZyb20gXCIuL3JvdW5kXCI7XG5pbXBvcnQgc3F1YXJpZnkgZnJvbSBcIi4vc3F1YXJpZnlcIjtcbmltcG9ydCB7cmVxdWlyZWR9IGZyb20gXCIuLi9hY2Nlc3NvcnNcIjtcbmltcG9ydCBjb25zdGFudCwge2NvbnN0YW50WmVyb30gZnJvbSBcIi4uL2NvbnN0YW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgdGlsZSA9IHNxdWFyaWZ5LFxuICAgICAgcm91bmQgPSBmYWxzZSxcbiAgICAgIGR4ID0gMSxcbiAgICAgIGR5ID0gMSxcbiAgICAgIHBhZGRpbmdTdGFjayA9IFswXSxcbiAgICAgIHBhZGRpbmdJbm5lciA9IGNvbnN0YW50WmVybyxcbiAgICAgIHBhZGRpbmdUb3AgPSBjb25zdGFudFplcm8sXG4gICAgICBwYWRkaW5nUmlnaHQgPSBjb25zdGFudFplcm8sXG4gICAgICBwYWRkaW5nQm90dG9tID0gY29uc3RhbnRaZXJvLFxuICAgICAgcGFkZGluZ0xlZnQgPSBjb25zdGFudFplcm87XG5cbiAgZnVuY3Rpb24gdHJlZW1hcChyb290KSB7XG4gICAgcm9vdC54MCA9XG4gICAgcm9vdC55MCA9IDA7XG4gICAgcm9vdC54MSA9IGR4O1xuICAgIHJvb3QueTEgPSBkeTtcbiAgICByb290LmVhY2hCZWZvcmUocG9zaXRpb25Ob2RlKTtcbiAgICBwYWRkaW5nU3RhY2sgPSBbMF07XG4gICAgaWYgKHJvdW5kKSByb290LmVhY2hCZWZvcmUocm91bmROb2RlKTtcbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uTm9kZShub2RlKSB7XG4gICAgdmFyIHAgPSBwYWRkaW5nU3RhY2tbbm9kZS5kZXB0aF0sXG4gICAgICAgIHgwID0gbm9kZS54MCArIHAsXG4gICAgICAgIHkwID0gbm9kZS55MCArIHAsXG4gICAgICAgIHgxID0gbm9kZS54MSAtIHAsXG4gICAgICAgIHkxID0gbm9kZS55MSAtIHA7XG4gICAgaWYgKHgxIDwgeDApIHgwID0geDEgPSAoeDAgKyB4MSkgLyAyO1xuICAgIGlmICh5MSA8IHkwKSB5MCA9IHkxID0gKHkwICsgeTEpIC8gMjtcbiAgICBub2RlLngwID0geDA7XG4gICAgbm9kZS55MCA9IHkwO1xuICAgIG5vZGUueDEgPSB4MTtcbiAgICBub2RlLnkxID0geTE7XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIHAgPSBwYWRkaW5nU3RhY2tbbm9kZS5kZXB0aCArIDFdID0gcGFkZGluZ0lubmVyKG5vZGUpIC8gMjtcbiAgICAgIHgwICs9IHBhZGRpbmdMZWZ0KG5vZGUpIC0gcDtcbiAgICAgIHkwICs9IHBhZGRpbmdUb3Aobm9kZSkgLSBwO1xuICAgICAgeDEgLT0gcGFkZGluZ1JpZ2h0KG5vZGUpIC0gcDtcbiAgICAgIHkxIC09IHBhZGRpbmdCb3R0b20obm9kZSkgLSBwO1xuICAgICAgaWYgKHgxIDwgeDApIHgwID0geDEgPSAoeDAgKyB4MSkgLyAyO1xuICAgICAgaWYgKHkxIDwgeTApIHkwID0geTEgPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgdGlsZShub2RlLCB4MCwgeTAsIHgxLCB5MSk7XG4gICAgfVxuICB9XG5cbiAgdHJlZW1hcC5yb3VuZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEheCwgdHJlZW1hcCkgOiByb3VuZDtcbiAgfTtcblxuICB0cmVlbWFwLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZHggPSAreFswXSwgZHkgPSAreFsxXSwgdHJlZW1hcCkgOiBbZHgsIGR5XTtcbiAgfTtcblxuICB0cmVlbWFwLnRpbGUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlsZSA9IHJlcXVpcmVkKHgpLCB0cmVlbWFwKSA6IHRpbGU7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdHJlZW1hcC5wYWRkaW5nSW5uZXIoeCkucGFkZGluZ091dGVyKHgpIDogdHJlZW1hcC5wYWRkaW5nSW5uZXIoKTtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdJbm5lciA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nSW5uZXI7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0cmVlbWFwLnBhZGRpbmdUb3AoeCkucGFkZGluZ1JpZ2h0KHgpLnBhZGRpbmdCb3R0b20oeCkucGFkZGluZ0xlZnQoeCkgOiB0cmVlbWFwLnBhZGRpbmdUb3AoKTtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdUb3AgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ1RvcCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdUb3A7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nUmlnaHQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ1JpZ2h0ID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHRyZWVtYXApIDogcGFkZGluZ1JpZ2h0O1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ0JvdHRvbSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nQm90dG9tID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHRyZWVtYXApIDogcGFkZGluZ0JvdHRvbTtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdMZWZ0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdMZWZ0ID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHRyZWVtYXApIDogcGFkZGluZ0xlZnQ7XG4gIH07XG5cbiAgcmV0dXJuIHRyZWVtYXA7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBub2RlcyA9IHBhcmVudC5jaGlsZHJlbixcbiAgICAgIGksIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBzdW0sIHN1bXMgPSBuZXcgQXJyYXkobiArIDEpO1xuXG4gIGZvciAoc3Vtc1swXSA9IHN1bSA9IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgc3Vtc1tpICsgMV0gPSBzdW0gKz0gbm9kZXNbaV0udmFsdWU7XG4gIH1cblxuICBwYXJ0aXRpb24oMCwgbiwgcGFyZW50LnZhbHVlLCB4MCwgeTAsIHgxLCB5MSk7XG5cbiAgZnVuY3Rpb24gcGFydGl0aW9uKGksIGosIHZhbHVlLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIGlmIChpID49IGogLSAxKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgbm9kZS54MCA9IHgwLCBub2RlLnkwID0geTA7XG4gICAgICBub2RlLngxID0geDEsIG5vZGUueTEgPSB5MTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVPZmZzZXQgPSBzdW1zW2ldLFxuICAgICAgICB2YWx1ZVRhcmdldCA9ICh2YWx1ZSAvIDIpICsgdmFsdWVPZmZzZXQsXG4gICAgICAgIGsgPSBpICsgMSxcbiAgICAgICAgaGkgPSBqIC0gMTtcblxuICAgIHdoaWxlIChrIDwgaGkpIHtcbiAgICAgIHZhciBtaWQgPSBrICsgaGkgPj4+IDE7XG4gICAgICBpZiAoc3Vtc1ttaWRdIDwgdmFsdWVUYXJnZXQpIGsgPSBtaWQgKyAxO1xuICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICB9XG5cbiAgICBpZiAoKHZhbHVlVGFyZ2V0IC0gc3Vtc1trIC0gMV0pIDwgKHN1bXNba10gLSB2YWx1ZVRhcmdldCkgJiYgaSArIDEgPCBrKSAtLWs7XG5cbiAgICB2YXIgdmFsdWVMZWZ0ID0gc3Vtc1trXSAtIHZhbHVlT2Zmc2V0LFxuICAgICAgICB2YWx1ZVJpZ2h0ID0gdmFsdWUgLSB2YWx1ZUxlZnQ7XG5cbiAgICBpZiAoKHgxIC0geDApID4gKHkxIC0geTApKSB7XG4gICAgICB2YXIgeGsgPSAoeDAgKiB2YWx1ZVJpZ2h0ICsgeDEgKiB2YWx1ZUxlZnQpIC8gdmFsdWU7XG4gICAgICBwYXJ0aXRpb24oaSwgaywgdmFsdWVMZWZ0LCB4MCwgeTAsIHhrLCB5MSk7XG4gICAgICBwYXJ0aXRpb24oaywgaiwgdmFsdWVSaWdodCwgeGssIHkwLCB4MSwgeTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeWsgPSAoeTAgKiB2YWx1ZVJpZ2h0ICsgeTEgKiB2YWx1ZUxlZnQpIC8gdmFsdWU7XG4gICAgICBwYXJ0aXRpb24oaSwgaywgdmFsdWVMZWZ0LCB4MCwgeTAsIHgxLCB5ayk7XG4gICAgICBwYXJ0aXRpb24oaywgaiwgdmFsdWVSaWdodCwgeDAsIHlrLCB4MSwgeTEpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IGRpY2UgZnJvbSBcIi4vZGljZVwiO1xuaW1wb3J0IHNsaWNlIGZyb20gXCIuL3NsaWNlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgKHBhcmVudC5kZXB0aCAmIDEgPyBzbGljZSA6IGRpY2UpKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpO1xufVxuIiwiaW1wb3J0IHRyZWVtYXBEaWNlIGZyb20gXCIuL2RpY2VcIjtcbmltcG9ydCB0cmVlbWFwU2xpY2UgZnJvbSBcIi4vc2xpY2VcIjtcbmltcG9ydCB7cGhpLCBzcXVhcmlmeVJhdGlvfSBmcm9tIFwiLi9zcXVhcmlmeVwiO1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKHJhdGlvKSB7XG5cbiAgZnVuY3Rpb24gcmVzcXVhcmlmeShwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgaWYgKChyb3dzID0gcGFyZW50Ll9zcXVhcmlmeSkgJiYgKHJvd3MucmF0aW8gPT09IHJhdGlvKSkge1xuICAgICAgdmFyIHJvd3MsXG4gICAgICAgICAgcm93LFxuICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgIGksXG4gICAgICAgICAgaiA9IC0xLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgbSA9IHJvd3MubGVuZ3RoLFxuICAgICAgICAgIHZhbHVlID0gcGFyZW50LnZhbHVlO1xuXG4gICAgICB3aGlsZSAoKytqIDwgbSkge1xuICAgICAgICByb3cgPSByb3dzW2pdLCBub2RlcyA9IHJvdy5jaGlsZHJlbjtcbiAgICAgICAgZm9yIChpID0gcm93LnZhbHVlID0gMCwgbiA9IG5vZGVzLmxlbmd0aDsgaSA8IG47ICsraSkgcm93LnZhbHVlICs9IG5vZGVzW2ldLnZhbHVlO1xuICAgICAgICBpZiAocm93LmRpY2UpIHRyZWVtYXBEaWNlKHJvdywgeDAsIHkwLCB4MSwgeTAgKz0gKHkxIC0geTApICogcm93LnZhbHVlIC8gdmFsdWUpO1xuICAgICAgICBlbHNlIHRyZWVtYXBTbGljZShyb3csIHgwLCB5MCwgeDAgKz0gKHgxIC0geDApICogcm93LnZhbHVlIC8gdmFsdWUsIHkxKTtcbiAgICAgICAgdmFsdWUgLT0gcm93LnZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQuX3NxdWFyaWZ5ID0gcm93cyA9IHNxdWFyaWZ5UmF0aW8ocmF0aW8sIHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpO1xuICAgICAgcm93cy5yYXRpbyA9IHJhdGlvO1xuICAgIH1cbiAgfVxuXG4gIHJlc3F1YXJpZnkucmF0aW8gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGN1c3RvbSgoeCA9ICt4KSA+IDEgPyB4IDogMSk7XG4gIH07XG5cbiAgcmV0dXJuIHJlc3F1YXJpZnk7XG59KShwaGkpO1xuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGNsdXN0ZXJ9IGZyb20gXCIuL2NsdXN0ZXJcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBoaWVyYXJjaHl9IGZyb20gXCIuL2hpZXJhcmNoeS9pbmRleFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHBhY2t9IGZyb20gXCIuL3BhY2svaW5kZXhcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwYWNrU2libGluZ3N9IGZyb20gXCIuL3BhY2svc2libGluZ3NcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwYWNrRW5jbG9zZX0gZnJvbSBcIi4vcGFjay9lbmNsb3NlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcGFydGl0aW9ufSBmcm9tIFwiLi9wYXJ0aXRpb25cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdHJhdGlmeX0gZnJvbSBcIi4vc3RyYXRpZnlcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0cmVlfSBmcm9tIFwiLi90cmVlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdHJlZW1hcH0gZnJvbSBcIi4vdHJlZW1hcC9pbmRleFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRyZWVtYXBCaW5hcnl9IGZyb20gXCIuL3RyZWVtYXAvYmluYXJ5XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdHJlZW1hcERpY2V9IGZyb20gXCIuL3RyZWVtYXAvZGljZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRyZWVtYXBTbGljZX0gZnJvbSBcIi4vdHJlZW1hcC9zbGljZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRyZWVtYXBTbGljZURpY2V9IGZyb20gXCIuL3RyZWVtYXAvc2xpY2VEaWNlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdHJlZW1hcFNxdWFyaWZ5fSBmcm9tIFwiLi90cmVlbWFwL3NxdWFyaWZ5XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdHJlZW1hcFJlc3F1YXJpZnl9IGZyb20gXCIuL3RyZWVtYXAvcmVzcXVhcmlmeVwiO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///265\n')},463:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/*!\n * reactjs-popup v1.3.1\n * (c) 2018-present Youssouf EL AZIZI <youssoufelazizi@gmail.com>\n * Released under the MIT License.\n */\n\n\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if ("value" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === "object" || typeof call === "function")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError("Invalid attempt to spread non-iterable instance");\n}\n\n/* Algo to calculate position\n  1. center position for popup content : the center of the trigger will be the center of the content content\n      so the popup content position will be like this :\n      top => the y of the center for the trigger element : trigger.top + trigger.height/2\n      left => the x of the center for the trigger element : trigger.left + trigger.width/2\n\n  2. translate position according to the first  position attribute  passed  in the function argument\n      for example :\n        position = \'left top\'\n        we need to handle the first argument in the position: \'left\' => that\'s mean we need to translate the popup content according to the X axis by - content.width/2\n\n  3.translate position according to the first  position attribute  passed  in the function argument\n    for example :\n      position = \'left top\'\n      the second argument \'top\' => translate popup content by + content.height*4/5\n\n  4. check if calculated position is going out of bounds of wrapper box or not. If yes repeat 1-3 for next position enum. By default wrapper box is window element\n*/\nfunction getCoordinatesForPosition(triggerBounding, ContentBounding, position, arrow, _ref) {\n  var offsetX = _ref.offsetX,\n      offsetY = _ref.offsetY;\n  var margin = arrow ? 8 : 0;\n  var args = position.split(" "); // the step N 1 : center the popup content => ok\n\n  var CenterTop = triggerBounding.top + triggerBounding.height / 2;\n  var CenterLeft = triggerBounding.left + triggerBounding.width / 2;\n  var height = ContentBounding.height,\n      width = ContentBounding.width;\n  var top = CenterTop - height / 2;\n  var left = CenterLeft - width / 2;\n  var transform = "";\n  var arrowTop = "0%";\n  var arrowLeft = "0%"; // the  step N 2 : => ok\n\n  switch (args[0]) {\n    case "top":\n      top -= height / 2 + triggerBounding.height / 2 + margin;\n      transform = "rotate(45deg)";\n      arrowTop = "100%";\n      arrowLeft = "50%";\n      break;\n\n    case "bottom":\n      top += height / 2 + triggerBounding.height / 2 + margin;\n      transform = "rotate(225deg)";\n      arrowLeft = "50%";\n      break;\n\n    case "left":\n      left -= width / 2 + triggerBounding.width / 2 + margin;\n      transform = " rotate(-45deg)";\n      arrowLeft = "100%";\n      arrowTop = "50%";\n      break;\n\n    case "right":\n      left += width / 2 + triggerBounding.width / 2 + margin;\n      transform = "rotate(135deg)";\n      arrowTop = "50%";\n      break;\n  }\n\n  switch (args[1]) {\n    case "top":\n      top = triggerBounding.top;\n      arrowTop = triggerBounding.height / 2 + "px";\n      break;\n\n    case "bottom":\n      top = triggerBounding.top - height + triggerBounding.height;\n      arrowTop = height - triggerBounding.height / 2 + "px";\n      break;\n\n    case "left":\n      left = triggerBounding.left;\n      arrowLeft = triggerBounding.width / 2 + "px";\n      break;\n\n    case "right":\n      left = triggerBounding.left - width + triggerBounding.width;\n      arrowLeft = width - triggerBounding.width / 2 + "px";\n      break;\n  }\n\n  top = args[0] === "top" ? top - offsetY : top + offsetY;\n  left = args[0] === "left" ? left - offsetX : left + offsetX;\n  return {\n    top: top,\n    left: left,\n    transform: transform,\n    arrowLeft: arrowLeft,\n    arrowTop: arrowTop\n  };\n}\n\nfunction calculatePosition(triggerBounding, ContentBounding, positions, arrow, _ref2, wrapperBox) {\n  var offsetX = _ref2.offsetX,\n      offsetY = _ref2.offsetY;\n  var bestCoords;\n  var i = 0;\n\n  while (i < positions.length) {\n    bestCoords = getCoordinatesForPosition(triggerBounding, ContentBounding, positions[i], arrow, {\n      offsetX: offsetX,\n      offsetY: offsetY\n    });\n    var contentBox = {\n      top: bestCoords.top,\n      left: bestCoords.left,\n      width: ContentBounding.width,\n      height: ContentBounding.height\n    };\n\n    if (contentBox.top <= wrapperBox.top || contentBox.left <= wrapperBox.left || contentBox.top + contentBox.height >= wrapperBox.top + wrapperBox.height || contentBox.left + contentBox.width >= wrapperBox.left + wrapperBox.width) {\n      i++;\n    } else {\n      break;\n    }\n  }\n\n  return bestCoords;\n}\n\nvar styles = {\n  popupContent: {\n    tooltip: {\n      position: "absolute",\n      zIndex: "2",\n      width: "200px",\n      background: "rgb(255, 255, 255)",\n      border: "1px solid rgb(187, 187, 187)",\n      boxShadow: "rgba(0, 0, 0, 0.2) 0px 1px 3px",\n      padding: "5px"\n    },\n    modal: {\n      position: "relative",\n      background: "rgb(255, 255, 255)",\n      width: "50%",\n      margin: "auto",\n      border: "1px solid rgb(187, 187, 187)",\n      padding: "5px"\n    }\n  },\n  popupArrow: {\n    height: "10px",\n    width: "10px",\n    position: "absolute",\n    background: "rgb(255, 255, 255)",\n    transform: "rotate(45deg)",\n    margin: "-5px",\n    zIndex: "-1",\n    boxShadow: "rgba(0, 0, 0, 0.2) 1px 1px 1px"\n  },\n  overlay: {\n    tooltip: {\n      position: "fixed",\n      top: "0",\n      bottom: "0",\n      left: "0",\n      right: "0"\n    },\n    modal: {\n      position: "fixed",\n      top: "0",\n      bottom: "0",\n      left: "0",\n      right: "0",\n      background: "rgba(0, 0, 0,0.5)",\n      display: "flex",\n      zIndex: "999"\n    }\n  }\n};\n\nvar POSITION_TYPES = ["top left", "top center", "top right", "right top", "right center", "right bottom", "bottom left", "bottom center", "bottom right", "left top", "left center", "left bottom"];\n\nvar Popup =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(Popup, _React$PureComponent);\n\n  function Popup(props) {\n    var _this;\n\n    _classCallCheck(this, Popup);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Popup).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {\n      isOpen: _this.props.open || _this.props.defaultOpen,\n      modal: _this.props.modal ? true : !_this.props.trigger // we create this modal state because the popup can\'t be a tooltip if the trigger prop doesn\'t exist\n\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "lockScroll", function () {\n      if (_this.state.modal && _this.props.lockScroll) document.getElementsByTagName("body")[0].style.overflow = "hidden";\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "resetScroll", function () {\n      if (_this.state.modal && _this.props.lockScroll) document.getElementsByTagName("body")[0].style.overflow = "auto";\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "togglePopup", function () {\n      if (_this.state.isOpen) _this.closePopup();else _this.openPopup();\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "openPopup", function () {\n      if (_this.state.isOpen || _this.props.disabled) return;\n\n      _this.setState({\n        isOpen: true\n      }, function () {\n        _this.setPosition();\n\n        _this.props.onOpen();\n\n        _this.lockScroll();\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "closePopup", function () {\n      if (!_this.state.isOpen) return;\n\n      _this.props.onClose();\n\n      _this.setState({\n        isOpen: false\n      }, function () {\n        _this.resetScroll();\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onMouseEnter", function () {\n      clearTimeout(_this.timeOut);\n      var mouseEnterDelay = _this.props.mouseEnterDelay;\n      _this.timeOut = setTimeout(function () {\n        return _this.openPopup();\n      }, mouseEnterDelay);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onMouseLeave", function () {\n      clearTimeout(_this.timeOut);\n      var mouseLeaveDelay = _this.props.mouseLeaveDelay;\n      _this.timeOut = setTimeout(function () {\n        return _this.closePopup();\n      }, mouseLeaveDelay);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getTooltipBoundary", function () {\n      var keepTooltipInside = _this.props.keepTooltipInside;\n      var boundingBox = {\n        top: 0,\n        left: 0,\n        width: window.innerWidth,\n        height: window.innerHeight\n      };\n\n      if (typeof keepTooltipInside === "string") {\n        var selector = document.querySelector(keepTooltipInside);\n\n        if (false) {}\n\n        boundingBox = selector.getBoundingClientRect();\n      }\n\n      return boundingBox;\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "setPosition", function () {\n      var _this$props = _this.props,\n          arrow = _this$props.arrow,\n          position = _this$props.position,\n          offsetX = _this$props.offsetX,\n          offsetY = _this$props.offsetY,\n          keepTooltipInside = _this$props.keepTooltipInside,\n          arrowStyle = _this$props.arrowStyle;\n      var modal = _this.state.modal;\n      if (modal) return;\n\n      var helper = _this.HelperEl.getBoundingClientRect();\n\n      var trigger = _this.TriggerEl.getBoundingClientRect();\n\n      var content = _this.ContentEl.getBoundingClientRect();\n\n      var boundingBox = _this.getTooltipBoundary();\n\n      var positions = Array.isArray(position) ? position : [position]; // keepTooltipInside would be activated if the  keepTooltipInside exist or the position is Array\n\n      if (keepTooltipInside || Array.isArray(position)) positions = _toConsumableArray(positions).concat(POSITION_TYPES);\n      var cords = calculatePosition(trigger, content, positions, arrow, {\n        offsetX: offsetX,\n        offsetY: offsetY\n      }, boundingBox);\n      _this.ContentEl.style.top = cords.top - helper.top + "px";\n      _this.ContentEl.style.left = cords.left - helper.left + "px";\n\n      if (arrow) {\n        _this.ArrowEl.style["transform"] = cords.transform;\n        _this.ArrowEl.style["-ms-transform"] = cords.transform;\n        _this.ArrowEl.style["-webkit-transform"] = cords.transform;\n        _this.ArrowEl.style.top = arrowStyle.top || cords.arrowTop;\n        _this.ArrowEl.style.left = arrowStyle.left || cords.arrowLeft;\n      }\n\n      if (window.getComputedStyle(_this.TriggerEl, null).getPropertyValue("position") == "static" || window.getComputedStyle(_this.TriggerEl, null).getPropertyValue("position") == "") _this.TriggerEl.style.position = "relative";\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "addWarperAction", function () {\n      var _this$props2 = _this.props,\n          contentStyle = _this$props2.contentStyle,\n          className = _this$props2.className,\n          on = _this$props2.on;\n      var modal = _this.state.modal;\n      var popupContentStyle = modal ? styles.popupContent.modal : styles.popupContent.tooltip;\n      var childrenElementProps = {\n        className: "popup-content ".concat(className),\n        style: Object.assign({}, popupContentStyle, contentStyle),\n        ref: _this.setContentRef,\n        onClick: function onClick(e) {\n          e.stopPropagation();\n        }\n      };\n\n      if (!modal && on.indexOf("hover") >= 0) {\n        childrenElementProps.onMouseEnter = _this.onMouseEnter;\n        childrenElementProps.onMouseLeave = _this.onMouseLeave;\n      }\n\n      return childrenElementProps;\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "renderTrigger", function () {\n      var triggerProps = {\n        key: "T"\n      };\n      var _this$props3 = _this.props,\n          on = _this$props3.on,\n          trigger = _this$props3.trigger;\n      var onAsArray = Array.isArray(on) ? on : [on];\n\n      for (var i = 0, len = onAsArray.length; i < len; i++) {\n        switch (onAsArray[i]) {\n          case "click":\n            triggerProps.onClick = _this.togglePopup;\n            break;\n\n          case "hover":\n            triggerProps.onMouseEnter = _this.onMouseEnter;\n            triggerProps.onMouseLeave = _this.onMouseLeave;\n            break;\n\n          case "focus":\n            triggerProps.onFocus = _this.onMouseEnter;\n            break;\n        }\n      }\n\n      if (typeof trigger === "function") return react__WEBPACK_IMPORTED_MODULE_0___default.a.cloneElement(trigger(_this.state.isOpen), triggerProps);\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.cloneElement(trigger, triggerProps);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "renderContent", function () {\n      var _this$props4 = _this.props,\n          arrow = _this$props4.arrow,\n          arrowStyle = _this$props4.arrowStyle;\n      var modal = _this.state.modal;\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", _extends({}, _this.addWarperAction(), {\n        key: "C"\n      }), arrow && !modal && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {\n        ref: _this.setArrowRef,\n        style: Object.assign({}, styles.popupArrow, arrowStyle)\n      }), typeof _this.props.children === "function" ? _this.props.children(_this.closePopup, _this.state.isOpen) : _this.props.children);\n    });\n\n    _this.setTriggerRef = function (r) {\n      return _this.TriggerEl = r;\n    };\n\n    _this.setContentRef = function (r) {\n      return _this.ContentEl = r;\n    };\n\n    _this.setArrowRef = function (r) {\n      return _this.ArrowEl = r;\n    };\n\n    _this.setHelperRef = function (r) {\n      return _this.HelperEl = r;\n    };\n\n    _this.timeOut = 0;\n    return _this;\n  }\n\n  _createClass(Popup, [{\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var _this$props5 = this.props,\n          closeOnEscape = _this$props5.closeOnEscape,\n          defaultOpen = _this$props5.defaultOpen;\n      if (defaultOpen) this.setPosition();\n\n      if (closeOnEscape) {\n        window.addEventListener("keyup", function (e) {\n          if (e.key === "Escape") _this2.closePopup();\n        });\n      }\n    }\n  }, {\n    key: "componentWillReceiveProps",\n    value: function componentWillReceiveProps(nextProps) {\n      if (this.props.open === nextProps.open) return;\n      if (nextProps.open) this.openPopup();else this.closePopup();\n    }\n  }, {\n    key: "componentDidUpdate",\n    value: function componentDidUpdate(prevProps) {\n      if (prevProps.disabled !== this.props.disabled && this.props.disabled && this.state.isOpen) {\n        this.closePopup();\n      }\n    }\n  }, {\n    key: "componentWillUnmount",\n    value: function componentWillUnmount() {\n      // kill any function to execute if the component is unmounted\n      clearTimeout(this.timeOut);\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this$props6 = this.props,\n          overlayStyle = _this$props6.overlayStyle,\n          closeOnDocumentClick = _this$props6.closeOnDocumentClick,\n          on = _this$props6.on;\n      var modal = this.state.modal;\n      var overlay = this.state.isOpen && !(on.indexOf("hover") >= 0);\n      var ovStyle = modal ? styles.overlay.modal : styles.overlay.tooltip;\n      return [!!this.props.trigger && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Ref, {\n        innerRef: this.setTriggerRef,\n        key: "R"\n      }, this.renderTrigger()), this.state.isOpen && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {\n        key: "H",\n        style: {\n          position: "absolute",\n          top: "0px",\n          left: "0px"\n        },\n        ref: this.setHelperRef\n      }), overlay && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {\n        key: "O",\n        className: "popup-overlay",\n        style: Object.assign({}, ovStyle, overlayStyle),\n        onClick: closeOnDocumentClick ? this.closePopup : undefined\n      }, modal && this.renderContent()), this.state.isOpen && !modal && this.renderContent()];\n    }\n  }]);\n\n  return Popup;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent);\n\n_defineProperty(Popup, "defaultProps", {\n  children: function children() {\n    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", null, " Your Content Here !!");\n  },\n  trigger: null,\n  onOpen: function onOpen() {},\n  onClose: function onClose() {},\n  defaultOpen: false,\n  open: false,\n  disabled: false,\n  closeOnDocumentClick: true,\n  closeOnEscape: true,\n  on: ["click"],\n  contentStyle: {},\n  arrowStyle: {},\n  overlayStyle: {},\n  className: "",\n  position: "bottom center",\n  modal: false,\n  lockScroll: false,\n  arrow: true,\n  offsetX: 0,\n  offsetY: 0,\n  mouseEnterDelay: 100,\n  mouseLeaveDelay: 100,\n  keepTooltipInside: false\n});\n\nif (false) { var TRIGGER_TYPES, PropTypes; }\n\nvar Ref =\n/*#__PURE__*/\nfunction (_React$PureComponent2) {\n  _inherits(Ref, _React$PureComponent2);\n\n  function Ref() {\n    _classCallCheck(this, Ref);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Ref).apply(this, arguments));\n  }\n\n  _createClass(Ref, [{\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      var innerRef = this.props.innerRef;\n      if (innerRef) innerRef(Object(react_dom__WEBPACK_IMPORTED_MODULE_1__["findDOMNode"])(this));\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var children = this.props.children;\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.Children.only(children);\n    }\n  }]);\n\n  return Ref;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent);\n\n/* harmony default export */ __webpack_exports__["default"] = (Popup);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Rqcy1wb3B1cC9yZWFjdGpzLXBvcHVwLmVzLmpzP2NjZjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMEI7QUFDYzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCOztBQUVqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsaURBQWlEO0FBQ2pELEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0EsT0FB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b0VBQUssRUFBQyIsImZpbGUiOiI0NjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHJlYWN0anMtcG9wdXAgdjEuMy4xXG4gKiAoYykgMjAxOC1wcmVzZW50IFlvdXNzb3VmIEVMIEFaSVpJIDx5b3Vzc291ZmVsYXppemlAZ21haWwuY29tPlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG59XG5cbi8qIEFsZ28gdG8gY2FsY3VsYXRlIHBvc2l0aW9uXG4gIDEuIGNlbnRlciBwb3NpdGlvbiBmb3IgcG9wdXAgY29udGVudCA6IHRoZSBjZW50ZXIgb2YgdGhlIHRyaWdnZXIgd2lsbCBiZSB0aGUgY2VudGVyIG9mIHRoZSBjb250ZW50IGNvbnRlbnRcbiAgICAgIHNvIHRoZSBwb3B1cCBjb250ZW50IHBvc2l0aW9uIHdpbGwgYmUgbGlrZSB0aGlzIDpcbiAgICAgIHRvcCA9PiB0aGUgeSBvZiB0aGUgY2VudGVyIGZvciB0aGUgdHJpZ2dlciBlbGVtZW50IDogdHJpZ2dlci50b3AgKyB0cmlnZ2VyLmhlaWdodC8yXG4gICAgICBsZWZ0ID0+IHRoZSB4IG9mIHRoZSBjZW50ZXIgZm9yIHRoZSB0cmlnZ2VyIGVsZW1lbnQgOiB0cmlnZ2VyLmxlZnQgKyB0cmlnZ2VyLndpZHRoLzJcblxuICAyLiB0cmFuc2xhdGUgcG9zaXRpb24gYWNjb3JkaW5nIHRvIHRoZSBmaXJzdCAgcG9zaXRpb24gYXR0cmlidXRlICBwYXNzZWQgIGluIHRoZSBmdW5jdGlvbiBhcmd1bWVudFxuICAgICAgZm9yIGV4YW1wbGUgOlxuICAgICAgICBwb3NpdGlvbiA9ICdsZWZ0IHRvcCdcbiAgICAgICAgd2UgbmVlZCB0byBoYW5kbGUgdGhlIGZpcnN0IGFyZ3VtZW50IGluIHRoZSBwb3NpdGlvbjogJ2xlZnQnID0+IHRoYXQncyBtZWFuIHdlIG5lZWQgdG8gdHJhbnNsYXRlIHRoZSBwb3B1cCBjb250ZW50IGFjY29yZGluZyB0byB0aGUgWCBheGlzIGJ5IC0gY29udGVudC53aWR0aC8yXG5cbiAgMy50cmFuc2xhdGUgcG9zaXRpb24gYWNjb3JkaW5nIHRvIHRoZSBmaXJzdCAgcG9zaXRpb24gYXR0cmlidXRlICBwYXNzZWQgIGluIHRoZSBmdW5jdGlvbiBhcmd1bWVudFxuICAgIGZvciBleGFtcGxlIDpcbiAgICAgIHBvc2l0aW9uID0gJ2xlZnQgdG9wJ1xuICAgICAgdGhlIHNlY29uZCBhcmd1bWVudCAndG9wJyA9PiB0cmFuc2xhdGUgcG9wdXAgY29udGVudCBieSArIGNvbnRlbnQuaGVpZ2h0KjQvNVxuXG4gIDQuIGNoZWNrIGlmIGNhbGN1bGF0ZWQgcG9zaXRpb24gaXMgZ29pbmcgb3V0IG9mIGJvdW5kcyBvZiB3cmFwcGVyIGJveCBvciBub3QuIElmIHllcyByZXBlYXQgMS0zIGZvciBuZXh0IHBvc2l0aW9uIGVudW0uIEJ5IGRlZmF1bHQgd3JhcHBlciBib3ggaXMgd2luZG93IGVsZW1lbnRcbiovXG5mdW5jdGlvbiBnZXRDb29yZGluYXRlc0ZvclBvc2l0aW9uKHRyaWdnZXJCb3VuZGluZywgQ29udGVudEJvdW5kaW5nLCBwb3NpdGlvbiwgYXJyb3csIF9yZWYpIHtcbiAgdmFyIG9mZnNldFggPSBfcmVmLm9mZnNldFgsXG4gICAgICBvZmZzZXRZID0gX3JlZi5vZmZzZXRZO1xuICB2YXIgbWFyZ2luID0gYXJyb3cgPyA4IDogMDtcbiAgdmFyIGFyZ3MgPSBwb3NpdGlvbi5zcGxpdChcIiBcIik7IC8vIHRoZSBzdGVwIE4gMSA6IGNlbnRlciB0aGUgcG9wdXAgY29udGVudCA9PiBva1xuXG4gIHZhciBDZW50ZXJUb3AgPSB0cmlnZ2VyQm91bmRpbmcudG9wICsgdHJpZ2dlckJvdW5kaW5nLmhlaWdodCAvIDI7XG4gIHZhciBDZW50ZXJMZWZ0ID0gdHJpZ2dlckJvdW5kaW5nLmxlZnQgKyB0cmlnZ2VyQm91bmRpbmcud2lkdGggLyAyO1xuICB2YXIgaGVpZ2h0ID0gQ29udGVudEJvdW5kaW5nLmhlaWdodCxcbiAgICAgIHdpZHRoID0gQ29udGVudEJvdW5kaW5nLndpZHRoO1xuICB2YXIgdG9wID0gQ2VudGVyVG9wIC0gaGVpZ2h0IC8gMjtcbiAgdmFyIGxlZnQgPSBDZW50ZXJMZWZ0IC0gd2lkdGggLyAyO1xuICB2YXIgdHJhbnNmb3JtID0gXCJcIjtcbiAgdmFyIGFycm93VG9wID0gXCIwJVwiO1xuICB2YXIgYXJyb3dMZWZ0ID0gXCIwJVwiOyAvLyB0aGUgIHN0ZXAgTiAyIDogPT4gb2tcblxuICBzd2l0Y2ggKGFyZ3NbMF0pIHtcbiAgICBjYXNlIFwidG9wXCI6XG4gICAgICB0b3AgLT0gaGVpZ2h0IC8gMiArIHRyaWdnZXJCb3VuZGluZy5oZWlnaHQgLyAyICsgbWFyZ2luO1xuICAgICAgdHJhbnNmb3JtID0gXCJyb3RhdGUoNDVkZWcpXCI7XG4gICAgICBhcnJvd1RvcCA9IFwiMTAwJVwiO1xuICAgICAgYXJyb3dMZWZ0ID0gXCI1MCVcIjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgdG9wICs9IGhlaWdodCAvIDIgKyB0cmlnZ2VyQm91bmRpbmcuaGVpZ2h0IC8gMiArIG1hcmdpbjtcbiAgICAgIHRyYW5zZm9ybSA9IFwicm90YXRlKDIyNWRlZylcIjtcbiAgICAgIGFycm93TGVmdCA9IFwiNTAlXCI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICBsZWZ0IC09IHdpZHRoIC8gMiArIHRyaWdnZXJCb3VuZGluZy53aWR0aCAvIDIgKyBtYXJnaW47XG4gICAgICB0cmFuc2Zvcm0gPSBcIiByb3RhdGUoLTQ1ZGVnKVwiO1xuICAgICAgYXJyb3dMZWZ0ID0gXCIxMDAlXCI7XG4gICAgICBhcnJvd1RvcCA9IFwiNTAlXCI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgbGVmdCArPSB3aWR0aCAvIDIgKyB0cmlnZ2VyQm91bmRpbmcud2lkdGggLyAyICsgbWFyZ2luO1xuICAgICAgdHJhbnNmb3JtID0gXCJyb3RhdGUoMTM1ZGVnKVwiO1xuICAgICAgYXJyb3dUb3AgPSBcIjUwJVwiO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBzd2l0Y2ggKGFyZ3NbMV0pIHtcbiAgICBjYXNlIFwidG9wXCI6XG4gICAgICB0b3AgPSB0cmlnZ2VyQm91bmRpbmcudG9wO1xuICAgICAgYXJyb3dUb3AgPSB0cmlnZ2VyQm91bmRpbmcuaGVpZ2h0IC8gMiArIFwicHhcIjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgdG9wID0gdHJpZ2dlckJvdW5kaW5nLnRvcCAtIGhlaWdodCArIHRyaWdnZXJCb3VuZGluZy5oZWlnaHQ7XG4gICAgICBhcnJvd1RvcCA9IGhlaWdodCAtIHRyaWdnZXJCb3VuZGluZy5oZWlnaHQgLyAyICsgXCJweFwiO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgbGVmdCA9IHRyaWdnZXJCb3VuZGluZy5sZWZ0O1xuICAgICAgYXJyb3dMZWZ0ID0gdHJpZ2dlckJvdW5kaW5nLndpZHRoIC8gMiArIFwicHhcIjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICBsZWZ0ID0gdHJpZ2dlckJvdW5kaW5nLmxlZnQgLSB3aWR0aCArIHRyaWdnZXJCb3VuZGluZy53aWR0aDtcbiAgICAgIGFycm93TGVmdCA9IHdpZHRoIC0gdHJpZ2dlckJvdW5kaW5nLndpZHRoIC8gMiArIFwicHhcIjtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdG9wID0gYXJnc1swXSA9PT0gXCJ0b3BcIiA/IHRvcCAtIG9mZnNldFkgOiB0b3AgKyBvZmZzZXRZO1xuICBsZWZ0ID0gYXJnc1swXSA9PT0gXCJsZWZ0XCIgPyBsZWZ0IC0gb2Zmc2V0WCA6IGxlZnQgKyBvZmZzZXRYO1xuICByZXR1cm4ge1xuICAgIHRvcDogdG9wLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgYXJyb3dMZWZ0OiBhcnJvd0xlZnQsXG4gICAgYXJyb3dUb3A6IGFycm93VG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9uKHRyaWdnZXJCb3VuZGluZywgQ29udGVudEJvdW5kaW5nLCBwb3NpdGlvbnMsIGFycm93LCBfcmVmMiwgd3JhcHBlckJveCkge1xuICB2YXIgb2Zmc2V0WCA9IF9yZWYyLm9mZnNldFgsXG4gICAgICBvZmZzZXRZID0gX3JlZjIub2Zmc2V0WTtcbiAgdmFyIGJlc3RDb29yZHM7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IHBvc2l0aW9ucy5sZW5ndGgpIHtcbiAgICBiZXN0Q29vcmRzID0gZ2V0Q29vcmRpbmF0ZXNGb3JQb3NpdGlvbih0cmlnZ2VyQm91bmRpbmcsIENvbnRlbnRCb3VuZGluZywgcG9zaXRpb25zW2ldLCBhcnJvdywge1xuICAgICAgb2Zmc2V0WDogb2Zmc2V0WCxcbiAgICAgIG9mZnNldFk6IG9mZnNldFlcbiAgICB9KTtcbiAgICB2YXIgY29udGVudEJveCA9IHtcbiAgICAgIHRvcDogYmVzdENvb3Jkcy50b3AsXG4gICAgICBsZWZ0OiBiZXN0Q29vcmRzLmxlZnQsXG4gICAgICB3aWR0aDogQ29udGVudEJvdW5kaW5nLndpZHRoLFxuICAgICAgaGVpZ2h0OiBDb250ZW50Qm91bmRpbmcuaGVpZ2h0XG4gICAgfTtcblxuICAgIGlmIChjb250ZW50Qm94LnRvcCA8PSB3cmFwcGVyQm94LnRvcCB8fCBjb250ZW50Qm94LmxlZnQgPD0gd3JhcHBlckJveC5sZWZ0IHx8IGNvbnRlbnRCb3gudG9wICsgY29udGVudEJveC5oZWlnaHQgPj0gd3JhcHBlckJveC50b3AgKyB3cmFwcGVyQm94LmhlaWdodCB8fCBjb250ZW50Qm94LmxlZnQgKyBjb250ZW50Qm94LndpZHRoID49IHdyYXBwZXJCb3gubGVmdCArIHdyYXBwZXJCb3gud2lkdGgpIHtcbiAgICAgIGkrKztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJlc3RDb29yZHM7XG59XG5cbnZhciBzdHlsZXMgPSB7XG4gIHBvcHVwQ29udGVudDoge1xuICAgIHRvb2x0aXA6IHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICB6SW5kZXg6IFwiMlwiLFxuICAgICAgd2lkdGg6IFwiMjAwcHhcIixcbiAgICAgIGJhY2tncm91bmQ6IFwicmdiKDI1NSwgMjU1LCAyNTUpXCIsXG4gICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHJnYigxODcsIDE4NywgMTg3KVwiLFxuICAgICAgYm94U2hhZG93OiBcInJnYmEoMCwgMCwgMCwgMC4yKSAwcHggMXB4IDNweFwiLFxuICAgICAgcGFkZGluZzogXCI1cHhcIlxuICAgIH0sXG4gICAgbW9kYWw6IHtcbiAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcInJnYigyNTUsIDI1NSwgMjU1KVwiLFxuICAgICAgd2lkdGg6IFwiNTAlXCIsXG4gICAgICBtYXJnaW46IFwiYXV0b1wiLFxuICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCByZ2IoMTg3LCAxODcsIDE4NylcIixcbiAgICAgIHBhZGRpbmc6IFwiNXB4XCJcbiAgICB9XG4gIH0sXG4gIHBvcHVwQXJyb3c6IHtcbiAgICBoZWlnaHQ6IFwiMTBweFwiLFxuICAgIHdpZHRoOiBcIjEwcHhcIixcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIGJhY2tncm91bmQ6IFwicmdiKDI1NSwgMjU1LCAyNTUpXCIsXG4gICAgdHJhbnNmb3JtOiBcInJvdGF0ZSg0NWRlZylcIixcbiAgICBtYXJnaW46IFwiLTVweFwiLFxuICAgIHpJbmRleDogXCItMVwiLFxuICAgIGJveFNoYWRvdzogXCJyZ2JhKDAsIDAsIDAsIDAuMikgMXB4IDFweCAxcHhcIlxuICB9LFxuICBvdmVybGF5OiB7XG4gICAgdG9vbHRpcDoge1xuICAgICAgcG9zaXRpb246IFwiZml4ZWRcIixcbiAgICAgIHRvcDogXCIwXCIsXG4gICAgICBib3R0b206IFwiMFwiLFxuICAgICAgbGVmdDogXCIwXCIsXG4gICAgICByaWdodDogXCIwXCJcbiAgICB9LFxuICAgIG1vZGFsOiB7XG4gICAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgICAgdG9wOiBcIjBcIixcbiAgICAgIGJvdHRvbTogXCIwXCIsXG4gICAgICBsZWZ0OiBcIjBcIixcbiAgICAgIHJpZ2h0OiBcIjBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwicmdiYSgwLCAwLCAwLDAuNSlcIixcbiAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgekluZGV4OiBcIjk5OVwiXG4gICAgfVxuICB9XG59O1xuXG52YXIgUE9TSVRJT05fVFlQRVMgPSBbXCJ0b3AgbGVmdFwiLCBcInRvcCBjZW50ZXJcIiwgXCJ0b3AgcmlnaHRcIiwgXCJyaWdodCB0b3BcIiwgXCJyaWdodCBjZW50ZXJcIiwgXCJyaWdodCBib3R0b21cIiwgXCJib3R0b20gbGVmdFwiLCBcImJvdHRvbSBjZW50ZXJcIiwgXCJib3R0b20gcmlnaHRcIiwgXCJsZWZ0IHRvcFwiLCBcImxlZnQgY2VudGVyXCIsIFwibGVmdCBib3R0b21cIl07XG5cbnZhciBQb3B1cCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFBvcHVwLCBfUmVhY3QkUHVyZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUG9wdXAocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wdXApO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoUG9wdXApLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgXCJzdGF0ZVwiLCB7XG4gICAgICBpc09wZW46IF90aGlzLnByb3BzLm9wZW4gfHwgX3RoaXMucHJvcHMuZGVmYXVsdE9wZW4sXG4gICAgICBtb2RhbDogX3RoaXMucHJvcHMubW9kYWwgPyB0cnVlIDogIV90aGlzLnByb3BzLnRyaWdnZXIgLy8gd2UgY3JlYXRlIHRoaXMgbW9kYWwgc3RhdGUgYmVjYXVzZSB0aGUgcG9wdXAgY2FuJ3QgYmUgYSB0b29sdGlwIGlmIHRoZSB0cmlnZ2VyIHByb3AgZG9lc24ndCBleGlzdFxuXG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIFwibG9ja1Njcm9sbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuc3RhdGUubW9kYWwgJiYgX3RoaXMucHJvcHMubG9ja1Njcm9sbCkgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgXCJyZXNldFNjcm9sbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuc3RhdGUubW9kYWwgJiYgX3RoaXMucHJvcHMubG9ja1Njcm9sbCkgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdLnN0eWxlLm92ZXJmbG93ID0gXCJhdXRvXCI7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIFwidG9nZ2xlUG9wdXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLnN0YXRlLmlzT3BlbikgX3RoaXMuY2xvc2VQb3B1cCgpO2Vsc2UgX3RoaXMub3BlblBvcHVwKCk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIFwib3BlblBvcHVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5zdGF0ZS5pc09wZW4gfHwgX3RoaXMucHJvcHMuZGlzYWJsZWQpIHJldHVybjtcblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc09wZW46IHRydWVcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc2V0UG9zaXRpb24oKTtcblxuICAgICAgICBfdGhpcy5wcm9wcy5vbk9wZW4oKTtcblxuICAgICAgICBfdGhpcy5sb2NrU2Nyb2xsKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgXCJjbG9zZVBvcHVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3RoaXMuc3RhdGUuaXNPcGVuKSByZXR1cm47XG5cbiAgICAgIF90aGlzLnByb3BzLm9uQ2xvc2UoKTtcblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc09wZW46IGZhbHNlXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnJlc2V0U2Nyb2xsKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgXCJvbk1vdXNlRW50ZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVPdXQpO1xuICAgICAgdmFyIG1vdXNlRW50ZXJEZWxheSA9IF90aGlzLnByb3BzLm1vdXNlRW50ZXJEZWxheTtcbiAgICAgIF90aGlzLnRpbWVPdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLm9wZW5Qb3B1cCgpO1xuICAgICAgfSwgbW91c2VFbnRlckRlbGF5KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgXCJvbk1vdXNlTGVhdmVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVPdXQpO1xuICAgICAgdmFyIG1vdXNlTGVhdmVEZWxheSA9IF90aGlzLnByb3BzLm1vdXNlTGVhdmVEZWxheTtcbiAgICAgIF90aGlzLnRpbWVPdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmNsb3NlUG9wdXAoKTtcbiAgICAgIH0sIG1vdXNlTGVhdmVEZWxheSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIFwiZ2V0VG9vbHRpcEJvdW5kYXJ5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBrZWVwVG9vbHRpcEluc2lkZSA9IF90aGlzLnByb3BzLmtlZXBUb29sdGlwSW5zaWRlO1xuICAgICAgdmFyIGJvdW5kaW5nQm94ID0ge1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgIH07XG5cbiAgICAgIGlmICh0eXBlb2Yga2VlcFRvb2x0aXBJbnNpZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihrZWVwVG9vbHRpcEluc2lkZSk7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGtlZXBUb29sdGlwSW5zaWRlLCBcIiBzZWxlY3RvciBpcyBub3QgZXhpc3QgOiBrZWVwVG9vbHRpcEluc2lkZSBtdXN0IGJlIGEgdmFsaWQgaHRtbCBzZWxlY3RvciAnY2xhc3MnIG9yICdJZCcgIG9yIGEgYm9vbGVhbiB2YWx1ZVwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBib3VuZGluZ0JveCA9IHNlbGVjdG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIFwic2V0UG9zaXRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgYXJyb3cgPSBfdGhpcyRwcm9wcy5hcnJvdyxcbiAgICAgICAgICBwb3NpdGlvbiA9IF90aGlzJHByb3BzLnBvc2l0aW9uLFxuICAgICAgICAgIG9mZnNldFggPSBfdGhpcyRwcm9wcy5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFkgPSBfdGhpcyRwcm9wcy5vZmZzZXRZLFxuICAgICAgICAgIGtlZXBUb29sdGlwSW5zaWRlID0gX3RoaXMkcHJvcHMua2VlcFRvb2x0aXBJbnNpZGUsXG4gICAgICAgICAgYXJyb3dTdHlsZSA9IF90aGlzJHByb3BzLmFycm93U3R5bGU7XG4gICAgICB2YXIgbW9kYWwgPSBfdGhpcy5zdGF0ZS5tb2RhbDtcbiAgICAgIGlmIChtb2RhbCkgcmV0dXJuO1xuXG4gICAgICB2YXIgaGVscGVyID0gX3RoaXMuSGVscGVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIHZhciB0cmlnZ2VyID0gX3RoaXMuVHJpZ2dlckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICB2YXIgY29udGVudCA9IF90aGlzLkNvbnRlbnRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgdmFyIGJvdW5kaW5nQm94ID0gX3RoaXMuZ2V0VG9vbHRpcEJvdW5kYXJ5KCk7XG5cbiAgICAgIHZhciBwb3NpdGlvbnMgPSBBcnJheS5pc0FycmF5KHBvc2l0aW9uKSA/IHBvc2l0aW9uIDogW3Bvc2l0aW9uXTsgLy8ga2VlcFRvb2x0aXBJbnNpZGUgd291bGQgYmUgYWN0aXZhdGVkIGlmIHRoZSAga2VlcFRvb2x0aXBJbnNpZGUgZXhpc3Qgb3IgdGhlIHBvc2l0aW9uIGlzIEFycmF5XG5cbiAgICAgIGlmIChrZWVwVG9vbHRpcEluc2lkZSB8fCBBcnJheS5pc0FycmF5KHBvc2l0aW9uKSkgcG9zaXRpb25zID0gX3RvQ29uc3VtYWJsZUFycmF5KHBvc2l0aW9ucykuY29uY2F0KFBPU0lUSU9OX1RZUEVTKTtcbiAgICAgIHZhciBjb3JkcyA9IGNhbGN1bGF0ZVBvc2l0aW9uKHRyaWdnZXIsIGNvbnRlbnQsIHBvc2l0aW9ucywgYXJyb3csIHtcbiAgICAgICAgb2Zmc2V0WDogb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WTogb2Zmc2V0WVxuICAgICAgfSwgYm91bmRpbmdCb3gpO1xuICAgICAgX3RoaXMuQ29udGVudEVsLnN0eWxlLnRvcCA9IGNvcmRzLnRvcCAtIGhlbHBlci50b3AgKyBcInB4XCI7XG4gICAgICBfdGhpcy5Db250ZW50RWwuc3R5bGUubGVmdCA9IGNvcmRzLmxlZnQgLSBoZWxwZXIubGVmdCArIFwicHhcIjtcblxuICAgICAgaWYgKGFycm93KSB7XG4gICAgICAgIF90aGlzLkFycm93RWwuc3R5bGVbXCJ0cmFuc2Zvcm1cIl0gPSBjb3Jkcy50cmFuc2Zvcm07XG4gICAgICAgIF90aGlzLkFycm93RWwuc3R5bGVbXCItbXMtdHJhbnNmb3JtXCJdID0gY29yZHMudHJhbnNmb3JtO1xuICAgICAgICBfdGhpcy5BcnJvd0VsLnN0eWxlW1wiLXdlYmtpdC10cmFuc2Zvcm1cIl0gPSBjb3Jkcy50cmFuc2Zvcm07XG4gICAgICAgIF90aGlzLkFycm93RWwuc3R5bGUudG9wID0gYXJyb3dTdHlsZS50b3AgfHwgY29yZHMuYXJyb3dUb3A7XG4gICAgICAgIF90aGlzLkFycm93RWwuc3R5bGUubGVmdCA9IGFycm93U3R5bGUubGVmdCB8fCBjb3Jkcy5hcnJvd0xlZnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShfdGhpcy5UcmlnZ2VyRWwsIG51bGwpLmdldFByb3BlcnR5VmFsdWUoXCJwb3NpdGlvblwiKSA9PSBcInN0YXRpY1wiIHx8IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKF90aGlzLlRyaWdnZXJFbCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShcInBvc2l0aW9uXCIpID09IFwiXCIpIF90aGlzLlRyaWdnZXJFbC5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgXCJhZGRXYXJwZXJBY3Rpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGNvbnRlbnRTdHlsZSA9IF90aGlzJHByb3BzMi5jb250ZW50U3R5bGUsXG4gICAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMyLmNsYXNzTmFtZSxcbiAgICAgICAgICBvbiA9IF90aGlzJHByb3BzMi5vbjtcbiAgICAgIHZhciBtb2RhbCA9IF90aGlzLnN0YXRlLm1vZGFsO1xuICAgICAgdmFyIHBvcHVwQ29udGVudFN0eWxlID0gbW9kYWwgPyBzdHlsZXMucG9wdXBDb250ZW50Lm1vZGFsIDogc3R5bGVzLnBvcHVwQ29udGVudC50b29sdGlwO1xuICAgICAgdmFyIGNoaWxkcmVuRWxlbWVudFByb3BzID0ge1xuICAgICAgICBjbGFzc05hbWU6IFwicG9wdXAtY29udGVudCBcIi5jb25jYXQoY2xhc3NOYW1lKSxcbiAgICAgICAgc3R5bGU6IE9iamVjdC5hc3NpZ24oe30sIHBvcHVwQ29udGVudFN0eWxlLCBjb250ZW50U3R5bGUpLFxuICAgICAgICByZWY6IF90aGlzLnNldENvbnRlbnRSZWYsXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmICghbW9kYWwgJiYgb24uaW5kZXhPZihcImhvdmVyXCIpID49IDApIHtcbiAgICAgICAgY2hpbGRyZW5FbGVtZW50UHJvcHMub25Nb3VzZUVudGVyID0gX3RoaXMub25Nb3VzZUVudGVyO1xuICAgICAgICBjaGlsZHJlbkVsZW1lbnRQcm9wcy5vbk1vdXNlTGVhdmUgPSBfdGhpcy5vbk1vdXNlTGVhdmU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGlsZHJlbkVsZW1lbnRQcm9wcztcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgXCJyZW5kZXJUcmlnZ2VyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0cmlnZ2VyUHJvcHMgPSB7XG4gICAgICAgIGtleTogXCJUXCJcbiAgICAgIH07XG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgb24gPSBfdGhpcyRwcm9wczMub24sXG4gICAgICAgICAgdHJpZ2dlciA9IF90aGlzJHByb3BzMy50cmlnZ2VyO1xuICAgICAgdmFyIG9uQXNBcnJheSA9IEFycmF5LmlzQXJyYXkob24pID8gb24gOiBbb25dO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb25Bc0FycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAob25Bc0FycmF5W2ldKSB7XG4gICAgICAgICAgY2FzZSBcImNsaWNrXCI6XG4gICAgICAgICAgICB0cmlnZ2VyUHJvcHMub25DbGljayA9IF90aGlzLnRvZ2dsZVBvcHVwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiaG92ZXJcIjpcbiAgICAgICAgICAgIHRyaWdnZXJQcm9wcy5vbk1vdXNlRW50ZXIgPSBfdGhpcy5vbk1vdXNlRW50ZXI7XG4gICAgICAgICAgICB0cmlnZ2VyUHJvcHMub25Nb3VzZUxlYXZlID0gX3RoaXMub25Nb3VzZUxlYXZlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiZm9jdXNcIjpcbiAgICAgICAgICAgIHRyaWdnZXJQcm9wcy5vbkZvY3VzID0gX3RoaXMub25Nb3VzZUVudGVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0cmlnZ2VyID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQodHJpZ2dlcihfdGhpcy5zdGF0ZS5pc09wZW4pLCB0cmlnZ2VyUHJvcHMpO1xuICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudCh0cmlnZ2VyLCB0cmlnZ2VyUHJvcHMpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBcInJlbmRlckNvbnRlbnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGFycm93ID0gX3RoaXMkcHJvcHM0LmFycm93LFxuICAgICAgICAgIGFycm93U3R5bGUgPSBfdGhpcyRwcm9wczQuYXJyb3dTdHlsZTtcbiAgICAgIHZhciBtb2RhbCA9IF90aGlzLnN0YXRlLm1vZGFsO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe30sIF90aGlzLmFkZFdhcnBlckFjdGlvbigpLCB7XG4gICAgICAgIGtleTogXCJDXCJcbiAgICAgIH0pLCBhcnJvdyAmJiAhbW9kYWwgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHJlZjogX3RoaXMuc2V0QXJyb3dSZWYsXG4gICAgICAgIHN0eWxlOiBPYmplY3QuYXNzaWduKHt9LCBzdHlsZXMucG9wdXBBcnJvdywgYXJyb3dTdHlsZSlcbiAgICAgIH0pLCB0eXBlb2YgX3RoaXMucHJvcHMuY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IF90aGlzLnByb3BzLmNoaWxkcmVuKF90aGlzLmNsb3NlUG9wdXAsIF90aGlzLnN0YXRlLmlzT3BlbikgOiBfdGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5zZXRUcmlnZ2VyUmVmID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiBfdGhpcy5UcmlnZ2VyRWwgPSByO1xuICAgIH07XG5cbiAgICBfdGhpcy5zZXRDb250ZW50UmVmID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiBfdGhpcy5Db250ZW50RWwgPSByO1xuICAgIH07XG5cbiAgICBfdGhpcy5zZXRBcnJvd1JlZiA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gX3RoaXMuQXJyb3dFbCA9IHI7XG4gICAgfTtcblxuICAgIF90aGlzLnNldEhlbHBlclJlZiA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gX3RoaXMuSGVscGVyRWwgPSByO1xuICAgIH07XG5cbiAgICBfdGhpcy50aW1lT3V0ID0gMDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUG9wdXAsIFt7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBfdGhpcyRwcm9wczUgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNsb3NlT25Fc2NhcGUgPSBfdGhpcyRwcm9wczUuY2xvc2VPbkVzY2FwZSxcbiAgICAgICAgICBkZWZhdWx0T3BlbiA9IF90aGlzJHByb3BzNS5kZWZhdWx0T3BlbjtcbiAgICAgIGlmIChkZWZhdWx0T3BlbikgdGhpcy5zZXRQb3NpdGlvbigpO1xuXG4gICAgICBpZiAoY2xvc2VPbkVzY2FwZSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiKSBfdGhpczIuY2xvc2VQb3B1cCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgaWYgKHRoaXMucHJvcHMub3BlbiA9PT0gbmV4dFByb3BzLm9wZW4pIHJldHVybjtcbiAgICAgIGlmIChuZXh0UHJvcHMub3BlbikgdGhpcy5vcGVuUG9wdXAoKTtlbHNlIHRoaXMuY2xvc2VQb3B1cCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgaWYgKHByZXZQcm9wcy5kaXNhYmxlZCAhPT0gdGhpcy5wcm9wcy5kaXNhYmxlZCAmJiB0aGlzLnByb3BzLmRpc2FibGVkICYmIHRoaXMuc3RhdGUuaXNPcGVuKSB7XG4gICAgICAgIHRoaXMuY2xvc2VQb3B1cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIC8vIGtpbGwgYW55IGZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWRcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVPdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzNiA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgb3ZlcmxheVN0eWxlID0gX3RoaXMkcHJvcHM2Lm92ZXJsYXlTdHlsZSxcbiAgICAgICAgICBjbG9zZU9uRG9jdW1lbnRDbGljayA9IF90aGlzJHByb3BzNi5jbG9zZU9uRG9jdW1lbnRDbGljayxcbiAgICAgICAgICBvbiA9IF90aGlzJHByb3BzNi5vbjtcbiAgICAgIHZhciBtb2RhbCA9IHRoaXMuc3RhdGUubW9kYWw7XG4gICAgICB2YXIgb3ZlcmxheSA9IHRoaXMuc3RhdGUuaXNPcGVuICYmICEob24uaW5kZXhPZihcImhvdmVyXCIpID49IDApO1xuICAgICAgdmFyIG92U3R5bGUgPSBtb2RhbCA/IHN0eWxlcy5vdmVybGF5Lm1vZGFsIDogc3R5bGVzLm92ZXJsYXkudG9vbHRpcDtcbiAgICAgIHJldHVybiBbISF0aGlzLnByb3BzLnRyaWdnZXIgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChSZWYsIHtcbiAgICAgICAgaW5uZXJSZWY6IHRoaXMuc2V0VHJpZ2dlclJlZixcbiAgICAgICAga2V5OiBcIlJcIlxuICAgICAgfSwgdGhpcy5yZW5kZXJUcmlnZ2VyKCkpLCB0aGlzLnN0YXRlLmlzT3BlbiAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAga2V5OiBcIkhcIixcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgIHRvcDogXCIwcHhcIixcbiAgICAgICAgICBsZWZ0OiBcIjBweFwiXG4gICAgICAgIH0sXG4gICAgICAgIHJlZjogdGhpcy5zZXRIZWxwZXJSZWZcbiAgICAgIH0pLCBvdmVybGF5ICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBrZXk6IFwiT1wiLFxuICAgICAgICBjbGFzc05hbWU6IFwicG9wdXAtb3ZlcmxheVwiLFxuICAgICAgICBzdHlsZTogT2JqZWN0LmFzc2lnbih7fSwgb3ZTdHlsZSwgb3ZlcmxheVN0eWxlKSxcbiAgICAgICAgb25DbGljazogY2xvc2VPbkRvY3VtZW50Q2xpY2sgPyB0aGlzLmNsb3NlUG9wdXAgOiB1bmRlZmluZWRcbiAgICAgIH0sIG1vZGFsICYmIHRoaXMucmVuZGVyQ29udGVudCgpKSwgdGhpcy5zdGF0ZS5pc09wZW4gJiYgIW1vZGFsICYmIHRoaXMucmVuZGVyQ29udGVudCgpXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUG9wdXA7XG59KFJlYWN0LlB1cmVDb21wb25lbnQpO1xuXG5fZGVmaW5lUHJvcGVydHkoUG9wdXAsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgY2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBcIiBZb3VyIENvbnRlbnQgSGVyZSAhIVwiKTtcbiAgfSxcbiAgdHJpZ2dlcjogbnVsbCxcbiAgb25PcGVuOiBmdW5jdGlvbiBvbk9wZW4oKSB7fSxcbiAgb25DbG9zZTogZnVuY3Rpb24gb25DbG9zZSgpIHt9LFxuICBkZWZhdWx0T3BlbjogZmFsc2UsXG4gIG9wZW46IGZhbHNlLFxuICBkaXNhYmxlZDogZmFsc2UsXG4gIGNsb3NlT25Eb2N1bWVudENsaWNrOiB0cnVlLFxuICBjbG9zZU9uRXNjYXBlOiB0cnVlLFxuICBvbjogW1wiY2xpY2tcIl0sXG4gIGNvbnRlbnRTdHlsZToge30sXG4gIGFycm93U3R5bGU6IHt9LFxuICBvdmVybGF5U3R5bGU6IHt9LFxuICBjbGFzc05hbWU6IFwiXCIsXG4gIHBvc2l0aW9uOiBcImJvdHRvbSBjZW50ZXJcIixcbiAgbW9kYWw6IGZhbHNlLFxuICBsb2NrU2Nyb2xsOiBmYWxzZSxcbiAgYXJyb3c6IHRydWUsXG4gIG9mZnNldFg6IDAsXG4gIG9mZnNldFk6IDAsXG4gIG1vdXNlRW50ZXJEZWxheTogMTAwLFxuICBtb3VzZUxlYXZlRGVsYXk6IDEwMCxcbiAga2VlcFRvb2x0aXBJbnNpZGU6IGZhbHNlXG59KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICB2YXIgUHJvcFR5cGVzID0gcmVxdWlyZShcInByb3AtdHlwZXNcIik7XG5cbiAgdmFyIFRSSUdHRVJfVFlQRVMgPSBbXCJob3ZlclwiLCBcImNsaWNrXCIsIFwiZm9jdXNcIl07XG4gIFBvcHVwLnByb3BUeXBlcyA9IHtcbiAgICBhcnJvd1N0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGNvbnRlbnRTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvdmVybGF5U3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG1vZGFsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBjbG9zZU9uRG9jdW1lbnRDbGljazogUHJvcFR5cGVzLmJvb2wsXG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIGxvY2tTY3JvbGw6IFByb3BUeXBlcy5ib29sLFxuICAgIG9mZnNldFg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgb2Zmc2V0WTogUHJvcFR5cGVzLm51bWJlcixcbiAgICBtb3VzZUVudGVyRGVsYXk6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgbW91c2VMZWF2ZURlbGF5OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIG9uT3BlbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb3BlbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgZGVmYXVsdE9wZW46IFByb3BUeXBlcy5ib29sLFxuICAgIHRyaWdnZXI6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuZWxlbWVudF0pLFxuICAgIC8vIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50IHdlIGRvbid0IG5lZWQgdGhlIHRyaWdnZXIgRWxlbWVudFxuICAgIG9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub25lT2YoVFJJR0dFUl9UWVBFUyksIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vbmVPZihUUklHR0VSX1RZUEVTKSldKSxcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5lbGVtZW50LCBQcm9wVHlwZXMuc3RyaW5nXSkuaXNSZXF1aXJlZCxcbiAgICBwb3NpdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9uZU9mKFBPU0lUSU9OX1RZUEVTKSwgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9uZU9mKFBPU0lUSU9OX1RZUEVTKSldKSxcbiAgICBrZWVwVG9vbHRpcEluc2lkZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5zdHJpbmddKVxuICB9O1xufVxuXG52YXIgUmVmID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudDIpIHtcbiAgX2luaGVyaXRzKFJlZiwgX1JlYWN0JFB1cmVDb21wb25lbnQyKTtcblxuICBmdW5jdGlvbiBSZWYoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlZik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFJlZikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVmLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHZhciBpbm5lclJlZiA9IHRoaXMucHJvcHMuaW5uZXJSZWY7XG4gICAgICBpZiAoaW5uZXJSZWYpIGlubmVyUmVmKGZpbmRET01Ob2RlKHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgICByZXR1cm4gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlZjtcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCk7XG5cbmV4cG9ydCBkZWZhdWx0IFBvcHVwO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///463\n')},464:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tree\", function() { return Tree; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Treemap\", function() { return Treemap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Cluster\", function() { return Cluster; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Pack\", function() { return Pack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Partition\", function() { return Partition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HierarchyDefaultLink\", function() { return HierarchyDefaultLink; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HierarchyDefaultNode\", function() { return HierarchyDefaultNode; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(93);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _vx_group__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(104);\n/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(265);\n\n\n\n\n\n\nHierarchyDefaultLink.propTypes = {\n  link: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object\n};\n\nfunction HierarchyDefaultLink(_ref) {\n  var link = _ref.link;\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('line', {\n    x1: link.source.x,\n    y1: link.source.y,\n    x2: link.target.x,\n    y2: link.target.y,\n    strokeWidth: 2,\n    stroke: '#999',\n    strokeOpacity: 0.6\n  });\n}\n\nHierarchyDefaultNode.propTypes = {\n  node: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object\n};\n\nfunction HierarchyDefaultNode(_ref) {\n  var node = _ref.node;\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('circle', { cx: node.x, cy: node.y, r: 15, fill: '#21D4FD' });\n}\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nTree.propTypes = {\n  root: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object.isRequired,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  className: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  size: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number),\n  nodeSize: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number),\n  separation: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  linkComponent: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.any,\n  nodeComponent: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.any\n};\n\nfunction Tree(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      className = _ref.className,\n      root = _ref.root,\n      size = _ref.size,\n      nodeSize = _ref.nodeSize,\n      separation = _ref.separation,\n      children = _ref.children,\n      _ref$linkComponent = _ref.linkComponent,\n      linkComponent = _ref$linkComponent === undefined ? HierarchyDefaultLink : _ref$linkComponent,\n      _ref$nodeComponent = _ref.nodeComponent,\n      nodeComponent = _ref$nodeComponent === undefined ? HierarchyDefaultNode : _ref$nodeComponent,\n      restProps = objectWithoutProperties(_ref, ['top', 'left', 'className', 'root', 'size', 'nodeSize', 'separation', 'children', 'linkComponent', 'nodeComponent']);\n\n  var tree$$1 = Object(d3_hierarchy__WEBPACK_IMPORTED_MODULE_4__[\"tree\"])();\n  if (size) tree$$1.size(size);\n  if (nodeSize) tree$$1.nodeSize(nodeSize);\n  if (separation) tree$$1.separation(separation);\n\n  var data = tree$$1(root);\n\n  if (!!children) {\n    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n      _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n      { top: top, left: left, className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-tree', className) },\n      children({ data: data })\n    );\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n    { top: top, left: left, className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-tree', className) },\n    linkComponent && data.links().map(function (link, i) {\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n        _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n        { key: 'tree-link-' + i },\n        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(linkComponent, { link: link })\n      );\n    }),\n    nodeComponent && data.descendants().map(function (node, i) {\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n        _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n        { key: 'tree-node-' + i },\n        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(nodeComponent, { node: node })\n      );\n    })\n  );\n}\n\nTreemap.propTypes = {\n  root: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object.isRequired,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  className: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tile: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  size: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number),\n  round: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  padding: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func]),\n  paddingInner: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func]),\n  paddingOuter: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func]),\n  paddingTop: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func]),\n  paddingRight: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func]),\n  paddingBottom: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func]),\n  paddingLeft: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func]),\n  nodeComponent: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.any\n};\n\nfunction Treemap(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      className = _ref.className,\n      root = _ref.root,\n      tile = _ref.tile,\n      size = _ref.size,\n      round = _ref.round,\n      padding = _ref.padding,\n      paddingInner = _ref.paddingInner,\n      paddingOuter = _ref.paddingOuter,\n      paddingTop = _ref.paddingTop,\n      paddingRight = _ref.paddingRight,\n      paddingBottom = _ref.paddingBottom,\n      paddingLeft = _ref.paddingLeft,\n      children = _ref.children,\n      _ref$nodeComponent = _ref.nodeComponent,\n      nodeComponent = _ref$nodeComponent === undefined ? HierarchyDefaultNode : _ref$nodeComponent,\n      restProps = objectWithoutProperties(_ref, ['top', 'left', 'className', 'root', 'tile', 'size', 'round', 'padding', 'paddingInner', 'paddingOuter', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'children', 'nodeComponent']);\n\n  var treemap$$1 = Object(d3_hierarchy__WEBPACK_IMPORTED_MODULE_4__[\"treemap\"])();\n\n  if (tile) treemap$$1.tile(tile);\n  if (size) treemap$$1.size(size);\n  if (round) treemap$$1.round(round);\n  if (padding) treemap$$1.padding(padding);\n  if (paddingInner) treemap$$1.paddingInner(paddingInner);\n  if (paddingOuter) treemap$$1.paddingOuter(paddingOuter);\n  if (paddingTop) treemap$$1.paddingTop(paddingTop);\n  if (paddingRight) treemap$$1.paddingRight(paddingRight);\n  if (paddingBottom) treemap$$1.paddingBottom(paddingBottom);\n  if (paddingLeft) treemap$$1.paddingLeft(paddingLeft);\n\n  var data = treemap$$1(root);\n\n  if (!!children) {\n    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n      _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n      { top: top, left: left, className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-treemap', className) },\n      children({ data: data })\n    );\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n    { top: top, left: left, className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-treemap', className) },\n    nodeComponent && data.descendants().map(function (node, i) {\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n        _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n        { key: 'treemap-node-' + i },\n        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(nodeComponent, { node: node })\n      );\n    })\n  );\n}\n\nCluster.propTypes = {\n  root: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object.isRequired,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  className: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  size: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number),\n  nodeSize: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number),\n  separation: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  linkComponent: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.any,\n  nodeComponent: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.any\n};\n\nfunction Cluster(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      className = _ref.className,\n      root = _ref.root,\n      size = _ref.size,\n      nodeSize = _ref.nodeSize,\n      separation = _ref.separation,\n      children = _ref.children,\n      _ref$linkComponent = _ref.linkComponent,\n      linkComponent = _ref$linkComponent === undefined ? HierarchyDefaultLink : _ref$linkComponent,\n      _ref$nodeComponent = _ref.nodeComponent,\n      nodeComponent = _ref$nodeComponent === undefined ? HierarchyDefaultNode : _ref$nodeComponent,\n      restProps = objectWithoutProperties(_ref, ['top', 'left', 'className', 'root', 'size', 'nodeSize', 'separation', 'children', 'linkComponent', 'nodeComponent']);\n\n  var cluster$$1 = Object(d3_hierarchy__WEBPACK_IMPORTED_MODULE_4__[\"cluster\"])();\n\n  if (size) cluster$$1.size(size);\n  if (nodeSize) cluster$$1.nodeSize(nodeSize);\n  if (separation) cluster$$1.separation(separation);\n\n  var data = cluster$$1(root);\n\n  if (!!children) {\n    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n      _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n      { top: top, left: left, className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-cluster', className) },\n      children({ data: data })\n    );\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n    { top: top, left: left, className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-cluster', className) },\n    linkComponent && data.links().map(function (link, i) {\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n        _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n        { key: 'cluster-link-' + i },\n        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(linkComponent, { link: link })\n      );\n    }),\n    nodeComponent && data.descendants().map(function (node, i) {\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n        _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n        { key: 'cluster-node-' + i },\n        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(nodeComponent, { node: node })\n      );\n    })\n  );\n}\n\nPack.propTypes = {\n  root: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object.isRequired,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  className: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  radius: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  size: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number),\n  padding: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  nodeComponent: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.any\n};\n\nfunction Pack(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      className = _ref.className,\n      root = _ref.root,\n      radius = _ref.radius,\n      size = _ref.size,\n      padding = _ref.padding,\n      children = _ref.children,\n      _ref$nodeComponent = _ref.nodeComponent,\n      nodeComponent = _ref$nodeComponent === undefined ? HierarchyDefaultNode : _ref$nodeComponent,\n      restProps = objectWithoutProperties(_ref, ['top', 'left', 'className', 'root', 'radius', 'size', 'padding', 'children', 'nodeComponent']);\n\n  var pack$$1 = Object(d3_hierarchy__WEBPACK_IMPORTED_MODULE_4__[\"pack\"])();\n\n  if (size) pack$$1.size(size);\n  if (radius !== undefined) pack$$1.radius(radius);\n  if (padding) pack$$1.padding(padding);\n\n  var data = pack$$1(root);\n\n  if (!!children) {\n    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n      _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n      { top: top, left: left, className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-pack', className) },\n      children({ data: data })\n    );\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n    { top: top, left: left, className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-pack', className) },\n    nodeComponent && data.descendants().map(function (node, i) {\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n        _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n        { key: 'pack-node-' + i },\n        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(nodeComponent, { node: node })\n      );\n    })\n  );\n}\n\nPartition.propTypes = {\n  root: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object.isRequired,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  className: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  size: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number),\n  round: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  padding: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  nodeComponent: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.any\n};\n\nfunction Partition(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      className = _ref.className,\n      root = _ref.root,\n      size = _ref.size,\n      round = _ref.round,\n      padding = _ref.padding,\n      children = _ref.children,\n      _ref$nodeComponent = _ref.nodeComponent,\n      nodeComponent = _ref$nodeComponent === undefined ? HierarchyDefaultNode : _ref$nodeComponent,\n      restProps = objectWithoutProperties(_ref, ['top', 'left', 'className', 'root', 'size', 'round', 'padding', 'children', 'nodeComponent']);\n\n  var partition$$1 = Object(d3_hierarchy__WEBPACK_IMPORTED_MODULE_4__[\"partition\"])();\n  if (size) partition$$1.size(size);\n  if (round) partition$$1.round(round);\n  if (padding) partition$$1.padding(padding);\n\n  var data = partition$$1(root);\n\n  if (!!children) {\n    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n      _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n      { top: top, left: left, className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-partition', className) },\n      children({ data: data })\n    );\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n    { top: top, left: left, className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-partition', className) },\n    nodeComponent && data.descendants().map(function (node, i) {\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n        _vx_group__WEBPACK_IMPORTED_MODULE_3__[\"Group\"],\n        { key: 'partition-node-' + i },\n        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(nodeComponent, { node: node })\n      );\n    })\n  );\n}\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ4L2hpZXJhcmNoeS9kaXN0L3Z4LWhpZXJhcmNoeS5lcy5qcz9kYmIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTBCO0FBQ1M7QUFDUDtBQUNNO0FBQ3FDOztBQUV2RTtBQUNBLFFBQVEsaURBQVM7QUFDakI7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLDRDQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxRQUFRLGlEQUFTO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUEsU0FBUyw0Q0FBSywwQkFBMEIsaURBQWlEO0FBQ3pGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxpREFBUztBQUNqQixZQUFZLGlEQUFTO0FBQ3JCLE9BQU8saURBQVM7QUFDaEIsUUFBUSxpREFBUztBQUNqQixhQUFhLGlEQUFTO0FBQ3RCLFFBQVEsaURBQVMsU0FBUyxpREFBUztBQUNuQyxZQUFZLGlEQUFTLFNBQVMsaURBQVM7QUFDdkMsY0FBYyxpREFBUztBQUN2QixpQkFBaUIsaURBQVM7QUFDMUIsaUJBQWlCLGlEQUFTO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHlEQUFJO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsNENBQUs7QUFDaEIsTUFBTSwrQ0FBSztBQUNYLE9BQU8sa0NBQWtDLGlEQUFFLHdCQUF3QjtBQUNuRSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBOztBQUVBLFNBQVMsNENBQUs7QUFDZCxJQUFJ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QixNQUFNLCtDQUFLO0FBQ1gsT0FBTyxrQ0FBa0MsaURBQUUsNkJBQTZCO0FBQ3hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7O0FBRUEsU0FBUyw0Q0FBSztBQUNkLElBQUksK0NBQUs7QUFDVCxLQUFLLGtDQUFrQyxpREFBRSw2QkFBNkI7QUFDdEU7QUFDQSxhQUFhLDRDQUFLO0FBQ2xCLFFBQVEsK0NBQUs7QUFDYixTQUFTLDZCQUE2QjtBQUN0QyxRQUFRLDRDQUFLLCtCQUErQixhQUFhO0FBQ3pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRStGIiwiZmlsZSI6IjQ2NC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgR3JvdXAgfSBmcm9tICdAdngvZ3JvdXAnO1xuaW1wb3J0IHsgdHJlZSwgdHJlZW1hcCwgY2x1c3RlciwgcGFjaywgcGFydGl0aW9uIH0gZnJvbSAnZDMtaGllcmFyY2h5JztcblxuSGllcmFyY2h5RGVmYXVsdExpbmsucHJvcFR5cGVzID0ge1xuICBsaW5rOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuXG5mdW5jdGlvbiBIaWVyYXJjaHlEZWZhdWx0TGluayhfcmVmKSB7XG4gIHZhciBsaW5rID0gX3JlZi5saW5rO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdsaW5lJywge1xuICAgIHgxOiBsaW5rLnNvdXJjZS54LFxuICAgIHkxOiBsaW5rLnNvdXJjZS55LFxuICAgIHgyOiBsaW5rLnRhcmdldC54LFxuICAgIHkyOiBsaW5rLnRhcmdldC55LFxuICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgIHN0cm9rZTogJyM5OTknLFxuICAgIHN0cm9rZU9wYWNpdHk6IDAuNlxuICB9KTtcbn1cblxuSGllcmFyY2h5RGVmYXVsdE5vZGUucHJvcFR5cGVzID0ge1xuICBub2RlOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuXG5mdW5jdGlvbiBIaWVyYXJjaHlEZWZhdWx0Tm9kZShfcmVmKSB7XG4gIHZhciBub2RlID0gX3JlZi5ub2RlO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdjaXJjbGUnLCB7IGN4OiBub2RlLngsIGN5OiBub2RlLnksIHI6IDE1LCBmaWxsOiAnIzIxRDRGRCcgfSk7XG59XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuVHJlZS5wcm9wVHlwZXMgPSB7XG4gIHJvb3Q6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jLFxuICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc2l6ZTogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlciksXG4gIG5vZGVTaXplOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKSxcbiAgc2VwYXJhdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGxpbmtDb21wb25lbnQ6IFByb3BUeXBlcy5hbnksXG4gIG5vZGVDb21wb25lbnQ6IFByb3BUeXBlcy5hbnlcbn07XG5cbmZ1bmN0aW9uIFRyZWUoX3JlZikge1xuICB2YXIgdG9wID0gX3JlZi50b3AsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICByb290ID0gX3JlZi5yb290LFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIG5vZGVTaXplID0gX3JlZi5ub2RlU2l6ZSxcbiAgICAgIHNlcGFyYXRpb24gPSBfcmVmLnNlcGFyYXRpb24sXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBfcmVmJGxpbmtDb21wb25lbnQgPSBfcmVmLmxpbmtDb21wb25lbnQsXG4gICAgICBsaW5rQ29tcG9uZW50ID0gX3JlZiRsaW5rQ29tcG9uZW50ID09PSB1bmRlZmluZWQgPyBIaWVyYXJjaHlEZWZhdWx0TGluayA6IF9yZWYkbGlua0NvbXBvbmVudCxcbiAgICAgIF9yZWYkbm9kZUNvbXBvbmVudCA9IF9yZWYubm9kZUNvbXBvbmVudCxcbiAgICAgIG5vZGVDb21wb25lbnQgPSBfcmVmJG5vZGVDb21wb25lbnQgPT09IHVuZGVmaW5lZCA/IEhpZXJhcmNoeURlZmF1bHROb2RlIDogX3JlZiRub2RlQ29tcG9uZW50LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWyd0b3AnLCAnbGVmdCcsICdjbGFzc05hbWUnLCAncm9vdCcsICdzaXplJywgJ25vZGVTaXplJywgJ3NlcGFyYXRpb24nLCAnY2hpbGRyZW4nLCAnbGlua0NvbXBvbmVudCcsICdub2RlQ29tcG9uZW50J10pO1xuXG4gIHZhciB0cmVlJCQxID0gdHJlZSgpO1xuICBpZiAoc2l6ZSkgdHJlZSQkMS5zaXplKHNpemUpO1xuICBpZiAobm9kZVNpemUpIHRyZWUkJDEubm9kZVNpemUobm9kZVNpemUpO1xuICBpZiAoc2VwYXJhdGlvbikgdHJlZSQkMS5zZXBhcmF0aW9uKHNlcGFyYXRpb24pO1xuXG4gIHZhciBkYXRhID0gdHJlZSQkMShyb290KTtcblxuICBpZiAoISFjaGlsZHJlbikge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgR3JvdXAsXG4gICAgICB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0LCBjbGFzc05hbWU6IGN4KCd2eC10cmVlJywgY2xhc3NOYW1lKSB9LFxuICAgICAgY2hpbGRyZW4oeyBkYXRhOiBkYXRhIH0pXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQsIGNsYXNzTmFtZTogY3goJ3Z4LXRyZWUnLCBjbGFzc05hbWUpIH0sXG4gICAgbGlua0NvbXBvbmVudCAmJiBkYXRhLmxpbmtzKCkubWFwKGZ1bmN0aW9uIChsaW5rLCBpKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgR3JvdXAsXG4gICAgICAgIHsga2V5OiAndHJlZS1saW5rLScgKyBpIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQobGlua0NvbXBvbmVudCwgeyBsaW5rOiBsaW5rIH0pXG4gICAgICApO1xuICAgIH0pLFxuICAgIG5vZGVDb21wb25lbnQgJiYgZGF0YS5kZXNjZW5kYW50cygpLm1hcChmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEdyb3VwLFxuICAgICAgICB7IGtleTogJ3RyZWUtbm9kZS0nICsgaSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KG5vZGVDb21wb25lbnQsIHsgbm9kZTogbm9kZSB9KVxuICAgICAgKTtcbiAgICB9KVxuICApO1xufVxuXG5UcmVlbWFwLnByb3BUeXBlcyA9IHtcbiAgcm9vdDogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmMsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0aWxlOiBQcm9wVHlwZXMuZnVuYyxcbiAgc2l6ZTogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlciksXG4gIHJvdW5kOiBQcm9wVHlwZXMuYm9vbCxcbiAgcGFkZGluZzogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgcGFkZGluZ0lubmVyOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuZnVuY10pLFxuICBwYWRkaW5nT3V0ZXI6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5mdW5jXSksXG4gIHBhZGRpbmdUb3A6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5mdW5jXSksXG4gIHBhZGRpbmdSaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgcGFkZGluZ0JvdHRvbTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgcGFkZGluZ0xlZnQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5mdW5jXSksXG4gIG5vZGVDb21wb25lbnQ6IFByb3BUeXBlcy5hbnlcbn07XG5cbmZ1bmN0aW9uIFRyZWVtYXAoX3JlZikge1xuICB2YXIgdG9wID0gX3JlZi50b3AsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICByb290ID0gX3JlZi5yb290LFxuICAgICAgdGlsZSA9IF9yZWYudGlsZSxcbiAgICAgIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICByb3VuZCA9IF9yZWYucm91bmQsXG4gICAgICBwYWRkaW5nID0gX3JlZi5wYWRkaW5nLFxuICAgICAgcGFkZGluZ0lubmVyID0gX3JlZi5wYWRkaW5nSW5uZXIsXG4gICAgICBwYWRkaW5nT3V0ZXIgPSBfcmVmLnBhZGRpbmdPdXRlcixcbiAgICAgIHBhZGRpbmdUb3AgPSBfcmVmLnBhZGRpbmdUb3AsXG4gICAgICBwYWRkaW5nUmlnaHQgPSBfcmVmLnBhZGRpbmdSaWdodCxcbiAgICAgIHBhZGRpbmdCb3R0b20gPSBfcmVmLnBhZGRpbmdCb3R0b20sXG4gICAgICBwYWRkaW5nTGVmdCA9IF9yZWYucGFkZGluZ0xlZnQsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBfcmVmJG5vZGVDb21wb25lbnQgPSBfcmVmLm5vZGVDb21wb25lbnQsXG4gICAgICBub2RlQ29tcG9uZW50ID0gX3JlZiRub2RlQ29tcG9uZW50ID09PSB1bmRlZmluZWQgPyBIaWVyYXJjaHlEZWZhdWx0Tm9kZSA6IF9yZWYkbm9kZUNvbXBvbmVudCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsndG9wJywgJ2xlZnQnLCAnY2xhc3NOYW1lJywgJ3Jvb3QnLCAndGlsZScsICdzaXplJywgJ3JvdW5kJywgJ3BhZGRpbmcnLCAncGFkZGluZ0lubmVyJywgJ3BhZGRpbmdPdXRlcicsICdwYWRkaW5nVG9wJywgJ3BhZGRpbmdSaWdodCcsICdwYWRkaW5nQm90dG9tJywgJ3BhZGRpbmdMZWZ0JywgJ2NoaWxkcmVuJywgJ25vZGVDb21wb25lbnQnXSk7XG5cbiAgdmFyIHRyZWVtYXAkJDEgPSB0cmVlbWFwKCk7XG5cbiAgaWYgKHRpbGUpIHRyZWVtYXAkJDEudGlsZSh0aWxlKTtcbiAgaWYgKHNpemUpIHRyZWVtYXAkJDEuc2l6ZShzaXplKTtcbiAgaWYgKHJvdW5kKSB0cmVlbWFwJCQxLnJvdW5kKHJvdW5kKTtcbiAgaWYgKHBhZGRpbmcpIHRyZWVtYXAkJDEucGFkZGluZyhwYWRkaW5nKTtcbiAgaWYgKHBhZGRpbmdJbm5lcikgdHJlZW1hcCQkMS5wYWRkaW5nSW5uZXIocGFkZGluZ0lubmVyKTtcbiAgaWYgKHBhZGRpbmdPdXRlcikgdHJlZW1hcCQkMS5wYWRkaW5nT3V0ZXIocGFkZGluZ091dGVyKTtcbiAgaWYgKHBhZGRpbmdUb3ApIHRyZWVtYXAkJDEucGFkZGluZ1RvcChwYWRkaW5nVG9wKTtcbiAgaWYgKHBhZGRpbmdSaWdodCkgdHJlZW1hcCQkMS5wYWRkaW5nUmlnaHQocGFkZGluZ1JpZ2h0KTtcbiAgaWYgKHBhZGRpbmdCb3R0b20pIHRyZWVtYXAkJDEucGFkZGluZ0JvdHRvbShwYWRkaW5nQm90dG9tKTtcbiAgaWYgKHBhZGRpbmdMZWZ0KSB0cmVlbWFwJCQxLnBhZGRpbmdMZWZ0KHBhZGRpbmdMZWZ0KTtcblxuICB2YXIgZGF0YSA9IHRyZWVtYXAkJDEocm9vdCk7XG5cbiAgaWYgKCEhY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIEdyb3VwLFxuICAgICAgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCwgY2xhc3NOYW1lOiBjeCgndngtdHJlZW1hcCcsIGNsYXNzTmFtZSkgfSxcbiAgICAgIGNoaWxkcmVuKHsgZGF0YTogZGF0YSB9KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBHcm91cCxcbiAgICB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0LCBjbGFzc05hbWU6IGN4KCd2eC10cmVlbWFwJywgY2xhc3NOYW1lKSB9LFxuICAgIG5vZGVDb21wb25lbnQgJiYgZGF0YS5kZXNjZW5kYW50cygpLm1hcChmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEdyb3VwLFxuICAgICAgICB7IGtleTogJ3RyZWVtYXAtbm9kZS0nICsgaSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KG5vZGVDb21wb25lbnQsIHsgbm9kZTogbm9kZSB9KVxuICAgICAgKTtcbiAgICB9KVxuICApO1xufVxuXG5DbHVzdGVyLnByb3BUeXBlcyA9IHtcbiAgcm9vdDogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmMsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzaXplOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKSxcbiAgbm9kZVNpemU6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5udW1iZXIpLFxuICBzZXBhcmF0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgbGlua0NvbXBvbmVudDogUHJvcFR5cGVzLmFueSxcbiAgbm9kZUNvbXBvbmVudDogUHJvcFR5cGVzLmFueVxufTtcblxuZnVuY3Rpb24gQ2x1c3RlcihfcmVmKSB7XG4gIHZhciB0b3AgPSBfcmVmLnRvcCxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICBzaXplID0gX3JlZi5zaXplLFxuICAgICAgbm9kZVNpemUgPSBfcmVmLm5vZGVTaXplLFxuICAgICAgc2VwYXJhdGlvbiA9IF9yZWYuc2VwYXJhdGlvbixcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIF9yZWYkbGlua0NvbXBvbmVudCA9IF9yZWYubGlua0NvbXBvbmVudCxcbiAgICAgIGxpbmtDb21wb25lbnQgPSBfcmVmJGxpbmtDb21wb25lbnQgPT09IHVuZGVmaW5lZCA/IEhpZXJhcmNoeURlZmF1bHRMaW5rIDogX3JlZiRsaW5rQ29tcG9uZW50LFxuICAgICAgX3JlZiRub2RlQ29tcG9uZW50ID0gX3JlZi5ub2RlQ29tcG9uZW50LFxuICAgICAgbm9kZUNvbXBvbmVudCA9IF9yZWYkbm9kZUNvbXBvbmVudCA9PT0gdW5kZWZpbmVkID8gSGllcmFyY2h5RGVmYXVsdE5vZGUgOiBfcmVmJG5vZGVDb21wb25lbnQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3RvcCcsICdsZWZ0JywgJ2NsYXNzTmFtZScsICdyb290JywgJ3NpemUnLCAnbm9kZVNpemUnLCAnc2VwYXJhdGlvbicsICdjaGlsZHJlbicsICdsaW5rQ29tcG9uZW50JywgJ25vZGVDb21wb25lbnQnXSk7XG5cbiAgdmFyIGNsdXN0ZXIkJDEgPSBjbHVzdGVyKCk7XG5cbiAgaWYgKHNpemUpIGNsdXN0ZXIkJDEuc2l6ZShzaXplKTtcbiAgaWYgKG5vZGVTaXplKSBjbHVzdGVyJCQxLm5vZGVTaXplKG5vZGVTaXplKTtcbiAgaWYgKHNlcGFyYXRpb24pIGNsdXN0ZXIkJDEuc2VwYXJhdGlvbihzZXBhcmF0aW9uKTtcblxuICB2YXIgZGF0YSA9IGNsdXN0ZXIkJDEocm9vdCk7XG5cbiAgaWYgKCEhY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIEdyb3VwLFxuICAgICAgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCwgY2xhc3NOYW1lOiBjeCgndngtY2x1c3RlcicsIGNsYXNzTmFtZSkgfSxcbiAgICAgIGNoaWxkcmVuKHsgZGF0YTogZGF0YSB9KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBHcm91cCxcbiAgICB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0LCBjbGFzc05hbWU6IGN4KCd2eC1jbHVzdGVyJywgY2xhc3NOYW1lKSB9LFxuICAgIGxpbmtDb21wb25lbnQgJiYgZGF0YS5saW5rcygpLm1hcChmdW5jdGlvbiAobGluaywgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEdyb3VwLFxuICAgICAgICB7IGtleTogJ2NsdXN0ZXItbGluay0nICsgaSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KGxpbmtDb21wb25lbnQsIHsgbGluazogbGluayB9KVxuICAgICAgKTtcbiAgICB9KSxcbiAgICBub2RlQ29tcG9uZW50ICYmIGRhdGEuZGVzY2VuZGFudHMoKS5tYXAoZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBHcm91cCxcbiAgICAgICAgeyBrZXk6ICdjbHVzdGVyLW5vZGUtJyArIGkgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChub2RlQ29tcG9uZW50LCB7IG5vZGU6IG5vZGUgfSlcbiAgICAgICk7XG4gICAgfSlcbiAgKTtcbn1cblxuUGFjay5wcm9wVHlwZXMgPSB7XG4gIHJvb3Q6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jLFxuICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgcmFkaXVzOiBQcm9wVHlwZXMuZnVuYyxcbiAgc2l6ZTogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlciksXG4gIHBhZGRpbmc6IFByb3BUeXBlcy5udW1iZXIsXG4gIG5vZGVDb21wb25lbnQ6IFByb3BUeXBlcy5hbnlcbn07XG5cbmZ1bmN0aW9uIFBhY2soX3JlZikge1xuICB2YXIgdG9wID0gX3JlZi50b3AsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICByb290ID0gX3JlZi5yb290LFxuICAgICAgcmFkaXVzID0gX3JlZi5yYWRpdXMsXG4gICAgICBzaXplID0gX3JlZi5zaXplLFxuICAgICAgcGFkZGluZyA9IF9yZWYucGFkZGluZyxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIF9yZWYkbm9kZUNvbXBvbmVudCA9IF9yZWYubm9kZUNvbXBvbmVudCxcbiAgICAgIG5vZGVDb21wb25lbnQgPSBfcmVmJG5vZGVDb21wb25lbnQgPT09IHVuZGVmaW5lZCA/IEhpZXJhcmNoeURlZmF1bHROb2RlIDogX3JlZiRub2RlQ29tcG9uZW50LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWyd0b3AnLCAnbGVmdCcsICdjbGFzc05hbWUnLCAncm9vdCcsICdyYWRpdXMnLCAnc2l6ZScsICdwYWRkaW5nJywgJ2NoaWxkcmVuJywgJ25vZGVDb21wb25lbnQnXSk7XG5cbiAgdmFyIHBhY2skJDEgPSBwYWNrKCk7XG5cbiAgaWYgKHNpemUpIHBhY2skJDEuc2l6ZShzaXplKTtcbiAgaWYgKHJhZGl1cyAhPT0gdW5kZWZpbmVkKSBwYWNrJCQxLnJhZGl1cyhyYWRpdXMpO1xuICBpZiAocGFkZGluZykgcGFjayQkMS5wYWRkaW5nKHBhZGRpbmcpO1xuXG4gIHZhciBkYXRhID0gcGFjayQkMShyb290KTtcblxuICBpZiAoISFjaGlsZHJlbikge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgR3JvdXAsXG4gICAgICB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0LCBjbGFzc05hbWU6IGN4KCd2eC1wYWNrJywgY2xhc3NOYW1lKSB9LFxuICAgICAgY2hpbGRyZW4oeyBkYXRhOiBkYXRhIH0pXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQsIGNsYXNzTmFtZTogY3goJ3Z4LXBhY2snLCBjbGFzc05hbWUpIH0sXG4gICAgbm9kZUNvbXBvbmVudCAmJiBkYXRhLmRlc2NlbmRhbnRzKCkubWFwKGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgR3JvdXAsXG4gICAgICAgIHsga2V5OiAncGFjay1ub2RlLScgKyBpIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQobm9kZUNvbXBvbmVudCwgeyBub2RlOiBub2RlIH0pXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cblBhcnRpdGlvbi5wcm9wVHlwZXMgPSB7XG4gIHJvb3Q6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jLFxuICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc2l6ZTogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlciksXG4gIHJvdW5kOiBQcm9wVHlwZXMuYm9vbCxcbiAgcGFkZGluZzogUHJvcFR5cGVzLm51bWJlcixcbiAgbm9kZUNvbXBvbmVudDogUHJvcFR5cGVzLmFueVxufTtcblxuZnVuY3Rpb24gUGFydGl0aW9uKF9yZWYpIHtcbiAgdmFyIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICByb3VuZCA9IF9yZWYucm91bmQsXG4gICAgICBwYWRkaW5nID0gX3JlZi5wYWRkaW5nLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgX3JlZiRub2RlQ29tcG9uZW50ID0gX3JlZi5ub2RlQ29tcG9uZW50LFxuICAgICAgbm9kZUNvbXBvbmVudCA9IF9yZWYkbm9kZUNvbXBvbmVudCA9PT0gdW5kZWZpbmVkID8gSGllcmFyY2h5RGVmYXVsdE5vZGUgOiBfcmVmJG5vZGVDb21wb25lbnQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3RvcCcsICdsZWZ0JywgJ2NsYXNzTmFtZScsICdyb290JywgJ3NpemUnLCAncm91bmQnLCAncGFkZGluZycsICdjaGlsZHJlbicsICdub2RlQ29tcG9uZW50J10pO1xuXG4gIHZhciBwYXJ0aXRpb24kJDEgPSBwYXJ0aXRpb24oKTtcbiAgaWYgKHNpemUpIHBhcnRpdGlvbiQkMS5zaXplKHNpemUpO1xuICBpZiAocm91bmQpIHBhcnRpdGlvbiQkMS5yb3VuZChyb3VuZCk7XG4gIGlmIChwYWRkaW5nKSBwYXJ0aXRpb24kJDEucGFkZGluZyhwYWRkaW5nKTtcblxuICB2YXIgZGF0YSA9IHBhcnRpdGlvbiQkMShyb290KTtcblxuICBpZiAoISFjaGlsZHJlbikge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgR3JvdXAsXG4gICAgICB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0LCBjbGFzc05hbWU6IGN4KCd2eC1wYXJ0aXRpb24nLCBjbGFzc05hbWUpIH0sXG4gICAgICBjaGlsZHJlbih7IGRhdGE6IGRhdGEgfSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCwgY2xhc3NOYW1lOiBjeCgndngtcGFydGl0aW9uJywgY2xhc3NOYW1lKSB9LFxuICAgIG5vZGVDb21wb25lbnQgJiYgZGF0YS5kZXNjZW5kYW50cygpLm1hcChmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEdyb3VwLFxuICAgICAgICB7IGtleTogJ3BhcnRpdGlvbi1ub2RlLScgKyBpIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQobm9kZUNvbXBvbmVudCwgeyBub2RlOiBub2RlIH0pXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cbmV4cG9ydCB7IFRyZWUsIFRyZWVtYXAsIENsdXN0ZXIsIFBhY2ssIFBhcnRpdGlvbiwgSGllcmFyY2h5RGVmYXVsdExpbmssIEhpZXJhcmNoeURlZmF1bHROb2RlIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///464\n")},465:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearGradient\", function() { return LinearGradient; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RadialGradient\", function() { return RadialGradient; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GradientDarkgreenGreen\", function() { return DarkgreenGreen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GradientLightgreenGreen\", function() { return LightgreenGreen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GradientOrangeRed\", function() { return OrangeRed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GradientPinkBlue\", function() { return PinkBlue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GradientPinkRed\", function() { return PinkRed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GradientPurpleOrange\", function() { return PurpleOrange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GradientPurpleRed\", function() { return PurpleRed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GradientPurpleTeal\", function() { return PurpleTeal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GradientSteelPurple\", function() { return SteelPurple; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GradientTealBlue\", function() { return TealBlue; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nLinearGradient.propTypes = {\n  id: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,\n  from: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  to: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  x1: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  y1: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  y2: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  fromOffset: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  fromOpacity: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  toOffset: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  toOpacity: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  rotate: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number]),\n  transform: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string\n};\n\nfunction LinearGradient(_ref) {\n  var children = _ref.children,\n      id = _ref.id,\n      from = _ref.from,\n      to = _ref.to,\n      x1 = _ref.x1,\n      y1 = _ref.y1,\n      x2 = _ref.x2,\n      y2 = _ref.y2,\n      _ref$fromOffset = _ref.fromOffset,\n      fromOffset = _ref$fromOffset === undefined ? '0%' : _ref$fromOffset,\n      _ref$fromOpacity = _ref.fromOpacity,\n      fromOpacity = _ref$fromOpacity === undefined ? 1 : _ref$fromOpacity,\n      _ref$toOffset = _ref.toOffset,\n      toOffset = _ref$toOffset === undefined ? '100%' : _ref$toOffset,\n      _ref$toOpacity = _ref.toOpacity,\n      toOpacity = _ref$toOpacity === undefined ? 1 : _ref$toOpacity,\n      rotate = _ref.rotate,\n      transform = _ref.transform,\n      _ref$vertical = _ref.vertical,\n      vertical = _ref$vertical === undefined ? true : _ref$vertical,\n      restProps = objectWithoutProperties(_ref, ['children', 'id', 'from', 'to', 'x1', 'y1', 'x2', 'y2', 'fromOffset', 'fromOpacity', 'toOffset', 'toOpacity', 'rotate', 'transform', 'vertical']);\n\n  if (vertical && !x1 && !x2 && !y1 && !y2) {\n    x1 = '0';\n    x2 = '0';\n    y1 = '0';\n    y2 = '1';\n  }\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    'defs',\n    null,\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n      'linearGradient',\n      _extends({\n        id: id,\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        gradientTransform: rotate ? 'rotate(' + rotate + ')' : transform\n      }, restProps),\n      !!children && children,\n      !children && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('stop', { offset: fromOffset, stopColor: from, stopOpacity: fromOpacity }),\n      !children && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('stop', { offset: toOffset, stopColor: to, stopOpacity: toOpacity })\n    )\n  );\n}\n\nRadialGradient.propTypes = {\n  id: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,\n  from: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  to: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  fromOffset: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  fromOpacity: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  toOffset: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  toOpacity: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  rotate: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number]),\n  transform: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string\n};\n\nfunction RadialGradient(_ref) {\n  var children = _ref.children,\n      id = _ref.id,\n      from = _ref.from,\n      to = _ref.to,\n      _ref$fromOffset = _ref.fromOffset,\n      fromOffset = _ref$fromOffset === undefined ? '0%' : _ref$fromOffset,\n      _ref$fromOpacity = _ref.fromOpacity,\n      fromOpacity = _ref$fromOpacity === undefined ? 1 : _ref$fromOpacity,\n      _ref$toOffset = _ref.toOffset,\n      toOffset = _ref$toOffset === undefined ? '100%' : _ref$toOffset,\n      _ref$toOpacity = _ref.toOpacity,\n      toOpacity = _ref$toOpacity === undefined ? 1 : _ref$toOpacity,\n      rotate = _ref.rotate,\n      transform = _ref.transform,\n      restProps = objectWithoutProperties(_ref, ['children', 'id', 'from', 'to', 'fromOffset', 'fromOpacity', 'toOffset', 'toOpacity', 'rotate', 'transform']);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    'defs',\n    null,\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n      'radialGradient',\n      _extends({\n        id: id,\n        gradientTransform: rotate ? 'rotate(' + rotate + ')' : transform\n      }, restProps),\n      !!children && children,\n      !children && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('stop', { offset: fromOffset, stopColor: from, stopOpacity: fromOpacity }),\n      !children && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('stop', { offset: toOffset, stopColor: to, stopOpacity: toOpacity })\n    )\n  );\n}\n\nvar DarkgreenGreen = (function (props) {\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(LinearGradient, _extends({ from: '#184E86', to: '#57CA85' }, props));\n});\n\nvar LightgreenGreen = (function (props) {\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(LinearGradient, _extends({ from: '#42E695', to: '#3BB2B8' }, props));\n});\n\nvar OrangeRed = (function (props) {\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(LinearGradient, _extends({ from: '#FCE38A', to: '#F38181' }, props));\n});\n\nvar PinkBlue = (function (props) {\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(LinearGradient, _extends({ from: '#F02FC2', to: '#6094EA' }, props));\n});\n\nvar PinkRed = (function (props) {\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(LinearGradient, _extends({ from: '#F54EA2', to: '#FF7676' }, props));\n});\n\nvar PurpleOrange = (function (props) {\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(LinearGradient, _extends({ from: '#7117EA', to: '#EA6060' }, props));\n});\n\nvar PurpleRed = (function (props) {\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(LinearGradient, _extends({ from: '#622774', to: '#C53364' }, props));\n});\n\nvar PurpleTeal = (function (props) {\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(LinearGradient, _extends({ from: '#5B247A', to: '#1BCEDF' }, props));\n});\n\nvar SteelPurple = (function (props) {\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(LinearGradient, _extends({ from: '#65799B', to: '#5E2563' }, props));\n});\n\nvar TealBlue = (function (props) {\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(LinearGradient, _extends({ from: '#17EAD9', to: '#6078EA' }, props));\n});\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ4L2dyYWRpZW50L2Rpc3QvdngtZ3JhZGllbnQuZXMuanM/ZWE3OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTBCO0FBQ1M7O0FBRW5DO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0saURBQVM7QUFDZixRQUFRLGlEQUFTO0FBQ2pCLE1BQU0saURBQVM7QUFDZixNQUFNLGlEQUFTO0FBQ2YsTUFBTSxpREFBUztBQUNmLE1BQU0saURBQVM7QUFDZixjQUFjLGlEQUFTO0FBQ3ZCLGVBQWUsaURBQVM7QUFDeEIsWUFBWSxpREFBUztBQUNyQixhQUFhLGlEQUFTO0FBQ3RCLFVBQVUsaURBQVMsWUFBWSxpREFBUyxTQUFTLGlEQUFTO0FBQzFELGFBQWEsaURBQVM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0Q0FBSztBQUNkO0FBQ0E7QUFDQSxJQUFJLDRDQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG1CQUFtQiw0Q0FBSyx3QkFBd0IsZ0VBQWdFO0FBQ2hILG1CQUFtQiw0Q0FBSyx3QkFBd0IsMERBQTBEO0FBQzFHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0saURBQVM7QUFDZixRQUFRLGlEQUFTO0FBQ2pCLE1BQU0saURBQVM7QUFDZixjQUFjLGlEQUFTO0FBQ3ZCLGVBQWUsaURBQVM7QUFDeEIsWUFBWSxpREFBUztBQUNyQixhQUFhLGlEQUFTO0FBQ3RCLFVBQVUsaURBQVMsWUFBWSxpREFBUyxTQUFTLGlEQUFTO0FBQzFELGFBQWEsaURBQVM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyw0Q0FBSztBQUNkO0FBQ0E7QUFDQSxJQUFJLDRDQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxtQkFBbUIsNENBQUssd0JBQXdCLGdFQUFnRTtBQUNoSCxtQkFBbUIsNENBQUssd0JBQXdCLDBEQUEwRDtBQUMxRztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLDRDQUFLLHlDQUF5QyxpQ0FBaUM7QUFDeEYsQ0FBQzs7QUFFRDtBQUNBLFNBQVMsNENBQUsseUNBQXlDLGlDQUFpQztBQUN4RixDQUFDOztBQUVEO0FBQ0EsU0FBUyw0Q0FBSyx5Q0FBeUMsaUNBQWlDO0FBQ3hGLENBQUM7O0FBRUQ7QUFDQSxTQUFTLDRDQUFLLHlDQUF5QyxpQ0FBaUM7QUFDeEYsQ0FBQzs7QUFFRDtBQUNBLFNBQVMsNENBQUsseUNBQXlDLGlDQUFpQztBQUN4RixDQUFDOztBQUVEO0FBQ0EsU0FBUyw0Q0FBSyx5Q0FBeUMsaUNBQWlDO0FBQ3hGLENBQUM7O0FBRUQ7QUFDQSxTQUFTLDRDQUFLLHlDQUF5QyxpQ0FBaUM7QUFDeEYsQ0FBQzs7QUFFRDtBQUNBLFNBQVMsNENBQUsseUNBQXlDLGlDQUFpQztBQUN4RixDQUFDOztBQUVEO0FBQ0EsU0FBUyw0Q0FBSyx5Q0FBeUMsaUNBQWlDO0FBQ3hGLENBQUM7O0FBRUQ7QUFDQSxTQUFTLDRDQUFLLHlDQUF5QyxpQ0FBaUM7QUFDeEYsQ0FBQzs7QUFFbVkiLCJmaWxlIjoiNDY1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbkxpbmVhckdyYWRpZW50LnByb3BUeXBlcyA9IHtcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgZnJvbTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG86IFByb3BUeXBlcy5zdHJpbmcsXG4gIHgxOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB5MTogUHJvcFR5cGVzLnN0cmluZyxcbiAgeTI6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGZyb21PZmZzZXQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGZyb21PcGFjaXR5OiBQcm9wVHlwZXMubnVtYmVyLFxuICB0b09mZnNldDogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG9PcGFjaXR5OiBQcm9wVHlwZXMubnVtYmVyLFxuICByb3RhdGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgdHJhbnNmb3JtOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5mdW5jdGlvbiBMaW5lYXJHcmFkaWVudChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBpZCA9IF9yZWYuaWQsXG4gICAgICBmcm9tID0gX3JlZi5mcm9tLFxuICAgICAgdG8gPSBfcmVmLnRvLFxuICAgICAgeDEgPSBfcmVmLngxLFxuICAgICAgeTEgPSBfcmVmLnkxLFxuICAgICAgeDIgPSBfcmVmLngyLFxuICAgICAgeTIgPSBfcmVmLnkyLFxuICAgICAgX3JlZiRmcm9tT2Zmc2V0ID0gX3JlZi5mcm9tT2Zmc2V0LFxuICAgICAgZnJvbU9mZnNldCA9IF9yZWYkZnJvbU9mZnNldCA9PT0gdW5kZWZpbmVkID8gJzAlJyA6IF9yZWYkZnJvbU9mZnNldCxcbiAgICAgIF9yZWYkZnJvbU9wYWNpdHkgPSBfcmVmLmZyb21PcGFjaXR5LFxuICAgICAgZnJvbU9wYWNpdHkgPSBfcmVmJGZyb21PcGFjaXR5ID09PSB1bmRlZmluZWQgPyAxIDogX3JlZiRmcm9tT3BhY2l0eSxcbiAgICAgIF9yZWYkdG9PZmZzZXQgPSBfcmVmLnRvT2Zmc2V0LFxuICAgICAgdG9PZmZzZXQgPSBfcmVmJHRvT2Zmc2V0ID09PSB1bmRlZmluZWQgPyAnMTAwJScgOiBfcmVmJHRvT2Zmc2V0LFxuICAgICAgX3JlZiR0b09wYWNpdHkgPSBfcmVmLnRvT3BhY2l0eSxcbiAgICAgIHRvT3BhY2l0eSA9IF9yZWYkdG9PcGFjaXR5ID09PSB1bmRlZmluZWQgPyAxIDogX3JlZiR0b09wYWNpdHksXG4gICAgICByb3RhdGUgPSBfcmVmLnJvdGF0ZSxcbiAgICAgIHRyYW5zZm9ybSA9IF9yZWYudHJhbnNmb3JtLFxuICAgICAgX3JlZiR2ZXJ0aWNhbCA9IF9yZWYudmVydGljYWwsXG4gICAgICB2ZXJ0aWNhbCA9IF9yZWYkdmVydGljYWwgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmJHZlcnRpY2FsLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydjaGlsZHJlbicsICdpZCcsICdmcm9tJywgJ3RvJywgJ3gxJywgJ3kxJywgJ3gyJywgJ3kyJywgJ2Zyb21PZmZzZXQnLCAnZnJvbU9wYWNpdHknLCAndG9PZmZzZXQnLCAndG9PcGFjaXR5JywgJ3JvdGF0ZScsICd0cmFuc2Zvcm0nLCAndmVydGljYWwnXSk7XG5cbiAgaWYgKHZlcnRpY2FsICYmICF4MSAmJiAheDIgJiYgIXkxICYmICF5Mikge1xuICAgIHgxID0gJzAnO1xuICAgIHgyID0gJzAnO1xuICAgIHkxID0gJzAnO1xuICAgIHkyID0gJzEnO1xuICB9XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICdkZWZzJyxcbiAgICBudWxsLFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnbGluZWFyR3JhZGllbnQnLFxuICAgICAgX2V4dGVuZHMoe1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIHkyOiB5MixcbiAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm06IHJvdGF0ZSA/ICdyb3RhdGUoJyArIHJvdGF0ZSArICcpJyA6IHRyYW5zZm9ybVxuICAgICAgfSwgcmVzdFByb3BzKSxcbiAgICAgICEhY2hpbGRyZW4gJiYgY2hpbGRyZW4sXG4gICAgICAhY2hpbGRyZW4gJiYgUmVhY3QuY3JlYXRlRWxlbWVudCgnc3RvcCcsIHsgb2Zmc2V0OiBmcm9tT2Zmc2V0LCBzdG9wQ29sb3I6IGZyb20sIHN0b3BPcGFjaXR5OiBmcm9tT3BhY2l0eSB9KSxcbiAgICAgICFjaGlsZHJlbiAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KCdzdG9wJywgeyBvZmZzZXQ6IHRvT2Zmc2V0LCBzdG9wQ29sb3I6IHRvLCBzdG9wT3BhY2l0eTogdG9PcGFjaXR5IH0pXG4gICAgKVxuICApO1xufVxuXG5SYWRpYWxHcmFkaWVudC5wcm9wVHlwZXMgPSB7XG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIGZyb206IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBmcm9tT2Zmc2V0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICBmcm9tT3BhY2l0eTogUHJvcFR5cGVzLm51bWJlcixcbiAgdG9PZmZzZXQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvT3BhY2l0eTogUHJvcFR5cGVzLm51bWJlcixcbiAgcm90YXRlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHRyYW5zZm9ybTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuZnVuY3Rpb24gUmFkaWFsR3JhZGllbnQoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgaWQgPSBfcmVmLmlkLFxuICAgICAgZnJvbSA9IF9yZWYuZnJvbSxcbiAgICAgIHRvID0gX3JlZi50byxcbiAgICAgIF9yZWYkZnJvbU9mZnNldCA9IF9yZWYuZnJvbU9mZnNldCxcbiAgICAgIGZyb21PZmZzZXQgPSBfcmVmJGZyb21PZmZzZXQgPT09IHVuZGVmaW5lZCA/ICcwJScgOiBfcmVmJGZyb21PZmZzZXQsXG4gICAgICBfcmVmJGZyb21PcGFjaXR5ID0gX3JlZi5mcm9tT3BhY2l0eSxcbiAgICAgIGZyb21PcGFjaXR5ID0gX3JlZiRmcm9tT3BhY2l0eSA9PT0gdW5kZWZpbmVkID8gMSA6IF9yZWYkZnJvbU9wYWNpdHksXG4gICAgICBfcmVmJHRvT2Zmc2V0ID0gX3JlZi50b09mZnNldCxcbiAgICAgIHRvT2Zmc2V0ID0gX3JlZiR0b09mZnNldCA9PT0gdW5kZWZpbmVkID8gJzEwMCUnIDogX3JlZiR0b09mZnNldCxcbiAgICAgIF9yZWYkdG9PcGFjaXR5ID0gX3JlZi50b09wYWNpdHksXG4gICAgICB0b09wYWNpdHkgPSBfcmVmJHRvT3BhY2l0eSA9PT0gdW5kZWZpbmVkID8gMSA6IF9yZWYkdG9PcGFjaXR5LFxuICAgICAgcm90YXRlID0gX3JlZi5yb3RhdGUsXG4gICAgICB0cmFuc2Zvcm0gPSBfcmVmLnRyYW5zZm9ybSxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2hpbGRyZW4nLCAnaWQnLCAnZnJvbScsICd0bycsICdmcm9tT2Zmc2V0JywgJ2Zyb21PcGFjaXR5JywgJ3RvT2Zmc2V0JywgJ3RvT3BhY2l0eScsICdyb3RhdGUnLCAndHJhbnNmb3JtJ10pO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICdkZWZzJyxcbiAgICBudWxsLFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAncmFkaWFsR3JhZGllbnQnLFxuICAgICAgX2V4dGVuZHMoe1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGdyYWRpZW50VHJhbnNmb3JtOiByb3RhdGUgPyAncm90YXRlKCcgKyByb3RhdGUgKyAnKScgOiB0cmFuc2Zvcm1cbiAgICAgIH0sIHJlc3RQcm9wcyksXG4gICAgICAhIWNoaWxkcmVuICYmIGNoaWxkcmVuLFxuICAgICAgIWNoaWxkcmVuICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3N0b3AnLCB7IG9mZnNldDogZnJvbU9mZnNldCwgc3RvcENvbG9yOiBmcm9tLCBzdG9wT3BhY2l0eTogZnJvbU9wYWNpdHkgfSksXG4gICAgICAhY2hpbGRyZW4gJiYgUmVhY3QuY3JlYXRlRWxlbWVudCgnc3RvcCcsIHsgb2Zmc2V0OiB0b09mZnNldCwgc3RvcENvbG9yOiB0bywgc3RvcE9wYWNpdHk6IHRvT3BhY2l0eSB9KVxuICAgIClcbiAgKTtcbn1cblxudmFyIERhcmtncmVlbkdyZWVuID0gKGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChMaW5lYXJHcmFkaWVudCwgX2V4dGVuZHMoeyBmcm9tOiAnIzE4NEU4NicsIHRvOiAnIzU3Q0E4NScgfSwgcHJvcHMpKTtcbn0pO1xuXG52YXIgTGlnaHRncmVlbkdyZWVuID0gKGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChMaW5lYXJHcmFkaWVudCwgX2V4dGVuZHMoeyBmcm9tOiAnIzQyRTY5NScsIHRvOiAnIzNCQjJCOCcgfSwgcHJvcHMpKTtcbn0pO1xuXG52YXIgT3JhbmdlUmVkID0gKGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChMaW5lYXJHcmFkaWVudCwgX2V4dGVuZHMoeyBmcm9tOiAnI0ZDRTM4QScsIHRvOiAnI0YzODE4MScgfSwgcHJvcHMpKTtcbn0pO1xuXG52YXIgUGlua0JsdWUgPSAoZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KExpbmVhckdyYWRpZW50LCBfZXh0ZW5kcyh7IGZyb206ICcjRjAyRkMyJywgdG86ICcjNjA5NEVBJyB9LCBwcm9wcykpO1xufSk7XG5cbnZhciBQaW5rUmVkID0gKGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChMaW5lYXJHcmFkaWVudCwgX2V4dGVuZHMoeyBmcm9tOiAnI0Y1NEVBMicsIHRvOiAnI0ZGNzY3NicgfSwgcHJvcHMpKTtcbn0pO1xuXG52YXIgUHVycGxlT3JhbmdlID0gKGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChMaW5lYXJHcmFkaWVudCwgX2V4dGVuZHMoeyBmcm9tOiAnIzcxMTdFQScsIHRvOiAnI0VBNjA2MCcgfSwgcHJvcHMpKTtcbn0pO1xuXG52YXIgUHVycGxlUmVkID0gKGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChMaW5lYXJHcmFkaWVudCwgX2V4dGVuZHMoeyBmcm9tOiAnIzYyMjc3NCcsIHRvOiAnI0M1MzM2NCcgfSwgcHJvcHMpKTtcbn0pO1xuXG52YXIgUHVycGxlVGVhbCA9IChmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGluZWFyR3JhZGllbnQsIF9leHRlbmRzKHsgZnJvbTogJyM1QjI0N0EnLCB0bzogJyMxQkNFREYnIH0sIHByb3BzKSk7XG59KTtcblxudmFyIFN0ZWVsUHVycGxlID0gKGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChMaW5lYXJHcmFkaWVudCwgX2V4dGVuZHMoeyBmcm9tOiAnIzY1Nzk5QicsIHRvOiAnIzVFMjU2MycgfSwgcHJvcHMpKTtcbn0pO1xuXG52YXIgVGVhbEJsdWUgPSAoZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KExpbmVhckdyYWRpZW50LCBfZXh0ZW5kcyh7IGZyb206ICcjMTdFQUQ5JywgdG86ICcjNjA3OEVBJyB9LCBwcm9wcykpO1xufSk7XG5cbmV4cG9ydCB7IExpbmVhckdyYWRpZW50LCBSYWRpYWxHcmFkaWVudCwgRGFya2dyZWVuR3JlZW4gYXMgR3JhZGllbnREYXJrZ3JlZW5HcmVlbiwgTGlnaHRncmVlbkdyZWVuIGFzIEdyYWRpZW50TGlnaHRncmVlbkdyZWVuLCBPcmFuZ2VSZWQgYXMgR3JhZGllbnRPcmFuZ2VSZWQsIFBpbmtCbHVlIGFzIEdyYWRpZW50UGlua0JsdWUsIFBpbmtSZWQgYXMgR3JhZGllbnRQaW5rUmVkLCBQdXJwbGVPcmFuZ2UgYXMgR3JhZGllbnRQdXJwbGVPcmFuZ2UsIFB1cnBsZVJlZCBhcyBHcmFkaWVudFB1cnBsZVJlZCwgUHVycGxlVGVhbCBhcyBHcmFkaWVudFB1cnBsZVRlYWwsIFN0ZWVsUHVycGxlIGFzIEdyYWRpZW50U3RlZWxQdXJwbGUsIFRlYWxCbHVlIGFzIEdyYWRpZW50VGVhbEJsdWUgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///465\n")},470:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(1);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: ./node_modules/classnames/index.js\nvar classnames = __webpack_require__(93);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(0);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// CONCATENATED MODULE: ./node_modules/d3-path/src/path.js\nvar pi = Math.PI,\n    tau = 2 * pi,\n    epsilon = 1e-6,\n    tauEpsilon = tau - epsilon;\n\nfunction Path() {\n  this._x0 = this._y0 = // start of current subpath\n  this._x1 = this._y1 = null; // end of current subpath\n  this._ = \"\";\n}\n\nfunction path() {\n  return new Path;\n}\n\nPath.prototype = path.prototype = {\n  constructor: Path,\n  moveTo: function(x, y) {\n    this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y);\n  },\n  closePath: function() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  },\n  lineTo: function(x, y) {\n    this._ += \"L\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  quadraticCurveTo: function(x1, y1, x, y) {\n    this._ += \"Q\" + (+x1) + \",\" + (+y1) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) {\n    this._ += \"C\" + (+x1) + \",\" + (+y1) + \",\" + (+x2) + \",\" + (+y2) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  arcTo: function(x1, y1, x2, y2, r) {\n    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n    var x0 = this._x1,\n        y0 = this._y1,\n        x21 = x2 - x1,\n        y21 = y2 - y1,\n        x01 = x0 - x1,\n        y01 = y0 - y1,\n        l01_2 = x01 * x01 + y01 * y01;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(\"negative radius: \" + r);\n\n    // Is this path empty? Move to (x1,y1).\n    if (this._x1 === null) {\n      this._ += \"M\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n    }\n\n    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n    else if (!(l01_2 > epsilon));\n\n    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n    // Equivalently, is (x1,y1) coincident with (x2,y2)?\n    // Or, is the radius zero? Line to (x1,y1).\n    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n      this._ += \"L\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n    }\n\n    // Otherwise, draw an arc!\n    else {\n      var x20 = x2 - x0,\n          y20 = y2 - y0,\n          l21_2 = x21 * x21 + y21 * y21,\n          l20_2 = x20 * x20 + y20 * y20,\n          l21 = Math.sqrt(l21_2),\n          l01 = Math.sqrt(l01_2),\n          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n          t01 = l / l01,\n          t21 = l / l21;\n\n      // If the start tangent is not coincident with (x0,y0), line to.\n      if (Math.abs(t01 - 1) > epsilon) {\n        this._ += \"L\" + (x1 + t01 * x01) + \",\" + (y1 + t01 * y01);\n      }\n\n      this._ += \"A\" + r + \",\" + r + \",0,0,\" + (+(y01 * x20 > x01 * y20)) + \",\" + (this._x1 = x1 + t21 * x21) + \",\" + (this._y1 = y1 + t21 * y21);\n    }\n  },\n  arc: function(x, y, r, a0, a1, ccw) {\n    x = +x, y = +y, r = +r;\n    var dx = r * Math.cos(a0),\n        dy = r * Math.sin(a0),\n        x0 = x + dx,\n        y0 = y + dy,\n        cw = 1 ^ ccw,\n        da = ccw ? a0 - a1 : a1 - a0;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(\"negative radius: \" + r);\n\n    // Is this path empty? Move to (x0,y0).\n    if (this._x1 === null) {\n      this._ += \"M\" + x0 + \",\" + y0;\n    }\n\n    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n      this._ += \"L\" + x0 + \",\" + y0;\n    }\n\n    // Is this arc empty? We’re done.\n    if (!r) return;\n\n    // Does the angle go the wrong way? Flip the direction.\n    if (da < 0) da = da % tau + tau;\n\n    // Is this a complete circle? Draw two arcs to complete the circle.\n    if (da > tauEpsilon) {\n      this._ += \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (x - dx) + \",\" + (y - dy) + \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (this._x1 = x0) + \",\" + (this._y1 = y0);\n    }\n\n    // Is this arc non-empty? Draw an arc!\n    else if (da > epsilon) {\n      this._ += \"A\" + r + \",\" + r + \",0,\" + (+(da >= pi)) + \",\" + cw + \",\" + (this._x1 = x + r * Math.cos(a1)) + \",\" + (this._y1 = y + r * Math.sin(a1));\n    }\n  },\n  rect: function(x, y, w, h) {\n    this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y) + \"h\" + (+w) + \"v\" + (+h) + \"h\" + (-w) + \"Z\";\n  },\n  toString: function() {\n    return this._;\n  }\n};\n\n/* harmony default export */ var src_path = (path);\n\n// CONCATENATED MODULE: ./node_modules/d3-path/src/index.js\n\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/constant.js\n/* harmony default export */ var constant = (function(x) {\n  return function constant() {\n    return x;\n  };\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/math.js\nvar abs = Math.abs;\nvar atan2 = Math.atan2;\nvar cos = Math.cos;\nvar max = Math.max;\nvar min = Math.min;\nvar sin = Math.sin;\nvar sqrt = Math.sqrt;\n\nvar math_epsilon = 1e-12;\nvar math_pi = Math.PI;\nvar halfPi = math_pi / 2;\nvar math_tau = 2 * math_pi;\n\nfunction acos(x) {\n  return x > 1 ? 0 : x < -1 ? math_pi : Math.acos(x);\n}\n\nfunction asin(x) {\n  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);\n}\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/arc.js\n\n\n\n\nfunction arcInnerRadius(d) {\n  return d.innerRadius;\n}\n\nfunction arcOuterRadius(d) {\n  return d.outerRadius;\n}\n\nfunction arcStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction arcEndAngle(d) {\n  return d.endAngle;\n}\n\nfunction arcPadAngle(d) {\n  return d && d.padAngle; // Note: optional!\n}\n\nfunction intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var x10 = x1 - x0, y10 = y1 - y0,\n      x32 = x3 - x2, y32 = y3 - y2,\n      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);\n  return [x0 + t * x10, y0 + t * y10];\n}\n\n// Compute perpendicular offset line of length rc.\n// http://mathworld.wolfram.com/Circle-LineIntersection.html\nfunction cornerTangents(x0, y0, x1, y1, r1, rc, cw) {\n  var x01 = x0 - x1,\n      y01 = y0 - y1,\n      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),\n      ox = lo * y01,\n      oy = -lo * x01,\n      x11 = x0 + ox,\n      y11 = y0 + oy,\n      x10 = x1 + ox,\n      y10 = y1 + oy,\n      x00 = (x11 + x10) / 2,\n      y00 = (y11 + y10) / 2,\n      dx = x10 - x11,\n      dy = y10 - y11,\n      d2 = dx * dx + dy * dy,\n      r = r1 - rc,\n      D = x11 * y10 - x10 * y11,\n      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),\n      cx0 = (D * dy - dx * d) / d2,\n      cy0 = (-D * dx - dy * d) / d2,\n      cx1 = (D * dy + dx * d) / d2,\n      cy1 = (-D * dx + dy * d) / d2,\n      dx0 = cx0 - x00,\n      dy0 = cy0 - y00,\n      dx1 = cx1 - x00,\n      dy1 = cy1 - y00;\n\n  // Pick the closer of the two intersection points.\n  // TODO Is there a faster way to determine which intersection to use?\n  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n\n  return {\n    cx: cx0,\n    cy: cy0,\n    x01: -ox,\n    y01: -oy,\n    x11: cx0 * (r1 / r - 1),\n    y11: cy0 * (r1 / r - 1)\n  };\n}\n\n/* harmony default export */ var src_arc = (function() {\n  var innerRadius = arcInnerRadius,\n      outerRadius = arcOuterRadius,\n      cornerRadius = constant(0),\n      padRadius = null,\n      startAngle = arcStartAngle,\n      endAngle = arcEndAngle,\n      padAngle = arcPadAngle,\n      context = null;\n\n  function arc() {\n    var buffer,\n        r,\n        r0 = +innerRadius.apply(this, arguments),\n        r1 = +outerRadius.apply(this, arguments),\n        a0 = startAngle.apply(this, arguments) - halfPi,\n        a1 = endAngle.apply(this, arguments) - halfPi,\n        da = abs(a1 - a0),\n        cw = a1 > a0;\n\n    if (!context) context = buffer = src_path();\n\n    // Ensure that the outer radius is always larger than the inner radius.\n    if (r1 < r0) r = r1, r1 = r0, r0 = r;\n\n    // Is it a point?\n    if (!(r1 > math_epsilon)) context.moveTo(0, 0);\n\n    // Or is it a circle or annulus?\n    else if (da > math_tau - math_epsilon) {\n      context.moveTo(r1 * cos(a0), r1 * sin(a0));\n      context.arc(0, 0, r1, a0, a1, !cw);\n      if (r0 > math_epsilon) {\n        context.moveTo(r0 * cos(a1), r0 * sin(a1));\n        context.arc(0, 0, r0, a1, a0, cw);\n      }\n    }\n\n    // Or is it a circular or annular sector?\n    else {\n      var a01 = a0,\n          a11 = a1,\n          a00 = a0,\n          a10 = a1,\n          da0 = da,\n          da1 = da,\n          ap = padAngle.apply(this, arguments) / 2,\n          rp = (ap > math_epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),\n          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),\n          rc0 = rc,\n          rc1 = rc,\n          t0,\n          t1;\n\n      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.\n      if (rp > math_epsilon) {\n        var p0 = asin(rp / r0 * sin(ap)),\n            p1 = asin(rp / r1 * sin(ap));\n        if ((da0 -= p0 * 2) > math_epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;\n        else da0 = 0, a00 = a10 = (a0 + a1) / 2;\n        if ((da1 -= p1 * 2) > math_epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;\n        else da1 = 0, a01 = a11 = (a0 + a1) / 2;\n      }\n\n      var x01 = r1 * cos(a01),\n          y01 = r1 * sin(a01),\n          x10 = r0 * cos(a10),\n          y10 = r0 * sin(a10);\n\n      // Apply rounded corners?\n      if (rc > math_epsilon) {\n        var x11 = r1 * cos(a11),\n            y11 = r1 * sin(a11),\n            x00 = r0 * cos(a00),\n            y00 = r0 * sin(a00);\n\n        // Restrict the corner radius according to the sector angle.\n        if (da < math_pi) {\n          var oc = da0 > math_epsilon ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],\n              ax = x01 - oc[0],\n              ay = y01 - oc[1],\n              bx = x11 - oc[0],\n              by = y11 - oc[1],\n              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),\n              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n          rc0 = min(rc, (r0 - lc) / (kc - 1));\n          rc1 = min(rc, (r1 - lc) / (kc + 1));\n        }\n      }\n\n      // Is the sector collapsed to a line?\n      if (!(da1 > math_epsilon)) context.moveTo(x01, y01);\n\n      // Does the sector’s outer ring have rounded corners?\n      else if (rc1 > math_epsilon) {\n        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);\n        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n\n        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);\n          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the outer ring just a circular arc?\n      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);\n\n      // Is there no inner ring, and it’s a circular sector?\n      // Or perhaps it’s an annular sector collapsed due to padding?\n      if (!(r0 > math_epsilon) || !(da0 > math_epsilon)) context.lineTo(x10, y10);\n\n      // Does the sector’s inner ring (or point) have rounded corners?\n      else if (rc0 > math_epsilon) {\n        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);\n\n        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);\n          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the inner ring just a circular arc?\n      else context.arc(0, 0, r0, a10, a00, cw);\n    }\n\n    context.closePath();\n\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  arc.centroid = function() {\n    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,\n        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - math_pi / 2;\n    return [cos(a) * r, sin(a) * r];\n  };\n\n  arc.innerRadius = function(_) {\n    return arguments.length ? (innerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : innerRadius;\n  };\n\n  arc.outerRadius = function(_) {\n    return arguments.length ? (outerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : outerRadius;\n  };\n\n  arc.cornerRadius = function(_) {\n    return arguments.length ? (cornerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : cornerRadius;\n  };\n\n  arc.padRadius = function(_) {\n    return arguments.length ? (padRadius = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), arc) : padRadius;\n  };\n\n  arc.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : startAngle;\n  };\n\n  arc.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : endAngle;\n  };\n\n  arc.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : padAngle;\n  };\n\n  arc.context = function(_) {\n    return arguments.length ? ((context = _ == null ? null : _), arc) : context;\n  };\n\n  return arc;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/linear.js\nfunction Linear(context) {\n  this._context = context;\n}\n\nLinear.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // proceed\n      default: this._context.lineTo(x, y); break;\n    }\n  }\n};\n\n/* harmony default export */ var linear = (function(context) {\n  return new Linear(context);\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/point.js\nfunction point_x(p) {\n  return p[0];\n}\n\nfunction point_y(p) {\n  return p[1];\n}\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/line.js\n\n\n\n\n\n/* harmony default export */ var src_line = (function() {\n  var x = point_x,\n      y = point_y,\n      defined = constant(true),\n      context = null,\n      curve = linear,\n      output = null;\n\n  function line(data) {\n    var i,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer;\n\n    if (context == null) output = curve(buffer = src_path());\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) output.lineStart();\n        else output.lineEnd();\n      }\n      if (defined0) output.point(+x(d, i, data), +y(d, i, data));\n    }\n\n    if (buffer) return output = null, buffer + \"\" || null;\n  }\n\n  line.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant(+_), line) : x;\n  };\n\n  line.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant(+_), line) : y;\n  };\n\n  line.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant(!!_), line) : defined;\n  };\n\n  line.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;\n  };\n\n  line.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;\n  };\n\n  return line;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/area.js\n\n\n\n\n\n\n/* harmony default export */ var src_area = (function() {\n  var x0 = point_x,\n      x1 = null,\n      y0 = constant(0),\n      y1 = point_y,\n      defined = constant(true),\n      context = null,\n      curve = linear,\n      output = null;\n\n  function area(data) {\n    var i,\n        j,\n        k,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer,\n        x0z = new Array(n),\n        y0z = new Array(n);\n\n    if (context == null) output = curve(buffer = src_path());\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) {\n          j = i;\n          output.areaStart();\n          output.lineStart();\n        } else {\n          output.lineEnd();\n          output.lineStart();\n          for (k = i - 1; k >= j; --k) {\n            output.point(x0z[k], y0z[k]);\n          }\n          output.lineEnd();\n          output.areaEnd();\n        }\n      }\n      if (defined0) {\n        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);\n        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);\n      }\n    }\n\n    if (buffer) return output = null, buffer + \"\" || null;\n  }\n\n  function arealine() {\n    return src_line().defined(defined).curve(curve).context(context);\n  }\n\n  area.x = function(_) {\n    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant(+_), x1 = null, area) : x0;\n  };\n\n  area.x0 = function(_) {\n    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant(+_), area) : x0;\n  };\n\n  area.x1 = function(_) {\n    return arguments.length ? (x1 = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), area) : x1;\n  };\n\n  area.y = function(_) {\n    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant(+_), y1 = null, area) : y0;\n  };\n\n  area.y0 = function(_) {\n    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant(+_), area) : y0;\n  };\n\n  area.y1 = function(_) {\n    return arguments.length ? (y1 = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), area) : y1;\n  };\n\n  area.lineX0 =\n  area.lineY0 = function() {\n    return arealine().x(x0).y(y0);\n  };\n\n  area.lineY1 = function() {\n    return arealine().x(x0).y(y1);\n  };\n\n  area.lineX1 = function() {\n    return arealine().x(x1).y(y0);\n  };\n\n  area.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant(!!_), area) : defined;\n  };\n\n  area.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;\n  };\n\n  area.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;\n  };\n\n  return area;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/descending.js\n/* harmony default export */ var descending = (function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/identity.js\n/* harmony default export */ var identity = (function(d) {\n  return d;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/pie.js\n\n\n\n\n\n/* harmony default export */ var src_pie = (function() {\n  var value = identity,\n      sortValues = descending,\n      sort = null,\n      startAngle = constant(0),\n      endAngle = constant(math_tau),\n      padAngle = constant(0);\n\n  function pie(data) {\n    var i,\n        n = data.length,\n        j,\n        k,\n        sum = 0,\n        index = new Array(n),\n        arcs = new Array(n),\n        a0 = +startAngle.apply(this, arguments),\n        da = Math.min(math_tau, Math.max(-math_tau, endAngle.apply(this, arguments) - a0)),\n        a1,\n        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),\n        pa = p * (da < 0 ? -1 : 1),\n        v;\n\n    for (i = 0; i < n; ++i) {\n      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {\n        sum += v;\n      }\n    }\n\n    // Optionally sort the arcs by previously-computed values or by data.\n    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });\n    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });\n\n    // Compute the arcs! They are stored in the original data's order.\n    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {\n      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {\n        data: data[j],\n        index: i,\n        value: v,\n        startAngle: a0,\n        endAngle: a1,\n        padAngle: p\n      };\n    }\n\n    return arcs;\n  }\n\n  pie.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(+_), pie) : value;\n  };\n\n  pie.sortValues = function(_) {\n    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;\n  };\n\n  pie.sort = function(_) {\n    return arguments.length ? (sort = _, sortValues = null, pie) : sort;\n  };\n\n  pie.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : startAngle;\n  };\n\n  pie.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : endAngle;\n  };\n\n  pie.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : padAngle;\n  };\n\n  return pie;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/radial.js\n\n\nvar curveRadialLinear = curveRadial(linear);\n\nfunction Radial(curve) {\n  this._curve = curve;\n}\n\nRadial.prototype = {\n  areaStart: function() {\n    this._curve.areaStart();\n  },\n  areaEnd: function() {\n    this._curve.areaEnd();\n  },\n  lineStart: function() {\n    this._curve.lineStart();\n  },\n  lineEnd: function() {\n    this._curve.lineEnd();\n  },\n  point: function(a, r) {\n    this._curve.point(r * Math.sin(a), r * -Math.cos(a));\n  }\n};\n\nfunction curveRadial(curve) {\n\n  function radial(context) {\n    return new Radial(curve(context));\n  }\n\n  radial._curve = curve;\n\n  return radial;\n}\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/lineRadial.js\n\n\n\nfunction lineRadial(l) {\n  var c = l.curve;\n\n  l.angle = l.x, delete l.x;\n  l.radius = l.y, delete l.y;\n\n  l.curve = function(_) {\n    return arguments.length ? c(curveRadial(_)) : c()._curve;\n  };\n\n  return l;\n}\n\n/* harmony default export */ var src_lineRadial = (function() {\n  return lineRadial(src_line().curve(curveRadialLinear));\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/areaRadial.js\n\n\n\n\n/* harmony default export */ var areaRadial = (function() {\n  var a = src_area().curve(curveRadialLinear),\n      c = a.curve,\n      x0 = a.lineX0,\n      x1 = a.lineX1,\n      y0 = a.lineY0,\n      y1 = a.lineY1;\n\n  a.angle = a.x, delete a.x;\n  a.startAngle = a.x0, delete a.x0;\n  a.endAngle = a.x1, delete a.x1;\n  a.radius = a.y, delete a.y;\n  a.innerRadius = a.y0, delete a.y0;\n  a.outerRadius = a.y1, delete a.y1;\n  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;\n  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;\n  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;\n  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;\n\n  a.curve = function(_) {\n    return arguments.length ? c(curveRadial(_)) : c()._curve;\n  };\n\n  return a;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/pointRadial.js\n/* harmony default export */ var pointRadial = (function(x, y) {\n  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/array.js\nvar slice = Array.prototype.slice;\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/link/index.js\n\n\n\n\n\n\nfunction linkSource(d) {\n  return d.source;\n}\n\nfunction linkTarget(d) {\n  return d.target;\n}\n\nfunction link_link(curve) {\n  var source = linkSource,\n      target = linkTarget,\n      x = point_x,\n      y = point_y,\n      context = null;\n\n  function link() {\n    var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);\n    if (!context) context = buffer = src_path();\n    curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  link.source = function(_) {\n    return arguments.length ? (source = _, link) : source;\n  };\n\n  link.target = function(_) {\n    return arguments.length ? (target = _, link) : target;\n  };\n\n  link.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant(+_), link) : x;\n  };\n\n  link.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant(+_), link) : y;\n  };\n\n  link.context = function(_) {\n    return arguments.length ? ((context = _ == null ? null : _), link) : context;\n  };\n\n  return link;\n}\n\nfunction curveHorizontal(context, x0, y0, x1, y1) {\n  context.moveTo(x0, y0);\n  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);\n}\n\nfunction curveVertical(context, x0, y0, x1, y1) {\n  context.moveTo(x0, y0);\n  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);\n}\n\nfunction link_curveRadial(context, x0, y0, x1, y1) {\n  var p0 = pointRadial(x0, y0),\n      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),\n      p2 = pointRadial(x1, y0),\n      p3 = pointRadial(x1, y1);\n  context.moveTo(p0[0], p0[1]);\n  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);\n}\n\nfunction linkHorizontal() {\n  return link_link(curveHorizontal);\n}\n\nfunction linkVertical() {\n  return link_link(curveVertical);\n}\n\nfunction linkRadial() {\n  var l = link_link(link_curveRadial);\n  l.angle = l.x, delete l.x;\n  l.radius = l.y, delete l.y;\n  return l;\n}\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/symbol/circle.js\n\n\n/* harmony default export */ var circle = ({\n  draw: function(context, size) {\n    var r = Math.sqrt(size / math_pi);\n    context.moveTo(r, 0);\n    context.arc(0, 0, r, 0, math_tau);\n  }\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/symbol/cross.js\n/* harmony default export */ var cross = ({\n  draw: function(context, size) {\n    var r = Math.sqrt(size / 5) / 2;\n    context.moveTo(-3 * r, -r);\n    context.lineTo(-r, -r);\n    context.lineTo(-r, -3 * r);\n    context.lineTo(r, -3 * r);\n    context.lineTo(r, -r);\n    context.lineTo(3 * r, -r);\n    context.lineTo(3 * r, r);\n    context.lineTo(r, r);\n    context.lineTo(r, 3 * r);\n    context.lineTo(-r, 3 * r);\n    context.lineTo(-r, r);\n    context.lineTo(-3 * r, r);\n    context.closePath();\n  }\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/symbol/diamond.js\nvar tan30 = Math.sqrt(1 / 3),\n    tan30_2 = tan30 * 2;\n\n/* harmony default export */ var diamond = ({\n  draw: function(context, size) {\n    var y = Math.sqrt(size / tan30_2),\n        x = y * tan30;\n    context.moveTo(0, -y);\n    context.lineTo(x, 0);\n    context.lineTo(0, y);\n    context.lineTo(-x, 0);\n    context.closePath();\n  }\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/symbol/star.js\n\n\nvar ka = 0.89081309152928522810,\n    kr = Math.sin(math_pi / 10) / Math.sin(7 * math_pi / 10),\n    kx = Math.sin(math_tau / 10) * kr,\n    ky = -Math.cos(math_tau / 10) * kr;\n\n/* harmony default export */ var star = ({\n  draw: function(context, size) {\n    var r = Math.sqrt(size * ka),\n        x = kx * r,\n        y = ky * r;\n    context.moveTo(0, -r);\n    context.lineTo(x, y);\n    for (var i = 1; i < 5; ++i) {\n      var a = math_tau * i / 5,\n          c = Math.cos(a),\n          s = Math.sin(a);\n      context.lineTo(s * r, -c * r);\n      context.lineTo(c * x - s * y, s * x + c * y);\n    }\n    context.closePath();\n  }\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/symbol/square.js\n/* harmony default export */ var square = ({\n  draw: function(context, size) {\n    var w = Math.sqrt(size),\n        x = -w / 2;\n    context.rect(x, x, w, w);\n  }\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/symbol/triangle.js\nvar sqrt3 = Math.sqrt(3);\n\n/* harmony default export */ var triangle = ({\n  draw: function(context, size) {\n    var y = -Math.sqrt(size / (sqrt3 * 3));\n    context.moveTo(0, y * 2);\n    context.lineTo(-sqrt3 * y, -y);\n    context.lineTo(sqrt3 * y, -y);\n    context.closePath();\n  }\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/symbol/wye.js\nvar wye_c = -0.5,\n    wye_s = Math.sqrt(3) / 2,\n    wye_k = 1 / Math.sqrt(12),\n    wye_a = (wye_k / 2 + 1) * 3;\n\n/* harmony default export */ var wye = ({\n  draw: function(context, size) {\n    var r = Math.sqrt(size / wye_a),\n        x0 = r / 2,\n        y0 = r * wye_k,\n        x1 = x0,\n        y1 = r * wye_k + r,\n        x2 = -x1,\n        y2 = y1;\n    context.moveTo(x0, y0);\n    context.lineTo(x1, y1);\n    context.lineTo(x2, y2);\n    context.lineTo(wye_c * x0 - wye_s * y0, wye_s * x0 + wye_c * y0);\n    context.lineTo(wye_c * x1 - wye_s * y1, wye_s * x1 + wye_c * y1);\n    context.lineTo(wye_c * x2 - wye_s * y2, wye_s * x2 + wye_c * y2);\n    context.lineTo(wye_c * x0 + wye_s * y0, wye_c * y0 - wye_s * x0);\n    context.lineTo(wye_c * x1 + wye_s * y1, wye_c * y1 - wye_s * x1);\n    context.lineTo(wye_c * x2 + wye_s * y2, wye_c * y2 - wye_s * x2);\n    context.closePath();\n  }\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/symbol.js\n\n\n\n\n\n\n\n\n\n\nvar symbols = [\n  circle,\n  cross,\n  diamond,\n  square,\n  star,\n  triangle,\n  wye\n];\n\n/* harmony default export */ var src_symbol = (function() {\n  var type = constant(circle),\n      size = constant(64),\n      context = null;\n\n  function symbol() {\n    var buffer;\n    if (!context) context = buffer = src_path();\n    type.apply(this, arguments).draw(context, +size.apply(this, arguments));\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  symbol.type = function(_) {\n    return arguments.length ? (type = typeof _ === \"function\" ? _ : constant(_), symbol) : type;\n  };\n\n  symbol.size = function(_) {\n    return arguments.length ? (size = typeof _ === \"function\" ? _ : constant(+_), symbol) : size;\n  };\n\n  symbol.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, symbol) : context;\n  };\n\n  return symbol;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/noop.js\n/* harmony default export */ var noop = (function() {});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/basis.js\nfunction point(that, x, y) {\n  that._context.bezierCurveTo(\n    (2 * that._x0 + that._x1) / 3,\n    (2 * that._y0 + that._y1) / 3,\n    (that._x0 + 2 * that._x1) / 3,\n    (that._y0 + 2 * that._y1) / 3,\n    (that._x0 + 4 * that._x1 + x) / 6,\n    (that._y0 + 4 * that._y1 + y) / 6\n  );\n}\n\nfunction Basis(context) {\n  this._context = context;\n}\n\nBasis.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 3: point(this, this._x1, this._y1); // proceed\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\n/* harmony default export */ var basis = (function(context) {\n  return new Basis(context);\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/basisClosed.js\n\n\n\nfunction BasisClosed(context) {\n  this._context = context;\n}\n\nBasisClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x2, this._y2);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);\n        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x2, this._y2);\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;\n      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;\n      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\n/* harmony default export */ var basisClosed = (function(context) {\n  return new BasisClosed(context);\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/basisOpen.js\n\n\nfunction BasisOpen(context) {\n  this._context = context;\n}\n\nBasisOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;\n      case 3: this._point = 4; // proceed\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\n/* harmony default export */ var basisOpen = (function(context) {\n  return new BasisOpen(context);\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/bundle.js\n\n\nfunction Bundle(context, beta) {\n  this._basis = new Basis(context);\n  this._beta = beta;\n}\n\nBundle.prototype = {\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n    this._basis.lineStart();\n  },\n  lineEnd: function() {\n    var x = this._x,\n        y = this._y,\n        j = x.length - 1;\n\n    if (j > 0) {\n      var x0 = x[0],\n          y0 = y[0],\n          dx = x[j] - x0,\n          dy = y[j] - y0,\n          i = -1,\n          t;\n\n      while (++i <= j) {\n        t = i / j;\n        this._basis.point(\n          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),\n          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)\n        );\n      }\n    }\n\n    this._x = this._y = null;\n    this._basis.lineEnd();\n  },\n  point: function(x, y) {\n    this._x.push(+x);\n    this._y.push(+y);\n  }\n};\n\n/* harmony default export */ var curve_bundle = ((function custom(beta) {\n\n  function bundle(context) {\n    return beta === 1 ? new Basis(context) : new Bundle(context, beta);\n  }\n\n  bundle.beta = function(beta) {\n    return custom(+beta);\n  };\n\n  return bundle;\n})(0.85));\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/cardinal.js\nfunction cardinal_point(that, x, y) {\n  that._context.bezierCurveTo(\n    that._x1 + that._k * (that._x2 - that._x0),\n    that._y1 + that._k * (that._y2 - that._y0),\n    that._x2 + that._k * (that._x1 - x),\n    that._y2 + that._k * (that._y1 - y),\n    that._x2,\n    that._y2\n  );\n}\n\nfunction Cardinal(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinal.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: cardinal_point(this, this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;\n      case 2: this._point = 3; // proceed\n      default: cardinal_point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\n/* harmony default export */ var cardinal = ((function custom(tension) {\n\n  function cardinal(context) {\n    return new Cardinal(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0));\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/cardinalClosed.js\n\n\n\nfunction CardinalClosed(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinalClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;\n      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;\n      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;\n      default: cardinal_point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\n/* harmony default export */ var cardinalClosed = ((function custom(tension) {\n\n  function cardinal(context) {\n    return new CardinalClosed(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0));\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/cardinalOpen.js\n\n\nfunction CardinalOpen(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinalOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;\n      case 3: this._point = 4; // proceed\n      default: cardinal_point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\n/* harmony default export */ var cardinalOpen = ((function custom(tension) {\n\n  function cardinal(context) {\n    return new CardinalOpen(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0));\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/catmullRom.js\n\n\n\nfunction catmullRom_point(that, x, y) {\n  var x1 = that._x1,\n      y1 = that._y1,\n      x2 = that._x2,\n      y2 = that._y2;\n\n  if (that._l01_a > math_epsilon) {\n    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,\n        n = 3 * that._l01_a * (that._l01_a + that._l12_a);\n    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;\n    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;\n  }\n\n  if (that._l23_a > math_epsilon) {\n    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,\n        m = 3 * that._l23_a * (that._l23_a + that._l12_a);\n    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;\n    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;\n  }\n\n  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);\n}\n\nfunction CatmullRom(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRom.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: this.point(this._x2, this._y2); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; // proceed\n      default: catmullRom_point(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\n/* harmony default export */ var curve_catmullRom = ((function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5));\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/catmullRomClosed.js\n\n\n\n\nfunction CatmullRomClosed(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRomClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;\n      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;\n      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;\n      default: catmullRom_point(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\n/* harmony default export */ var catmullRomClosed = ((function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5));\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/catmullRomOpen.js\n\n\n\nfunction CatmullRomOpen(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRomOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;\n      case 3: this._point = 4; // proceed\n      default: catmullRom_point(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\n/* harmony default export */ var catmullRomOpen = ((function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5));\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/linearClosed.js\n\n\nfunction LinearClosed(context) {\n  this._context = context;\n}\n\nLinearClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._point) this._context.closePath();\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    if (this._point) this._context.lineTo(x, y);\n    else this._point = 1, this._context.moveTo(x, y);\n  }\n};\n\n/* harmony default export */ var linearClosed = (function(context) {\n  return new LinearClosed(context);\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/monotone.js\nfunction sign(x) {\n  return x < 0 ? -1 : 1;\n}\n\n// Calculate the slopes of the tangents (Hermite-type interpolation) based on\n// the following paper: Steffen, M. 1990. A Simple Method for Monotonic\n// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.\n// NOV(II), P. 443, 1990.\nfunction slope3(that, x2, y2) {\n  var h0 = that._x1 - that._x0,\n      h1 = x2 - that._x1,\n      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),\n      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),\n      p = (s0 * h1 + s1 * h0) / (h0 + h1);\n  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n}\n\n// Calculate a one-sided slope.\nfunction slope2(that, t) {\n  var h = that._x1 - that._x0;\n  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;\n}\n\n// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n// \"you can express cubic Hermite interpolation in terms of cubic Bézier curves\n// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1\".\nfunction monotone_point(that, t0, t1) {\n  var x0 = that._x0,\n      y0 = that._y0,\n      x1 = that._x1,\n      y1 = that._y1,\n      dx = (x1 - x0) / 3;\n  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);\n}\n\nfunction MonotoneX(context) {\n  this._context = context;\n}\n\nMonotoneX.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 =\n    this._t0 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n      case 3: monotone_point(this, this._t0, slope2(this, this._t0)); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    var t1 = NaN;\n\n    x = +x, y = +y;\n    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; monotone_point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;\n      default: monotone_point(this, this._t0, t1 = slope3(this, x, y)); break;\n    }\n\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n    this._t0 = t1;\n  }\n}\n\nfunction MonotoneY(context) {\n  this._context = new ReflectContext(context);\n}\n\n(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {\n  MonotoneX.prototype.point.call(this, y, x);\n};\n\nfunction ReflectContext(context) {\n  this._context = context;\n}\n\nReflectContext.prototype = {\n  moveTo: function(x, y) { this._context.moveTo(y, x); },\n  closePath: function() { this._context.closePath(); },\n  lineTo: function(x, y) { this._context.lineTo(y, x); },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }\n};\n\nfunction monotoneX(context) {\n  return new MonotoneX(context);\n}\n\nfunction monotoneY(context) {\n  return new MonotoneY(context);\n}\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/natural.js\nfunction Natural(context) {\n  this._context = context;\n}\n\nNatural.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n  },\n  lineEnd: function() {\n    var x = this._x,\n        y = this._y,\n        n = x.length;\n\n    if (n) {\n      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);\n      if (n === 2) {\n        this._context.lineTo(x[1], y[1]);\n      } else {\n        var px = controlPoints(x),\n            py = controlPoints(y);\n        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {\n          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);\n        }\n      }\n    }\n\n    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n    this._x = this._y = null;\n  },\n  point: function(x, y) {\n    this._x.push(+x);\n    this._y.push(+y);\n  }\n};\n\n// See https://www.particleincell.com/2012/bezier-splines/ for derivation.\nfunction controlPoints(x) {\n  var i,\n      n = x.length - 1,\n      m,\n      a = new Array(n),\n      b = new Array(n),\n      r = new Array(n);\n  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];\n  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];\n  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];\n  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];\n  a[n - 1] = r[n - 1] / b[n - 1];\n  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];\n  b[n - 1] = (x[n] + a[n - 1]) / 2;\n  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];\n  return [a, b];\n}\n\n/* harmony default export */ var natural = (function(context) {\n  return new Natural(context);\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/step.js\nfunction Step(context, t) {\n  this._context = context;\n  this._t = t;\n}\n\nStep.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = this._y = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // proceed\n      default: {\n        if (this._t <= 0) {\n          this._context.lineTo(this._x, y);\n          this._context.lineTo(x, y);\n        } else {\n          var x1 = this._x * (1 - this._t) + x * this._t;\n          this._context.lineTo(x1, this._y);\n          this._context.lineTo(x1, y);\n        }\n        break;\n      }\n    }\n    this._x = x, this._y = y;\n  }\n};\n\n/* harmony default export */ var step = (function(context) {\n  return new Step(context, 0.5);\n});\n\nfunction stepBefore(context) {\n  return new Step(context, 0);\n}\n\nfunction stepAfter(context) {\n  return new Step(context, 1);\n}\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/offset/none.js\n/* harmony default export */ var none = (function(series, order) {\n  if (!((n = series.length) > 1)) return;\n  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {\n    s0 = s1, s1 = series[order[i]];\n    for (j = 0; j < m; ++j) {\n      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];\n    }\n  }\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/order/none.js\n/* harmony default export */ var order_none = (function(series) {\n  var n = series.length, o = new Array(n);\n  while (--n >= 0) o[n] = n;\n  return o;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/stack.js\n\n\n\n\n\nfunction stackValue(d, key) {\n  return d[key];\n}\n\n/* harmony default export */ var src_stack = (function() {\n  var keys = constant([]),\n      order = order_none,\n      offset = none,\n      value = stackValue;\n\n  function stack(data) {\n    var kz = keys.apply(this, arguments),\n        i,\n        m = data.length,\n        n = kz.length,\n        sz = new Array(n),\n        oz;\n\n    for (i = 0; i < n; ++i) {\n      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {\n        si[j] = sij = [0, +value(data[j], ki, j, data)];\n        sij.data = data[j];\n      }\n      si.key = ki;\n    }\n\n    for (i = 0, oz = order(sz); i < n; ++i) {\n      sz[oz[i]].index = i;\n    }\n\n    offset(sz, oz);\n    return sz;\n  }\n\n  stack.keys = function(_) {\n    return arguments.length ? (keys = typeof _ === \"function\" ? _ : constant(slice.call(_)), stack) : keys;\n  };\n\n  stack.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(+_), stack) : value;\n  };\n\n  stack.order = function(_) {\n    return arguments.length ? (order = _ == null ? order_none : typeof _ === \"function\" ? _ : constant(slice.call(_)), stack) : order;\n  };\n\n  stack.offset = function(_) {\n    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;\n  };\n\n  return stack;\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/offset/expand.js\n\n\n/* harmony default export */ var expand = (function(series, order) {\n  if (!((n = series.length) > 0)) return;\n  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {\n    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;\n    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;\n  }\n  none(series, order);\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/offset/diverging.js\n/* harmony default export */ var diverging = (function(series, order) {\n  if (!((n = series.length) > 1)) return;\n  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {\n    for (yp = yn = 0, i = 0; i < n; ++i) {\n      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {\n        d[0] = yp, d[1] = yp += dy;\n      } else if (dy < 0) {\n        d[1] = yn, d[0] = yn += dy;\n      } else {\n        d[0] = yp;\n      }\n    }\n  }\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/offset/silhouette.js\n\n\n/* harmony default export */ var silhouette = (function(series, order) {\n  if (!((n = series.length) > 0)) return;\n  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {\n    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;\n    s0[j][1] += s0[j][0] = -y / 2;\n  }\n  none(series, order);\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/offset/wiggle.js\n\n\n/* harmony default export */ var wiggle = (function(series, order) {\n  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;\n  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {\n    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {\n      var si = series[order[i]],\n          sij0 = si[j][1] || 0,\n          sij1 = si[j - 1][1] || 0,\n          s3 = (sij0 - sij1) / 2;\n      for (var k = 0; k < i; ++k) {\n        var sk = series[order[k]],\n            skj0 = sk[j][1] || 0,\n            skj1 = sk[j - 1][1] || 0;\n        s3 += skj0 - skj1;\n      }\n      s1 += sij0, s2 += s3 * sij0;\n    }\n    s0[j - 1][1] += s0[j - 1][0] = y;\n    if (s1) y -= s2 / s1;\n  }\n  s0[j - 1][1] += s0[j - 1][0] = y;\n  none(series, order);\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/order/ascending.js\n\n\n/* harmony default export */ var ascending = (function(series) {\n  var sums = series.map(ascending_sum);\n  return order_none(series).sort(function(a, b) { return sums[a] - sums[b]; });\n});\n\nfunction ascending_sum(series) {\n  var s = 0, i = -1, n = series.length, v;\n  while (++i < n) if (v = +series[i][1]) s += v;\n  return s;\n}\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/order/descending.js\n\n\n/* harmony default export */ var order_descending = (function(series) {\n  return ascending(series).reverse();\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/order/insideOut.js\n\n\n\n/* harmony default export */ var insideOut = (function(series) {\n  var n = series.length,\n      i,\n      j,\n      sums = series.map(ascending_sum),\n      order = order_none(series).sort(function(a, b) { return sums[b] - sums[a]; }),\n      top = 0,\n      bottom = 0,\n      tops = [],\n      bottoms = [];\n\n  for (i = 0; i < n; ++i) {\n    j = order[i];\n    if (top < bottom) {\n      top += sums[j];\n      tops.push(j);\n    } else {\n      bottom += sums[j];\n      bottoms.push(j);\n    }\n  }\n\n  return bottoms.reverse().concat(tops);\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/order/reverse.js\n\n\n/* harmony default export */ var order_reverse = (function(series) {\n  return order_none(series).reverse();\n});\n\n// CONCATENATED MODULE: ./node_modules/d3-shape/src/index.js\n\n\n\n\n // Note: radialArea is deprecated!\n // Note: radialLine is deprecated!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// EXTERNAL MODULE: ./node_modules/@vx/group/dist/vx-group.es.js\nvar vx_group_es = __webpack_require__(104);\n\n// CONCATENATED MODULE: ./node_modules/@vx/point/dist/vx-point.es.js\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar Point = function () {\n  function Point(_ref) {\n    var _ref$x = _ref.x,\n        x = _ref$x === undefined ? 0 : _ref$x,\n        _ref$y = _ref.y,\n        y = _ref$y === undefined ? 0 : _ref$y;\n    classCallCheck(this, Point);\n\n    this.x = x;\n    this.y = y;\n  }\n\n  createClass(Point, [{\n    key: \"value\",\n    value: function value() {\n      return {\n        x: this.x,\n        y: this.y\n      };\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray$$1() {\n      return [this.x, this.y];\n    }\n  }]);\n  return Point;\n}();\n\n\n\n// CONCATENATED MODULE: ./node_modules/@vx/shape/dist/vx-shape.es.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Arc\", function() { return Arc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Pie\", function() { return Pie; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Line\", function() { return Line; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinePath\", function() { return LinePath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineRadial\", function() { return LineRadial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Area\", function() { return Area; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AreaClosed\", function() { return AreaClosed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AreaStack\", function() { return AreaStack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Bar\", function() { return Bar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BarGroup\", function() { return BarGroup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BarGroupHorizontal\", function() { return BarGroupHorizontal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BarStack\", function() { return BarStack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BarStackHorizontal\", function() { return BarStackHorizontal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Stack\", function() { return Stack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"callOrValue\", function() { return callOrValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stackOffset\", function() { return stackOffset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STACK_OFFSETS\", function() { return STACK_OFFSETS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STACK_OFFSET_NAMES\", function() { return STACK_OFFSET_NAMES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stackOrder\", function() { return stackOrder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STACK_ORDERS\", function() { return STACK_ORDERS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STACK_ORDER_NAMES\", function() { return STACK_ORDER_NAMES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"degreesToRadians\", function() { return degreesToRadians; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinkHorizontal\", function() { return LinkHorizontal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pathHorizontalDiagonal\", function() { return pathHorizontalDiagonal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinkVertical\", function() { return LinkVertical; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pathVerticalDiagonal\", function() { return pathVerticalDiagonal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinkRadial\", function() { return LinkRadial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pathRadialDiagonal\", function() { return pathRadialDiagonal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinkHorizontalCurve\", function() { return LinkHorizontalCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pathHorizontalCurve\", function() { return pathHorizontalCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinkVerticalCurve\", function() { return LinkVerticalCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pathVerticalCurve\", function() { return pathVerticalCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinkRadialCurve\", function() { return LinkRadialCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pathRadialCurve\", function() { return pathRadialCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinkHorizontalLine\", function() { return LinkHorizontalLine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pathHorizontalLine\", function() { return pathHorizontalLine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinkVerticalLine\", function() { return LinkVerticalLine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pathVerticalLine\", function() { return pathVerticalLine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinkRadialLine\", function() { return LinkRadialStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pathRadialLine\", function() { return pathRadialLine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinkHorizontalStep\", function() { return LinkHorizontalStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pathHorizontalStep\", function() { return pathHorizontalStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinkVerticalStep\", function() { return LinkVerticalStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pathVerticalStep\", function() { return pathVerticalStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinkRadialStep\", function() { return LinkRadialStep$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pathRadialStep\", function() { return pathRadialStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Polygon\", function() { return Polygon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPoints\", function() { return getPoints; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPoint\", function() { return vx_shape_es_getPoint; });\n\n\n\n\n\n\n\n\n\nfunction callOrValue(maybeFn, data) {\n  if (typeof maybeFn === 'function') {\n    return maybeFn(data);\n  }\n  return maybeFn;\n}\n\nfunction additionalProps(restProps, data) {\n  return Object.keys(restProps).reduce(function (ret, cur) {\n    ret[cur] = callOrValue(restProps[cur], data);\n    return ret;\n  }, {});\n}\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nArc.propTypes = {\n  className: prop_types_default.a.string,\n  data: prop_types_default.a.any,\n  centroid: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  innerRadius: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  outerRadius: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  cornerRadius: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  startAngle: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  endAngle: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  padAngle: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  padRadius: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number])\n};\n\nfunction Arc(_ref) {\n  var className = _ref.className,\n      data = _ref.data,\n      centroid = _ref.centroid,\n      innerRadius = _ref.innerRadius,\n      outerRadius = _ref.outerRadius,\n      cornerRadius = _ref.cornerRadius,\n      startAngle = _ref.startAngle,\n      endAngle = _ref.endAngle,\n      padAngle = _ref.padAngle,\n      padRadius = _ref.padRadius,\n      restProps = objectWithoutProperties(_ref, ['className', 'data', 'centroid', 'innerRadius', 'outerRadius', 'cornerRadius', 'startAngle', 'endAngle', 'padAngle', 'padRadius']);\n\n  var arc$$1 = src_arc();\n  if (centroid) arc$$1.centroid(centroid);\n  if (innerRadius) arc$$1.innerRadius(innerRadius);\n  if (outerRadius) arc$$1.outerRadius(outerRadius);\n  if (cornerRadius) arc$$1.cornerRadius(cornerRadius);\n  if (startAngle) arc$$1.startAngle(startAngle);\n  if (endAngle) arc$$1.endAngle(endAngle);\n  if (padAngle) arc$$1.padAngle(padAngle);\n  if (padRadius) arc$$1.padRadius(padRadius);\n  return react_default.a.createElement('path', _extends({ className: classnames_default()('vx-arc', className), d: arc$$1(data) }, additionalProps(restProps, data)));\n}\n\nPie.propTypes = {\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number,\n  data: prop_types_default.a.array,\n  centroid: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  innerRadius: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  outerRadius: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  cornerRadius: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  startAngle: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  endAngle: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  padAngle: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  padRadius: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  pieSort: prop_types_default.a.func,\n  pieSortValues: prop_types_default.a.func,\n  pieValue: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  children: prop_types_default.a.func\n};\n\nfunction Pie(_ref) {\n  var _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      data = _ref.data,\n      centroid = _ref.centroid,\n      _ref$innerRadius = _ref.innerRadius,\n      innerRadius = _ref$innerRadius === undefined ? 0 : _ref$innerRadius,\n      outerRadius = _ref.outerRadius,\n      cornerRadius = _ref.cornerRadius,\n      _ref$startAngle = _ref.startAngle,\n      startAngle = _ref$startAngle === undefined ? 0 : _ref$startAngle,\n      endAngle = _ref.endAngle,\n      padAngle = _ref.padAngle,\n      padRadius = _ref.padRadius,\n      pieSort = _ref.pieSort,\n      pieSortValues = _ref.pieSortValues,\n      pieValue = _ref.pieValue,\n      children = _ref.children,\n      restProps = objectWithoutProperties(_ref, ['className', 'top', 'left', 'data', 'centroid', 'innerRadius', 'outerRadius', 'cornerRadius', 'startAngle', 'endAngle', 'padAngle', 'padRadius', 'pieSort', 'pieSortValues', 'pieValue', 'children']);\n\n  var path$$1 = src_arc();\n  path$$1.innerRadius(innerRadius);\n  if (outerRadius) path$$1.outerRadius(outerRadius);\n  if (cornerRadius) path$$1.cornerRadius(cornerRadius);\n  if (padRadius) path$$1.padRadius(padRadius);\n  var pie$$1 = src_pie();\n  if (pieSort !== undefined) pie$$1.sort(pieSort);\n  if (pieSortValues !== undefined) pie$$1.sortValues(pieSortValues);\n  if (pieValue) pie$$1.value(pieValue);\n  if (padAngle != null) pie$$1.padAngle(padAngle);\n  if (startAngle != null) pie$$1.startAngle(startAngle);\n  if (endAngle != null) pie$$1.endAngle(endAngle);\n  var arcs = pie$$1(data);\n  var renderFunctionArg = {\n    arcs: arcs,\n    generatePathProps: function generatePathProps(arc$$1, index) {\n      return _extends({\n        className: classnames_default()('vx-pie-arc', className),\n        d: path$$1(arc$$1)\n      }, additionalProps(restProps, _extends({}, arc$$1, {\n        index: index,\n        centroid: centroid ? path$$1.centroid(arc$$1) : undefined\n      })));\n    },\n    generateCentroid: function generateCentroid(arc$$1) {\n      return centroid && centroid(path$$1.centroid(arc$$1), arc$$1);\n    }\n  };\n  return react_default.a.createElement(\n    vx_group_es[\"Group\"],\n    { className: 'vx-pie-arcs-group', top: top, left: left },\n    children ? children(renderFunctionArg) : arcs.map(function (arc$$1, i) {\n      var pathProps = renderFunctionArg.generatePathProps(arc$$1, i);\n      return react_default.a.createElement(\n        'g',\n        { key: 'pie-arc-' + i },\n        react_default.a.createElement('path', pathProps),\n        renderFunctionArg.generateCentroid(arc$$1)\n      );\n    })\n  );\n}\n\nLine.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction Line(_ref) {\n  var _ref$from = _ref.from,\n      from = _ref$from === undefined ? new Point({ x: 0, y: 0 }) : _ref$from,\n      _ref$to = _ref.to,\n      to = _ref$to === undefined ? new Point({ x: 1, y: 1 }) : _ref$to,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 1 : _ref$strokeWidth,\n      _ref$strokeDasharray = _ref.strokeDasharray,\n      strokeDasharray = _ref$strokeDasharray === undefined ? '' : _ref$strokeDasharray,\n      _ref$transform = _ref.transform,\n      transform = _ref$transform === undefined ? '' : _ref$transform,\n      _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      data = _ref.data,\n      innerRef = _ref.innerRef,\n      restProps = objectWithoutProperties(_ref, ['from', 'to', 'stroke', 'strokeWidth', 'strokeDasharray', 'transform', 'className', 'data', 'innerRef']);\n\n  return react_default.a.createElement('line', _extends({\n    ref: innerRef,\n    className: classnames_default()('vx-line', className),\n    x1: from.x,\n    y1: from.y,\n    x2: to.x,\n    y2: to.y,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    transform: transform\n  }, additionalProps(restProps, data)));\n}\n\nLinePath.propTypes = {\n  innerRef: prop_types_default.a.func,\n  xScale: prop_types_default.a.func,\n  yScale: prop_types_default.a.func,\n  data: prop_types_default.a.array,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  defined: prop_types_default.a.func,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  glyph: prop_types_default.a.func,\n  curve: prop_types_default.a.func\n};\n\nfunction LinePath(_ref) {\n  var children = _ref.children,\n      data = _ref.data,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      x = _ref.x,\n      y = _ref.y,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'steelblue' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$strokeDasharray = _ref.strokeDasharray,\n      strokeDasharray = _ref$strokeDasharray === undefined ? '' : _ref$strokeDasharray,\n      _ref$strokeDashoffset = _ref.strokeDashoffset,\n      strokeDashoffset = _ref$strokeDashoffset === undefined ? 0 : _ref$strokeDashoffset,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'none' : _ref$fill,\n      _ref$curve = _ref.curve,\n      curve = _ref$curve === undefined ? linear : _ref$curve,\n      glyph = _ref.glyph,\n      innerRef = _ref.innerRef,\n      restProps = objectWithoutProperties(_ref, ['children', 'data', 'xScale', 'yScale', 'x', 'y', 'defined', 'className', 'stroke', 'strokeWidth', 'strokeDasharray', 'strokeDashoffset', 'fill', 'curve', 'glyph', 'innerRef']);\n\n  var path$$1 = src_line().x(function () {\n    return xScale(x.apply(undefined, arguments));\n  }).y(function () {\n    return yScale(y.apply(undefined, arguments));\n  }).defined(defined).curve(curve);\n  if (children) return children({ path: path$$1 });\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', _extends({\n      ref: innerRef,\n      className: classnames_default()('vx-linepath', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      strokeDashoffset: strokeDashoffset,\n      fill: fill\n    }, additionalProps(restProps, data))),\n    glyph && react_default.a.createElement(\n      'g',\n      { className: 'vx-linepath-glyphs' },\n      data.map(glyph)\n    )\n  );\n}\n\nLineRadial.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction LineRadial(_ref) {\n  var _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      angle = _ref.angle,\n      radius = _ref.radius,\n      defined = _ref.defined,\n      curve = _ref.curve,\n      data = _ref.data,\n      innerRef = _ref.innerRef,\n      restProps = objectWithoutProperties(_ref, ['className', 'angle', 'radius', 'defined', 'curve', 'data', 'innerRef']);\n\n  var path$$1 = src_lineRadial();\n  if (angle) path$$1.angle(angle);\n  if (radius) path$$1.radius(radius);\n  if (defined) path$$1.defined(defined);\n  if (curve) path$$1.curve(curve);\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', _extends({\n      ref: innerRef,\n      className: classnames_default()('vx-line-radial', className),\n      d: path$$1(data)\n    }, additionalProps(restProps, data)))\n  );\n}\n\nArea.propTypes = {\n  x: prop_types_default.a.func,\n  x0: prop_types_default.a.func,\n  x1: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  y0: prop_types_default.a.func,\n  y1: prop_types_default.a.func,\n  xScale: prop_types_default.a.func,\n  yScale: prop_types_default.a.func,\n  data: prop_types_default.a.array,\n  defined: prop_types_default.a.func,\n  className: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.bool, prop_types_default.a.object, prop_types_default.a.array]),\n  innerRef: prop_types_default.a.func,\n  strokeDasharray: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  stroke: prop_types_default.a.string,\n  fill: prop_types_default.a.string,\n  curve: prop_types_default.a.func\n};\n\nfunction Area(_ref) {\n  var children = _ref.children,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y = _ref.y,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      _ref$data = _ref.data,\n      data = _ref$data === undefined ? [] : _ref$data,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      strokeDasharray = _ref.strokeDasharray,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'rgba(0,0,0,0.3)' : _ref$fill,\n      curve = _ref.curve,\n      innerRef = _ref.innerRef,\n      restProps = objectWithoutProperties(_ref, ['children', 'x', 'x0', 'x1', 'y', 'y0', 'y1', 'xScale', 'yScale', 'data', 'defined', 'className', 'strokeDasharray', 'strokeWidth', 'stroke', 'fill', 'curve', 'innerRef']);\n\n  var path$$1 = src_area();\n  if (x) path$$1.x(function () {\n    return xScale(x.apply(undefined, arguments));\n  });\n  if (x0) path$$1.x0(function () {\n    return xScale(x0.apply(undefined, arguments));\n  });\n  if (x1) path$$1.x1(function () {\n    return xScale(x1.apply(undefined, arguments));\n  });\n  if (y) path$$1.y(function () {\n    return yScale(y.apply(undefined, arguments));\n  });\n  if (y0) path$$1.y0(function () {\n    return yScale(y0.apply(undefined, arguments));\n  });\n  if (y1) path$$1.y1(function () {\n    return yScale(y1.apply(undefined, arguments));\n  });\n  if (defined) path$$1.defined(defined);\n  if (curve) path$$1.curve(curve);\n  if (children) return children({ path: path$$1 });\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', _extends({\n      ref: innerRef,\n      className: classnames_default()('vx-area', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      fill: fill\n    }, additionalProps(restProps, data)))\n  );\n}\n\nAreaClosed.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction AreaClosed(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      y0 = _ref.y0,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      data = _ref.data,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      strokeDasharray = _ref.strokeDasharray,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'rgba(0,0,0,0.3)' : _ref$fill,\n      curve = _ref.curve,\n      innerRef = _ref.innerRef,\n      restProps = objectWithoutProperties(_ref, ['x', 'y', 'y0', 'xScale', 'yScale', 'data', 'defined', 'className', 'strokeDasharray', 'strokeWidth', 'stroke', 'fill', 'curve', 'innerRef']);\n\n  var path$$1 = src_area().x(function () {\n    return xScale(x.apply(undefined, arguments));\n  }).y0(y0 || yScale.range()[0]).y1(function () {\n    return yScale(y.apply(undefined, arguments));\n  }).defined(defined);\n  if (curve) path$$1.curve(curve);\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', _extends({\n      ref: innerRef,\n      className: classnames_default()('vx-area-closed', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      fill: fill\n    }, additionalProps(restProps, data)))\n  );\n}\n\nAreaStack.propTypes = {\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number,\n  keys: prop_types_default.a.array,\n  data: prop_types_default.a.array,\n  curve: prop_types_default.a.func,\n  defined: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.bool]),\n  x: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  x0: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  x1: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  y: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  y0: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  y1: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  glyph: prop_types_default.a.bool,\n  reverse: prop_types_default.a.bool\n};\n\nfunction AreaStack(_ref) {\n  var className = _ref.className,\n      keys = _ref.keys,\n      data = _ref.data,\n      curve = _ref.curve,\n      defined = _ref.defined,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      glyph = _ref.glyph,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === undefined ? false : _ref$reverse,\n      restProps = objectWithoutProperties(_ref, ['className', 'keys', 'data', 'curve', 'defined', 'x', 'x0', 'x1', 'y0', 'y1', 'glyph', 'reverse']);\n\n  var stack$$1 = src_stack();\n  if (keys) stack$$1.keys(keys);\n\n  var path$$1 = src_area();\n  if (x) path$$1.x(x);\n  if (x0) path$$1.x0(x0);\n  if (x1) path$$1.x1(x1);\n  if (y0) path$$1.y0(y0);\n  if (y1) path$$1.y1(y1);\n  if (curve) path$$1.curve(curve);\n  if (defined) path$$1.defined(defined);\n\n  var seriesData = stack$$1(data);\n  if (reverse) seriesData.reverse();\n\n  return react_default.a.createElement(\n    'g',\n    null,\n    seriesData.map(function (series, i) {\n      return react_default.a.createElement('path', _extends({\n        className: classnames_default()('vx-area-stack', className),\n        key: 'area-stack-' + i + '-' + (series.key || ''),\n        d: path$$1(series)\n      }, additionalProps(restProps, {\n        datum: series[i],\n        index: i,\n        series: series\n      })));\n    }),\n    !!glyph && react_default.a.createElement(\n      'g',\n      { className: 'vx-area-stack-glyphs' },\n      data.map(glyph)\n    )\n  );\n}\n\nBar.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction Bar(_ref) {\n  var className = _ref.className,\n      innerRef = _ref.innerRef,\n      data = _ref.data,\n      _ref$x = _ref.x,\n      x = _ref$x === undefined ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === undefined ? 0 : _ref$y,\n      width = _ref.width,\n      height = _ref.height,\n      rx = _ref.rx,\n      ry = _ref.ry,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'steelblue' : _ref$fill,\n      fillOpacity = _ref.fillOpacity,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      strokeLinecap = _ref.strokeLinecap,\n      strokeLinejoin = _ref.strokeLinejoin,\n      strokeMiterlimit = _ref.strokeMiterlimit,\n      strokeOpacity = _ref.strokeOpacity,\n      restProps = objectWithoutProperties(_ref, ['className', 'innerRef', 'data', 'x', 'y', 'width', 'height', 'rx', 'ry', 'fill', 'fillOpacity', 'stroke', 'strokeWidth', 'strokeDasharray', 'strokeLinecap', 'strokeLinejoin', 'strokeMiterlimit', 'strokeOpacity']);\n\n  return react_default.a.createElement('rect', _extends({\n    ref: innerRef,\n    className: classnames_default()('vx-bar', className),\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    rx: rx,\n    ry: ry,\n    fill: fill,\n    fillOpacity: fillOpacity,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    strokeLinecap: strokeLinecap,\n    strokeLinejoin: strokeLinejoin,\n    strokeMiterlimit: strokeMiterlimit,\n    strokeOpacity: strokeOpacity\n  }, additionalProps(restProps, data)));\n}\n\nBarGroup.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  x0: prop_types_default.a.func.isRequired,\n  x0Scale: prop_types_default.a.func.isRequired,\n  x1Scale: prop_types_default.a.func.isRequired,\n  yScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  height: prop_types_default.a.number.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number\n};\n\nfunction BarGroup(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      x0 = _ref.x0,\n      x0Scale = _ref.x0Scale,\n      x1Scale = _ref.x1Scale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      height = _ref.height,\n      restProps = objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'x0', 'x0Scale', 'x1Scale', 'yScale', 'zScale', 'keys', 'height']);\n\n  var format = x0Scale.tickFormat ? x0Scale.tickFormat() : function (d) {\n    return d;\n  };\n  return react_default.a.createElement(\n    vx_group_es[\"Group\"],\n    { className: classnames_default()('vx-bar-group', className), top: top, left: left },\n    data && data.map(function (d, i) {\n      return react_default.a.createElement(\n        vx_group_es[\"Group\"],\n        { key: 'bar-group-' + i + '-' + x0(d), left: x0Scale(x0(d)) },\n        keys && keys.map(function (key, j) {\n          var value = d[key];\n          return react_default.a.createElement(Bar, _extends({\n            key: 'bar-group-bar-' + i + '-' + j + '-' + value + '-' + key,\n            x: x1Scale(key),\n            y: yScale(value),\n            width: x1Scale.bandwidth(),\n            height: height - yScale(value),\n            fill: zScale(key),\n            data: {\n              key: key,\n              value: value,\n              x: format(x0(d)),\n              data: d\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nBarGroupHorizontal.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  y0: prop_types_default.a.func.isRequired,\n  y0Scale: prop_types_default.a.func.isRequired,\n  y1Scale: prop_types_default.a.func.isRequired,\n  xScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  width: prop_types_default.a.number.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number\n};\n\nfunction BarGroupHorizontal(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      y0 = _ref.y0,\n      y0Scale = _ref.y0Scale,\n      y1Scale = _ref.y1Scale,\n      xScale = _ref.xScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      width = _ref.width,\n      restProps = objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'y0', 'y0Scale', 'y1Scale', 'xScale', 'zScale', 'keys', 'width']);\n\n  var format = y0Scale.tickFormat ? y0Scale.tickFormat() : function (d) {\n    return d;\n  };\n  return react_default.a.createElement(\n    vx_group_es[\"Group\"],\n    { className: classnames_default()('vx-bar-group-horizontal', className), top: top, left: left },\n    data && data.map(function (d, i) {\n      return react_default.a.createElement(\n        vx_group_es[\"Group\"],\n        { key: 'bar-group-' + i + '-' + y0(d), top: y0Scale(y0(d)) },\n        keys && keys.map(function (key, j) {\n          var value = d[key];\n          return react_default.a.createElement(Bar, _extends({\n            key: 'bar-group-bar-' + i + '-' + j + '-' + value + '-' + key,\n            x: 0,\n            y: y1Scale(key),\n            width: width - xScale(value),\n            height: y1Scale.bandwidth(),\n            fill: zScale(key),\n            data: {\n              key: key,\n              value: value,\n              y: format(y0(d)),\n              data: d\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nfunction objHasMethod(obj, funcName) {\n  return !!obj[funcName] && typeof obj[funcName] === 'function';\n}\n\nBarStack.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  x: prop_types_default.a.func.isRequired,\n  xScale: prop_types_default.a.func.isRequired,\n  yScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number,\n  width: prop_types_default.a.number,\n  height: prop_types_default.a.number\n};\n\nfunction BarStack(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      x = _ref.x,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      width = _ref.width,\n      height = _ref.height,\n      restProps = objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'x', 'xScale', 'yScale', 'zScale', 'keys', 'width', 'height']);\n\n  var series = src_stack().keys(keys)(data);\n  var format = xScale.tickFormat ? xScale.tickFormat() : function (d) {\n    return d;\n  };\n  var xRange = xScale.range();\n  var xDomain = xScale.domain();\n  return react_default.a.createElement(\n    vx_group_es[\"Group\"],\n    { className: classnames_default()('vx-bar-stack', className), top: top, left: left },\n    series && series.map(function (s, i) {\n      return react_default.a.createElement(\n        vx_group_es[\"Group\"],\n        { key: 'vx-bar-stack-' + i },\n        s.map(function (d, ii) {\n          var barHeight = yScale(d[0]) - yScale(d[1]);\n          var barWidth = width || (objHasMethod(xScale, 'bandwidth') ? xScale.bandwidth() : Math.abs(xRange[xRange.length - 1] - xRange[0]) / xDomain.length);\n\n          var barX = objHasMethod(xScale, 'bandwidth') ? xScale(x(d.data)) : xScale(x(d.data)) - barWidth / 2;\n          return react_default.a.createElement(Bar, _extends({\n            key: 'bar-group-bar-' + i + '-' + ii + '-' + s.key,\n            x: barX,\n            y: yScale(d[1]),\n            width: barWidth,\n            height: barHeight,\n            fill: zScale(s.key),\n            data: {\n              paddingInner: objHasMethod(xScale, 'paddingInner') && xScale.paddingInner(),\n              paddingOuter: objHasMethod(xScale, 'paddingOuter') && xScale.paddingOuter(),\n              step: objHasMethod(xScale, 'step') && xScale.step(),\n              key: s.key,\n              value: d[1],\n              height: barHeight,\n              width: barWidth,\n              x: x(d.data),\n              xFormatted: format(x(d.data)),\n              data: d.data\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nBarStackHorizontal.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  y: prop_types_default.a.func.isRequired,\n  xScale: prop_types_default.a.func.isRequired,\n  yScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number,\n  width: prop_types_default.a.number,\n  height: prop_types_default.a.number\n};\n\nfunction BarStackHorizontal(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      y = _ref.y,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      width = _ref.width,\n      height = _ref.height,\n      restProps = objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'y', 'xScale', 'yScale', 'zScale', 'keys', 'width', 'height']);\n\n  var series = src_stack().keys(keys)(data);\n  var format = yScale.tickFormat ? yScale.tickFormat() : function (d) {\n    return d;\n  };\n  var yRange = yScale.range();\n  var yDomain = yScale.domain();\n  return react_default.a.createElement(\n    vx_group_es[\"Group\"],\n    { className: classnames_default()('vx-bar-stack-horizontal', className), top: top, left: left },\n    series && series.map(function (s, i) {\n      return react_default.a.createElement(\n        vx_group_es[\"Group\"],\n        { key: 'vx-bar-stack-horizontal-' + i },\n        s.map(function (d, ii) {\n          var barWidth = xScale(d[1]) - xScale(d[0]);\n          var barHeight = width || (objHasMethod(yScale, 'bandwidth') ? yScale.bandwidth() : Math.abs(yRange[yRange.length - 1] - yRange[0]) / yDomain.length);\n\n          var barY = objHasMethod(yScale, 'bandwidth') ? yScale(y(d.data)) : yScale(y(d.data)) - barHeight / 2;\n          return react_default.a.createElement(Bar, _extends({\n            key: 'bar-group-bar-' + i + '-' + ii + '-' + s.key,\n            x: xScale(d[0]),\n            y: barY,\n            width: barWidth,\n            height: barHeight,\n            fill: zScale(s.key),\n            data: {\n              paddingInner: objHasMethod(yScale, 'paddingInner') && yScale.paddingInner(),\n              paddingOuter: objHasMethod(yScale, 'paddingOuter') && yScale.paddingOuter(),\n              step: objHasMethod(yScale, 'step') && yScale.step(),\n              key: s.key,\n              value: d[0],\n              height: barHeight,\n              width: barWidth,\n              y: y(d.data),\n              yFormatted: format(y(d.data)),\n              data: d.data\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nvar STACK_ORDERS = {\n  ascending: ascending,\n  descending: order_descending,\n  insideout: insideOut,\n  none: order_none,\n  reverse: order_reverse\n};\n\nvar STACK_ORDER_NAMES = Object.keys(STACK_ORDERS);\n\nfunction stackOrder(order) {\n  return STACK_ORDERS[order] || STACK_ORDERS.none;\n}\n\nvar STACK_OFFSETS = {\n  expand: expand,\n  diverging: diverging,\n  none: none,\n  silhouette: silhouette,\n  wiggle: wiggle\n};\n\nvar STACK_OFFSET_NAMES = Object.keys(STACK_OFFSETS);\n\nfunction stackOffset(offset) {\n  return STACK_OFFSETS[offset] || STACK_OFFSETS.none;\n}\n\nStack.propTypes = {\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number,\n  keys: prop_types_default.a.array,\n  data: prop_types_default.a.array,\n  curve: prop_types_default.a.func,\n  defined: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.bool]),\n  x: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  x0: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  x1: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  y: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  y0: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  y1: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  value: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  order: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.array, prop_types_default.a.string]),\n  offset: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.array, prop_types_default.a.string]),\n  render: prop_types_default.a.func,\n  reverse: prop_types_default.a.bool\n};\n\nfunction Stack(_ref) {\n  var className = _ref.className,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      keys = _ref.keys,\n      data = _ref.data,\n      curve = _ref.curve,\n      defined = _ref.defined,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      value = _ref.value,\n      order = _ref.order,\n      offset = _ref.offset,\n      render = _ref.render,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === undefined ? false : _ref$reverse,\n      restProps = objectWithoutProperties(_ref, ['className', 'top', 'left', 'keys', 'data', 'curve', 'defined', 'x', 'x0', 'x1', 'y0', 'y1', 'value', 'order', 'offset', 'render', 'reverse']);\n\n  var stack$$1 = src_stack();\n  if (keys) stack$$1.keys(keys);\n  if (value) stack$$1.value(value);\n  if (order) stack$$1.order(stackOrder(order));\n  if (offset) stack$$1.offset(stackOffset(offset));\n\n  var path$$1 = src_area();\n  if (x) path$$1.x(x);\n  if (x0) path$$1.x0(x0);\n  if (x1) path$$1.x1(x1);\n  if (y0) path$$1.y0(y0);\n  if (y1) path$$1.y1(y1);\n  if (curve) path$$1.curve(curve);\n  if (defined) path$$1.defined(defined);\n\n  var seriesData = stack$$1(data);\n  if (reverse) seriesData.reverse();\n\n  if (render) {\n    return react_default.a.createElement(\n      vx_group_es[\"Group\"],\n      { top: top, left: left },\n      render({ seriesData: seriesData, path: path$$1 })\n    );\n  }\n\n  return react_default.a.createElement(\n    vx_group_es[\"Group\"],\n    { top: top, left: left },\n    seriesData.map(function (series, i) {\n      return react_default.a.createElement('path', _extends({\n        className: classnames_default()('vx-stack', className),\n        key: 'stack-' + i + '-' + (series.key || ''),\n        d: path$$1(series)\n      }, additionalProps(restProps, {\n        datum: series[i],\n        index: i,\n        series: series\n      })));\n    })\n  );\n}\n\nvar degreesToRadians = function degreesToRadians(degrees) {\n  return Math.PI / 180 * degrees;\n};\n\nfunction pathHorizontalDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var link = linkHorizontal();\n    link.x(x);\n    link.y(y);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nLinkHorizontal.propTypes = {\n  innerRef: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkHorizontal(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathHorizontalDiagonal({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link-horizontal', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var link = linkVertical();\n    link.x(x);\n    link.y(y);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nLinkVertical.propTypes = {\n  innerRef: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkVertical(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathVerticalDiagonal({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link-vertical', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      angle = _ref.angle,\n      radius = _ref.radius;\n\n  return function (data) {\n    var link = linkRadial();\n    link.angle(angle);\n    link.radius(radius);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nLinkRadial.propTypes = {\n  innerRef: prop_types_default.a.func,\n  angle: prop_types_default.a.func,\n  radius: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkRadial(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$angle = _ref2.angle,\n      angle = _ref2$angle === undefined ? function (d) {\n    return d.x;\n  } : _ref2$angle,\n      _ref2$radius = _ref2.radius,\n      radius = _ref2$radius === undefined ? function (d) {\n    return d.y;\n  } : _ref2$radius,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'angle', 'radius', 'source', 'target']);\n\n  path$$1 = path$$1 || pathRadialDiagonal({ source: source, target: target, angle: angle, radius: radius });\n  return react_default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link-radius', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathHorizontalCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = src_path();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkHorizontalCurve.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkHorizontalCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || pathHorizontalCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = src_path();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkVerticalCurve.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkVerticalCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || pathVerticalCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sa = x(sourceData) - Math.PI / 2;\n    var sr = y(sourceData);\n    var ta = x(targetData) - Math.PI / 2;\n    var tr = y(targetData);\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n\n    var sx = sr * sc;\n    var sy = sr * ss;\n    var tx = tr * tc;\n    var ty = tr * ts;\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = src_path();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkRadialCurve.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkRadialCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || pathRadialCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathHorizontalLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = src_path();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkHorizontalLine.propTypes = {\n  innerRef: prop_types_default.a.func,\n  path: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func\n};\n\nfunction LinkHorizontalLine(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathHorizontalLine({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = src_path();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkVerticalLine.propTypes = {\n  innerRef: prop_types_default.a.func,\n  path: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func\n};\n\nfunction LinkVerticalLine(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathVerticalLine({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sa = x(sourceData) - Math.PI / 2;\n    var sr = y(sourceData);\n    var ta = x(targetData) - Math.PI / 2;\n    var tr = y(targetData);\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n\n    var path$$1 = src_path();\n    path$$1.moveTo(sr * sc, sr * ss);\n    path$$1.lineTo(tr * tc, tr * ts);\n\n    return path$$1.toString();\n  };\n}\n\nLinkRadialStep.propTypes = {\n  innerRef: prop_types_default.a.func,\n  path: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func\n};\n\nfunction LinkRadialStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathRadialLine({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathHorizontalStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = src_path();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(sx + (tx - sx) * percent, sy);\n    path$$1.lineTo(sx + (tx - sx) * percent, ty);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkHorizontalStep.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkHorizontalStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.5 : _ref2$percent,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'percent', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathHorizontalStep({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = src_path();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(sx, sy + (ty - sy) * percent);\n    path$$1.lineTo(tx, sy + (ty - sy) * percent);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkVerticalStep.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkVerticalStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.5 : _ref2$percent,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'percent', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathVerticalStep({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var sa = sx - Math.PI / 2;\n    var sr = sy;\n    var ta = tx - Math.PI / 2;\n    var tr = ty;\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n    var sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n\n    return '\\n      M' + sr * sc + ',' + sr * ss + '\\n      A' + sr + ',' + sr + ',0,0,' + (sf ? 1 : 0) + ',' + sr * tc + ',' + sr * ts + '\\n      L' + tr * tc + ',' + tr * ts + '\\n    ';\n  };\n}\n\nLinkRadialStep$1.propTypes = {\n  innerRef: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkRadialStep$1(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathRadialStep({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nPolygon.propTypes = {\n  sides: prop_types_default.a.number.isRequired,\n  size: prop_types_default.a.number.isRequired,\n  className: prop_types_default.a.string,\n  rotate: prop_types_default.a.number\n};\n\nvar vx_shape_es_getPoint = function getPoint(_ref) {\n  var sides = _ref.sides,\n      size = _ref.size,\n      center = _ref.center,\n      rotate = _ref.rotate,\n      side = _ref.side;\n\n  var degrees = 360 / sides * side - rotate;\n  var radians = degreesToRadians(degrees);\n\n  return new Point({\n    x: center.x + size * Math.cos(radians),\n    y: center.y + size * Math.sin(radians)\n  });\n};\n\nvar getPoints = function getPoints(_ref2) {\n  var sides = _ref2.sides,\n      size = _ref2.size,\n      center = _ref2.center,\n      rotate = _ref2.rotate;\n\n  return [].concat(toConsumableArray(Array(sides).keys())).map(function (side) {\n    return vx_shape_es_getPoint({\n      sides: sides,\n      size: size,\n      center: center,\n      rotate: rotate,\n      side: side\n    });\n  });\n};\n\nfunction Polygon(_ref3) {\n  var sides = _ref3.sides,\n      _ref3$size = _ref3.size,\n      size = _ref3$size === undefined ? 25 : _ref3$size,\n      _ref3$center = _ref3.center,\n      center = _ref3$center === undefined ? new Point({ x: 0, y: 0 }) : _ref3$center,\n      _ref3$rotate = _ref3.rotate,\n      rotate = _ref3$rotate === undefined ? 0 : _ref3$rotate,\n      className = _ref3.className,\n      restProps = objectWithoutProperties(_ref3, ['sides', 'size', 'center', 'rotate', 'className']);\n\n  var points = getPoints({\n    sides: sides,\n    size: size,\n    center: center,\n    rotate: rotate\n  }).map(function (p) {\n    return p.toArray();\n  }).join(' ');\n\n  return react_default.a.createElement('polygon', _extends({ points: points, className: classnames_default()('vx-polygon', className) }, restProps));\n}\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtcGF0aC9zcmMvcGF0aC5qcz9lYWRjIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1wYXRoL3NyYy9pbmRleC5qcz9mMzdjIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY29uc3RhbnQuanM/ZDhhZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL21hdGguanM/MDk4NiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2FyYy5qcz82NTBjIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvbGluZWFyLmpzPzQ4MzAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9wb2ludC5qcz9mZGE0Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvbGluZS5qcz9mYWU4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJlYS5qcz9lMzhjIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvZGVzY2VuZGluZy5qcz84ODQ3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvaWRlbnRpdHkuanM/MTkwNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3BpZS5qcz84OGYxIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvcmFkaWFsLmpzPzI2NzAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9saW5lUmFkaWFsLmpzPzRjOGQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9hcmVhUmFkaWFsLmpzPzFhOTQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9wb2ludFJhZGlhbC5qcz8xMzI0Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJyYXkuanM/ODJhYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2xpbmsvaW5kZXguanM/MWE4OCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9jaXJjbGUuanM/MWFmMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9jcm9zcy5qcz9hMGFjIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2RpYW1vbmQuanM/OWFjZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9zdGFyLmpzPzA4MDMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvc3F1YXJlLmpzP2Q1YTciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvdHJpYW5nbGUuanM/YWU0MCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC93eWUuanM/YzQ5NCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC5qcz85MTUwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvbm9vcC5qcz9kMGFlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvYmFzaXMuanM/OGM4MCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2Jhc2lzQ2xvc2VkLmpzPzlhZTYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9iYXNpc09wZW4uanM/ZDY3NSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2J1bmRsZS5qcz83Nzg0Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvY2FyZGluYWwuanM/Nzc5MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhcmRpbmFsQ2xvc2VkLmpzPzNiNGQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXJkaW5hbE9wZW4uanM/YjBhZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhdG11bGxSb20uanM/MjljOCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhdG11bGxSb21DbG9zZWQuanM/NTY0NCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhdG11bGxSb21PcGVuLmpzPzQzOGQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9saW5lYXJDbG9zZWQuanM/Y2MzZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL21vbm90b25lLmpzP2E0YmQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9uYXR1cmFsLmpzP2E4NGQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9zdGVwLmpzPzdiZDYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vZmZzZXQvbm9uZS5qcz9kMTNlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb3JkZXIvbm9uZS5qcz9hYWFhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3RhY2suanM/YzA4YiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29mZnNldC9leHBhbmQuanM/MWEzNCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29mZnNldC9kaXZlcmdpbmcuanM/ZTFiOSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29mZnNldC9zaWxob3VldHRlLmpzPzM2ZGMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vZmZzZXQvd2lnZ2xlLmpzP2YxZTIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9vcmRlci9hc2NlbmRpbmcuanM/NWFlMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29yZGVyL2Rlc2NlbmRpbmcuanM/ZjVjZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL29yZGVyL2luc2lkZU91dC5qcz8zYThlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvb3JkZXIvcmV2ZXJzZS5qcz81MDU2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvaW5kZXguanM/ZjFkZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ4L3BvaW50L2Rpc3QvdngtcG9pbnQuZXMuanM/ZDA4YiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ4L3NoYXBlL2Rpc3Qvdngtc2hhcGUuZXMuanM/NzliMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FB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QUNBO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSyxFQUFFLGFBQWE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7O0FBRUgsU0FBUyxlQUFLLG9DQUFvQyw0QkFBNEIsb0JBQUUsMkJBQTJCO0FBQzNHOztBQUUyd0IiLCJmaWxlIjoiNDcwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHBpID0gTWF0aC5QSSxcbiAgICB0YXUgPSAyICogcGksXG4gICAgZXBzaWxvbiA9IDFlLTYsXG4gICAgdGF1RXBzaWxvbiA9IHRhdSAtIGVwc2lsb247XG5cbmZ1bmN0aW9uIFBhdGgoKSB7XG4gIHRoaXMuX3gwID0gdGhpcy5feTAgPSAvLyBzdGFydCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgdGhpcy5feDEgPSB0aGlzLl95MSA9IG51bGw7IC8vIGVuZCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgdGhpcy5fID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gcGF0aCgpIHtcbiAgcmV0dXJuIG5ldyBQYXRoO1xufVxuXG5QYXRoLnByb3RvdHlwZSA9IHBhdGgucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUGF0aCxcbiAgbW92ZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl94MSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5feDEgPSB0aGlzLl94MCwgdGhpcy5feTEgPSB0aGlzLl95MDtcbiAgICAgIHRoaXMuXyArPSBcIlpcIjtcbiAgICB9XG4gIH0sXG4gIGxpbmVUbzogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIkxcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gXCJRXCIgKyAoK3gxKSArIFwiLFwiICsgKCt5MSkgKyBcIixcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIkNcIiArICgreDEpICsgXCIsXCIgKyAoK3kxKSArIFwiLFwiICsgKCt4MikgKyBcIixcIiArICgreTIpICsgXCIsXCIgKyAodGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MSA9ICt5KTtcbiAgfSxcbiAgYXJjVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCByKSB7XG4gICAgeDEgPSAreDEsIHkxID0gK3kxLCB4MiA9ICt4MiwgeTIgPSAreTIsIHIgPSArcjtcbiAgICB2YXIgeDAgPSB0aGlzLl94MSxcbiAgICAgICAgeTAgPSB0aGlzLl95MSxcbiAgICAgICAgeDIxID0geDIgLSB4MSxcbiAgICAgICAgeTIxID0geTIgLSB5MSxcbiAgICAgICAgeDAxID0geDAgLSB4MSxcbiAgICAgICAgeTAxID0geTAgLSB5MSxcbiAgICAgICAgbDAxXzIgPSB4MDEgKiB4MDEgKyB5MDEgKiB5MDE7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyByKTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDEseTEpLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gxID0geDEpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MSk7XG4gICAgfVxuXG4gICAgLy8gT3IsIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4MCx5MCk/IERvIG5vdGhpbmcuXG4gICAgZWxzZSBpZiAoIShsMDFfMiA+IGVwc2lsb24pKTtcblxuICAgIC8vIE9yLCBhcmUgKHgwLHkwKSwgKHgxLHkxKSBhbmQgKHgyLHkyKSBjb2xsaW5lYXI/XG4gICAgLy8gRXF1aXZhbGVudGx5LCBpcyAoeDEseTEpIGNvaW5jaWRlbnQgd2l0aCAoeDIseTIpP1xuICAgIC8vIE9yLCBpcyB0aGUgcmFkaXVzIHplcm8/IExpbmUgdG8gKHgxLHkxKS5cbiAgICBlbHNlIGlmICghKE1hdGguYWJzKHkwMSAqIHgyMSAtIHkyMSAqIHgwMSkgPiBlcHNpbG9uKSB8fCAhcikge1xuICAgICAgdGhpcy5fICs9IFwiTFwiICsgKHRoaXMuX3gxID0geDEpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MSk7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBkcmF3IGFuIGFyYyFcbiAgICBlbHNlIHtcbiAgICAgIHZhciB4MjAgPSB4MiAtIHgwLFxuICAgICAgICAgIHkyMCA9IHkyIC0geTAsXG4gICAgICAgICAgbDIxXzIgPSB4MjEgKiB4MjEgKyB5MjEgKiB5MjEsXG4gICAgICAgICAgbDIwXzIgPSB4MjAgKiB4MjAgKyB5MjAgKiB5MjAsXG4gICAgICAgICAgbDIxID0gTWF0aC5zcXJ0KGwyMV8yKSxcbiAgICAgICAgICBsMDEgPSBNYXRoLnNxcnQobDAxXzIpLFxuICAgICAgICAgIGwgPSByICogTWF0aC50YW4oKHBpIC0gTWF0aC5hY29zKChsMjFfMiArIGwwMV8yIC0gbDIwXzIpIC8gKDIgKiBsMjEgKiBsMDEpKSkgLyAyKSxcbiAgICAgICAgICB0MDEgPSBsIC8gbDAxLFxuICAgICAgICAgIHQyMSA9IGwgLyBsMjE7XG5cbiAgICAgIC8vIElmIHRoZSBzdGFydCB0YW5nZW50IGlzIG5vdCBjb2luY2lkZW50IHdpdGggKHgwLHkwKSwgbGluZSB0by5cbiAgICAgIGlmIChNYXRoLmFicyh0MDEgLSAxKSA+IGVwc2lsb24pIHtcbiAgICAgICAgdGhpcy5fICs9IFwiTFwiICsgKHgxICsgdDAxICogeDAxKSArIFwiLFwiICsgKHkxICsgdDAxICogeTAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMCxcIiArICgrKHkwMSAqIHgyMCA+IHgwMSAqIHkyMCkpICsgXCIsXCIgKyAodGhpcy5feDEgPSB4MSArIHQyMSAqIHgyMSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxICsgdDIxICogeTIxKTtcbiAgICB9XG4gIH0sXG4gIGFyYzogZnVuY3Rpb24oeCwgeSwgciwgYTAsIGExLCBjY3cpIHtcbiAgICB4ID0gK3gsIHkgPSAreSwgciA9ICtyO1xuICAgIHZhciBkeCA9IHIgKiBNYXRoLmNvcyhhMCksXG4gICAgICAgIGR5ID0gciAqIE1hdGguc2luKGEwKSxcbiAgICAgICAgeDAgPSB4ICsgZHgsXG4gICAgICAgIHkwID0geSArIGR5LFxuICAgICAgICBjdyA9IDEgXiBjY3csXG4gICAgICAgIGRhID0gY2N3ID8gYTAgLSBhMSA6IGExIC0gYTA7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyByKTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDAseTApLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIE9yLCBpcyAoeDAseTApIG5vdCBjb2luY2lkZW50IHdpdGggdGhlIHByZXZpb3VzIHBvaW50PyBMaW5lIHRvICh4MCx5MCkuXG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB4MCkgPiBlcHNpbG9uIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0geTApID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiTFwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIElzIHRoaXMgYXJjIGVtcHR5PyBXZeKAmXJlIGRvbmUuXG4gICAgaWYgKCFyKSByZXR1cm47XG5cbiAgICAvLyBEb2VzIHRoZSBhbmdsZSBnbyB0aGUgd3Jvbmcgd2F5PyBGbGlwIHRoZSBkaXJlY3Rpb24uXG4gICAgaWYgKGRhIDwgMCkgZGEgPSBkYSAlIHRhdSArIHRhdTtcblxuICAgIC8vIElzIHRoaXMgYSBjb21wbGV0ZSBjaXJjbGU/IERyYXcgdHdvIGFyY3MgdG8gY29tcGxldGUgdGhlIGNpcmNsZS5cbiAgICBpZiAoZGEgPiB0YXVFcHNpbG9uKSB7XG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwxLFwiICsgY3cgKyBcIixcIiArICh4IC0gZHgpICsgXCIsXCIgKyAoeSAtIGR5KSArIFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMSxcIiArIGN3ICsgXCIsXCIgKyAodGhpcy5feDEgPSB4MCkgKyBcIixcIiArICh0aGlzLl95MSA9IHkwKTtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGlzIGFyYyBub24tZW1wdHk/IERyYXcgYW4gYXJjIVxuICAgIGVsc2UgaWYgKGRhID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsXCIgKyAoKyhkYSA+PSBwaSkpICsgXCIsXCIgKyBjdyArIFwiLFwiICsgKHRoaXMuX3gxID0geCArIHIgKiBNYXRoLmNvcyhhMSkpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5ICsgciAqIE1hdGguc2luKGExKSk7XG4gICAgfVxuICB9LFxuICByZWN0OiBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpICsgXCJoXCIgKyAoK3cpICsgXCJ2XCIgKyAoK2gpICsgXCJoXCIgKyAoLXcpICsgXCJaXCI7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYXRoO1xuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIHBhdGh9IGZyb20gXCIuL3BhdGhcIjtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN0YW50KCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiZXhwb3J0IHZhciBhYnMgPSBNYXRoLmFicztcbmV4cG9ydCB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuZXhwb3J0IHZhciBjb3MgPSBNYXRoLmNvcztcbmV4cG9ydCB2YXIgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgdmFyIG1pbiA9IE1hdGgubWluO1xuZXhwb3J0IHZhciBzaW4gPSBNYXRoLnNpbjtcbmV4cG9ydCB2YXIgc3FydCA9IE1hdGguc3FydDtcblxuZXhwb3J0IHZhciBlcHNpbG9uID0gMWUtMTI7XG5leHBvcnQgdmFyIHBpID0gTWF0aC5QSTtcbmV4cG9ydCB2YXIgaGFsZlBpID0gcGkgLyAyO1xuZXhwb3J0IHZhciB0YXUgPSAyICogcGk7XG5cbmV4cG9ydCBmdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNpbih4KSB7XG4gIHJldHVybiB4ID49IDEgPyBoYWxmUGkgOiB4IDw9IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbn1cbiIsImltcG9ydCB7cGF0aH0gZnJvbSBcImQzLXBhdGhcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudFwiO1xuaW1wb3J0IHthYnMsIGFjb3MsIGFzaW4sIGF0YW4yLCBjb3MsIGVwc2lsb24sIGhhbGZQaSwgbWF4LCBtaW4sIHBpLCBzaW4sIHNxcnQsIHRhdX0gZnJvbSBcIi4vbWF0aFwiO1xuXG5mdW5jdGlvbiBhcmNJbm5lclJhZGl1cyhkKSB7XG4gIHJldHVybiBkLmlubmVyUmFkaXVzO1xufVxuXG5mdW5jdGlvbiBhcmNPdXRlclJhZGl1cyhkKSB7XG4gIHJldHVybiBkLm91dGVyUmFkaXVzO1xufVxuXG5mdW5jdGlvbiBhcmNTdGFydEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQuc3RhcnRBbmdsZTtcbn1cblxuZnVuY3Rpb24gYXJjRW5kQW5nbGUoZCkge1xuICByZXR1cm4gZC5lbmRBbmdsZTtcbn1cblxuZnVuY3Rpb24gYXJjUGFkQW5nbGUoZCkge1xuICByZXR1cm4gZCAmJiBkLnBhZEFuZ2xlOyAvLyBOb3RlOiBvcHRpb25hbCFcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICB2YXIgeDEwID0geDEgLSB4MCwgeTEwID0geTEgLSB5MCxcbiAgICAgIHgzMiA9IHgzIC0geDIsIHkzMiA9IHkzIC0geTIsXG4gICAgICB0ID0gKHgzMiAqICh5MCAtIHkyKSAtIHkzMiAqICh4MCAtIHgyKSkgLyAoeTMyICogeDEwIC0geDMyICogeTEwKTtcbiAgcmV0dXJuIFt4MCArIHQgKiB4MTAsIHkwICsgdCAqIHkxMF07XG59XG5cbi8vIENvbXB1dGUgcGVycGVuZGljdWxhciBvZmZzZXQgbGluZSBvZiBsZW5ndGggcmMuXG4vLyBodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0NpcmNsZS1MaW5lSW50ZXJzZWN0aW9uLmh0bWxcbmZ1bmN0aW9uIGNvcm5lclRhbmdlbnRzKHgwLCB5MCwgeDEsIHkxLCByMSwgcmMsIGN3KSB7XG4gIHZhciB4MDEgPSB4MCAtIHgxLFxuICAgICAgeTAxID0geTAgLSB5MSxcbiAgICAgIGxvID0gKGN3ID8gcmMgOiAtcmMpIC8gc3FydCh4MDEgKiB4MDEgKyB5MDEgKiB5MDEpLFxuICAgICAgb3ggPSBsbyAqIHkwMSxcbiAgICAgIG95ID0gLWxvICogeDAxLFxuICAgICAgeDExID0geDAgKyBveCxcbiAgICAgIHkxMSA9IHkwICsgb3ksXG4gICAgICB4MTAgPSB4MSArIG94LFxuICAgICAgeTEwID0geTEgKyBveSxcbiAgICAgIHgwMCA9ICh4MTEgKyB4MTApIC8gMixcbiAgICAgIHkwMCA9ICh5MTEgKyB5MTApIC8gMixcbiAgICAgIGR4ID0geDEwIC0geDExLFxuICAgICAgZHkgPSB5MTAgLSB5MTEsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgciA9IHIxIC0gcmMsXG4gICAgICBEID0geDExICogeTEwIC0geDEwICogeTExLFxuICAgICAgZCA9IChkeSA8IDAgPyAtMSA6IDEpICogc3FydChtYXgoMCwgciAqIHIgKiBkMiAtIEQgKiBEKSksXG4gICAgICBjeDAgPSAoRCAqIGR5IC0gZHggKiBkKSAvIGQyLFxuICAgICAgY3kwID0gKC1EICogZHggLSBkeSAqIGQpIC8gZDIsXG4gICAgICBjeDEgPSAoRCAqIGR5ICsgZHggKiBkKSAvIGQyLFxuICAgICAgY3kxID0gKC1EICogZHggKyBkeSAqIGQpIC8gZDIsXG4gICAgICBkeDAgPSBjeDAgLSB4MDAsXG4gICAgICBkeTAgPSBjeTAgLSB5MDAsXG4gICAgICBkeDEgPSBjeDEgLSB4MDAsXG4gICAgICBkeTEgPSBjeTEgLSB5MDA7XG5cbiAgLy8gUGljayB0aGUgY2xvc2VyIG9mIHRoZSB0d28gaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgLy8gVE9ETyBJcyB0aGVyZSBhIGZhc3RlciB3YXkgdG8gZGV0ZXJtaW5lIHdoaWNoIGludGVyc2VjdGlvbiB0byB1c2U/XG4gIGlmIChkeDAgKiBkeDAgKyBkeTAgKiBkeTAgPiBkeDEgKiBkeDEgKyBkeTEgKiBkeTEpIGN4MCA9IGN4MSwgY3kwID0gY3kxO1xuXG4gIHJldHVybiB7XG4gICAgY3g6IGN4MCxcbiAgICBjeTogY3kwLFxuICAgIHgwMTogLW94LFxuICAgIHkwMTogLW95LFxuICAgIHgxMTogY3gwICogKHIxIC8gciAtIDEpLFxuICAgIHkxMTogY3kwICogKHIxIC8gciAtIDEpXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5uZXJSYWRpdXMgPSBhcmNJbm5lclJhZGl1cyxcbiAgICAgIG91dGVyUmFkaXVzID0gYXJjT3V0ZXJSYWRpdXMsXG4gICAgICBjb3JuZXJSYWRpdXMgPSBjb25zdGFudCgwKSxcbiAgICAgIHBhZFJhZGl1cyA9IG51bGwsXG4gICAgICBzdGFydEFuZ2xlID0gYXJjU3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlID0gYXJjRW5kQW5nbGUsXG4gICAgICBwYWRBbmdsZSA9IGFyY1BhZEFuZ2xlLFxuICAgICAgY29udGV4dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gYXJjKCkge1xuICAgIHZhciBidWZmZXIsXG4gICAgICAgIHIsXG4gICAgICAgIHIwID0gK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHIxID0gK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIGEwID0gc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpLFxuICAgICAgICBhMSA9IGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmUGksXG4gICAgICAgIGRhID0gYWJzKGExIC0gYTApLFxuICAgICAgICBjdyA9IGExID4gYTA7XG5cbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoKCk7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgb3V0ZXIgcmFkaXVzIGlzIGFsd2F5cyBsYXJnZXIgdGhhbiB0aGUgaW5uZXIgcmFkaXVzLlxuICAgIGlmIChyMSA8IHIwKSByID0gcjEsIHIxID0gcjAsIHIwID0gcjtcblxuICAgIC8vIElzIGl0IGEgcG9pbnQ/XG4gICAgaWYgKCEocjEgPiBlcHNpbG9uKSkgY29udGV4dC5tb3ZlVG8oMCwgMCk7XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmNsZSBvciBhbm51bHVzP1xuICAgIGVsc2UgaWYgKGRhID4gdGF1IC0gZXBzaWxvbikge1xuICAgICAgY29udGV4dC5tb3ZlVG8ocjEgKiBjb3MoYTApLCByMSAqIHNpbihhMCkpO1xuICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwLCBhMSwgIWN3KTtcbiAgICAgIGlmIChyMCA+IGVwc2lsb24pIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocjAgKiBjb3MoYTEpLCByMCAqIHNpbihhMSkpO1xuICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMCwgYTEsIGEwLCBjdyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3IgaXMgaXQgYSBjaXJjdWxhciBvciBhbm51bGFyIHNlY3Rvcj9cbiAgICBlbHNlIHtcbiAgICAgIHZhciBhMDEgPSBhMCxcbiAgICAgICAgICBhMTEgPSBhMSxcbiAgICAgICAgICBhMDAgPSBhMCxcbiAgICAgICAgICBhMTAgPSBhMSxcbiAgICAgICAgICBkYTAgPSBkYSxcbiAgICAgICAgICBkYTEgPSBkYSxcbiAgICAgICAgICBhcCA9IHBhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLyAyLFxuICAgICAgICAgIHJwID0gKGFwID4gZXBzaWxvbikgJiYgKHBhZFJhZGl1cyA/ICtwYWRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHNxcnQocjAgKiByMCArIHIxICogcjEpKSxcbiAgICAgICAgICByYyA9IG1pbihhYnMocjEgLSByMCkgLyAyLCArY29ybmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLFxuICAgICAgICAgIHJjMCA9IHJjLFxuICAgICAgICAgIHJjMSA9IHJjLFxuICAgICAgICAgIHQwLFxuICAgICAgICAgIHQxO1xuXG4gICAgICAvLyBBcHBseSBwYWRkaW5nPyBOb3RlIHRoYXQgc2luY2UgcjEg4omlIHIwLCBkYTEg4omlIGRhMC5cbiAgICAgIGlmIChycCA+IGVwc2lsb24pIHtcbiAgICAgICAgdmFyIHAwID0gYXNpbihycCAvIHIwICogc2luKGFwKSksXG4gICAgICAgICAgICBwMSA9IGFzaW4ocnAgLyByMSAqIHNpbihhcCkpO1xuICAgICAgICBpZiAoKGRhMCAtPSBwMCAqIDIpID4gZXBzaWxvbikgcDAgKj0gKGN3ID8gMSA6IC0xKSwgYTAwICs9IHAwLCBhMTAgLT0gcDA7XG4gICAgICAgIGVsc2UgZGEwID0gMCwgYTAwID0gYTEwID0gKGEwICsgYTEpIC8gMjtcbiAgICAgICAgaWYgKChkYTEgLT0gcDEgKiAyKSA+IGVwc2lsb24pIHAxICo9IChjdyA/IDEgOiAtMSksIGEwMSArPSBwMSwgYTExIC09IHAxO1xuICAgICAgICBlbHNlIGRhMSA9IDAsIGEwMSA9IGExMSA9IChhMCArIGExKSAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciB4MDEgPSByMSAqIGNvcyhhMDEpLFxuICAgICAgICAgIHkwMSA9IHIxICogc2luKGEwMSksXG4gICAgICAgICAgeDEwID0gcjAgKiBjb3MoYTEwKSxcbiAgICAgICAgICB5MTAgPSByMCAqIHNpbihhMTApO1xuXG4gICAgICAvLyBBcHBseSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBpZiAocmMgPiBlcHNpbG9uKSB7XG4gICAgICAgIHZhciB4MTEgPSByMSAqIGNvcyhhMTEpLFxuICAgICAgICAgICAgeTExID0gcjEgKiBzaW4oYTExKSxcbiAgICAgICAgICAgIHgwMCA9IHIwICogY29zKGEwMCksXG4gICAgICAgICAgICB5MDAgPSByMCAqIHNpbihhMDApO1xuXG4gICAgICAgIC8vIFJlc3RyaWN0IHRoZSBjb3JuZXIgcmFkaXVzIGFjY29yZGluZyB0byB0aGUgc2VjdG9yIGFuZ2xlLlxuICAgICAgICBpZiAoZGEgPCBwaSkge1xuICAgICAgICAgIHZhciBvYyA9IGRhMCA+IGVwc2lsb24gPyBpbnRlcnNlY3QoeDAxLCB5MDEsIHgwMCwgeTAwLCB4MTEsIHkxMSwgeDEwLCB5MTApIDogW3gxMCwgeTEwXSxcbiAgICAgICAgICAgICAgYXggPSB4MDEgLSBvY1swXSxcbiAgICAgICAgICAgICAgYXkgPSB5MDEgLSBvY1sxXSxcbiAgICAgICAgICAgICAgYnggPSB4MTEgLSBvY1swXSxcbiAgICAgICAgICAgICAgYnkgPSB5MTEgLSBvY1sxXSxcbiAgICAgICAgICAgICAga2MgPSAxIC8gc2luKGFjb3MoKGF4ICogYnggKyBheSAqIGJ5KSAvIChzcXJ0KGF4ICogYXggKyBheSAqIGF5KSAqIHNxcnQoYnggKiBieCArIGJ5ICogYnkpKSkgLyAyKSxcbiAgICAgICAgICAgICAgbGMgPSBzcXJ0KG9jWzBdICogb2NbMF0gKyBvY1sxXSAqIG9jWzFdKTtcbiAgICAgICAgICByYzAgPSBtaW4ocmMsIChyMCAtIGxjKSAvIChrYyAtIDEpKTtcbiAgICAgICAgICByYzEgPSBtaW4ocmMsIChyMSAtIGxjKSAvIChrYyArIDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJcyB0aGUgc2VjdG9yIGNvbGxhcHNlZCB0byBhIGxpbmU/XG4gICAgICBpZiAoIShkYTEgPiBlcHNpbG9uKSkgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpO1xuXG4gICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIG91dGVyIHJpbmcgaGF2ZSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBlbHNlIGlmIChyYzEgPiBlcHNpbG9uKSB7XG4gICAgICAgIHQwID0gY29ybmVyVGFuZ2VudHMoeDAwLCB5MDAsIHgwMSwgeTAxLCByMSwgcmMxLCBjdyk7XG4gICAgICAgIHQxID0gY29ybmVyVGFuZ2VudHMoeDExLCB5MTEsIHgxMCwgeTEwLCByMSwgcmMxLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMSA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBkcmF3IHRoZSB0d28gY29ybmVycyBhbmQgdGhlIHJpbmcuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMxLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQwLnkxMSwgdDAueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMSwgYXRhbjIodDAuY3kgKyB0MC55MTEsIHQwLmN4ICsgdDAueDExKSwgYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MS5jeCwgdDEuY3ksIHJjMSwgYXRhbjIodDEueTExLCB0MS54MTEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3IgaXMgdGhlIG91dGVyIHJpbmcganVzdCBhIGNpcmN1bGFyIGFyYz9cbiAgICAgIGVsc2UgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpLCBjb250ZXh0LmFyYygwLCAwLCByMSwgYTAxLCBhMTEsICFjdyk7XG5cbiAgICAgIC8vIElzIHRoZXJlIG5vIGlubmVyIHJpbmcsIGFuZCBpdOKAmXMgYSBjaXJjdWxhciBzZWN0b3I/XG4gICAgICAvLyBPciBwZXJoYXBzIGl04oCZcyBhbiBhbm51bGFyIHNlY3RvciBjb2xsYXBzZWQgZHVlIHRvIHBhZGRpbmc/XG4gICAgICBpZiAoIShyMCA+IGVwc2lsb24pIHx8ICEoZGEwID4gZXBzaWxvbikpIGNvbnRleHQubGluZVRvKHgxMCwgeTEwKTtcblxuICAgICAgLy8gRG9lcyB0aGUgc2VjdG9y4oCZcyBpbm5lciByaW5nIChvciBwb2ludCkgaGF2ZSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBlbHNlIGlmIChyYzAgPiBlcHNpbG9uKSB7XG4gICAgICAgIHQwID0gY29ybmVyVGFuZ2VudHMoeDEwLCB5MTAsIHgxMSwgeTExLCByMCwgLXJjMCwgY3cpO1xuICAgICAgICB0MSA9IGNvcm5lclRhbmdlbnRzKHgwMSwgeTAxLCB4MDAsIHkwMCwgcjAsIC1yYzAsIGN3KTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyh0MC5jeCArIHQwLngwMSwgdDAuY3kgKyB0MC55MDEpO1xuXG4gICAgICAgIC8vIEhhdmUgdGhlIGNvcm5lcnMgbWVyZ2VkP1xuICAgICAgICBpZiAocmMwIDwgcmMpIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMwLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcblxuICAgICAgICAvLyBPdGhlcndpc2UsIGRyYXcgdGhlIHR3byBjb3JuZXJzIGFuZCB0aGUgcmluZy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzAsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhdGFuMih0MC5jeSArIHQwLnkxMSwgdDAuY3ggKyB0MC54MTEpLCBhdGFuMih0MS5jeSArIHQxLnkxMSwgdDEuY3ggKyB0MS54MTEpLCBjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmModDEuY3gsIHQxLmN5LCByYzAsIGF0YW4yKHQxLnkxMSwgdDEueDExKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9yIGlzIHRoZSBpbm5lciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XG4gICAgICBlbHNlIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMTAsIGEwMCwgY3cpO1xuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGFyYy5jZW50cm9pZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gKCtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMixcbiAgICAgICAgYSA9ICgrc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK2VuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMiAtIHBpIC8gMjtcbiAgICByZXR1cm4gW2NvcyhhKSAqIHIsIHNpbihhKSAqIHJdO1xuICB9O1xuXG4gIGFyYy5pbm5lclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogaW5uZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLm91dGVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG91dGVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBvdXRlclJhZGl1cztcbiAgfTtcblxuICBhcmMuY29ybmVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvcm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogY29ybmVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5wYWRSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkUmFkaXVzID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogcGFkUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0YXJ0QW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHN0YXJ0QW5nbGU7XG4gIH07XG5cbiAgYXJjLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBlbmRBbmdsZTtcbiAgfTtcblxuICBhcmMucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHBhZEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8pLCBhcmMpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gYXJjO1xufVxuIiwiZnVuY3Rpb24gTGluZWFyKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkxpbmVhci5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IExpbmVhcihjb250ZXh0KTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiB4KHApIHtcbiAgcmV0dXJuIHBbMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5KHApIHtcbiAgcmV0dXJuIHBbMV07XG59XG4iLCJpbXBvcnQge3BhdGh9IGZyb20gXCJkMy1wYXRoXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnRcIjtcbmltcG9ydCBjdXJ2ZUxpbmVhciBmcm9tIFwiLi9jdXJ2ZS9saW5lYXJcIjtcbmltcG9ydCB7eCBhcyBwb2ludFgsIHkgYXMgcG9pbnRZfSBmcm9tIFwiLi9wb2ludFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSBwb2ludFgsXG4gICAgICB5ID0gcG9pbnRZLFxuICAgICAgZGVmaW5lZCA9IGNvbnN0YW50KHRydWUpLFxuICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICBjdXJ2ZSA9IGN1cnZlTGluZWFyLFxuICAgICAgb3V0cHV0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBsaW5lKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBkLFxuICAgICAgICBkZWZpbmVkMCA9IGZhbHNlLFxuICAgICAgICBidWZmZXI7XG5cbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSBvdXRwdXQgPSBjdXJ2ZShidWZmZXIgPSBwYXRoKCkpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGlmICghKGkgPCBuICYmIGRlZmluZWQoZCA9IGRhdGFbaV0sIGksIGRhdGEpKSA9PT0gZGVmaW5lZDApIHtcbiAgICAgICAgaWYgKGRlZmluZWQwID0gIWRlZmluZWQwKSBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgIGVsc2Ugb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbmVkMCkgb3V0cHV0LnBvaW50KCt4KGQsIGksIGRhdGEpLCAreShkLCBpLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGxpbmUueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmUpIDogeDtcbiAgfTtcblxuICBsaW5lLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHk7XG4gIH07XG5cbiAgbGluZS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlZmluZWQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGxpbmUpIDogZGVmaW5lZDtcbiAgfTtcblxuICBsaW5lLmN1cnZlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGN1cnZlID0gXywgY29udGV4dCAhPSBudWxsICYmIChvdXRwdXQgPSBjdXJ2ZShjb250ZXh0KSksIGxpbmUpIDogY3VydmU7XG4gIH07XG5cbiAgbGluZS5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IGNvbnRleHQgPSBvdXRwdXQgPSBudWxsIDogb3V0cHV0ID0gY3VydmUoY29udGV4dCA9IF8pLCBsaW5lKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmU7XG59XG4iLCJpbXBvcnQge3BhdGh9IGZyb20gXCJkMy1wYXRoXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnRcIjtcbmltcG9ydCBjdXJ2ZUxpbmVhciBmcm9tIFwiLi9jdXJ2ZS9saW5lYXJcIjtcbmltcG9ydCBsaW5lIGZyb20gXCIuL2xpbmVcIjtcbmltcG9ydCB7eCBhcyBwb2ludFgsIHkgYXMgcG9pbnRZfSBmcm9tIFwiLi9wb2ludFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHgwID0gcG9pbnRYLFxuICAgICAgeDEgPSBudWxsLFxuICAgICAgeTAgPSBjb25zdGFudCgwKSxcbiAgICAgIHkxID0gcG9pbnRZLFxuICAgICAgZGVmaW5lZCA9IGNvbnN0YW50KHRydWUpLFxuICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICBjdXJ2ZSA9IGN1cnZlTGluZWFyLFxuICAgICAgb3V0cHV0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBhcmVhKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaixcbiAgICAgICAgayxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBkLFxuICAgICAgICBkZWZpbmVkMCA9IGZhbHNlLFxuICAgICAgICBidWZmZXIsXG4gICAgICAgIHgweiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgeTB6ID0gbmV3IEFycmF5KG4pO1xuXG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gcGF0aCgpKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkge1xuICAgICAgICAgIGogPSBpO1xuICAgICAgICAgIG91dHB1dC5hcmVhU3RhcnQoKTtcbiAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgICAgZm9yIChrID0gaSAtIDE7IGsgPj0gajsgLS1rKSB7XG4gICAgICAgICAgICBvdXRwdXQucG9pbnQoeDB6W2tdLCB5MHpba10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgICAgIG91dHB1dC5hcmVhRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbmVkMCkge1xuICAgICAgICB4MHpbaV0gPSAreDAoZCwgaSwgZGF0YSksIHkweltpXSA9ICt5MChkLCBpLCBkYXRhKTtcbiAgICAgICAgb3V0cHV0LnBvaW50KHgxID8gK3gxKGQsIGksIGRhdGEpIDogeDB6W2ldLCB5MSA/ICt5MShkLCBpLCBkYXRhKSA6IHkweltpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFyZWFsaW5lKCkge1xuICAgIHJldHVybiBsaW5lKCkuZGVmaW5lZChkZWZpbmVkKS5jdXJ2ZShjdXJ2ZSkuY29udGV4dChjb250ZXh0KTtcbiAgfVxuXG4gIGFyZWEueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB4MSA9IG51bGwsIGFyZWEpIDogeDA7XG4gIH07XG5cbiAgYXJlYS54MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHgwO1xuICB9O1xuXG4gIGFyZWEueDEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDEgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeDE7XG4gIH07XG5cbiAgYXJlYS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHkxID0gbnVsbCwgYXJlYSkgOiB5MDtcbiAgfTtcblxuICBhcmVhLnkwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeTA7XG4gIH07XG5cbiAgYXJlYS55MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MSA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB5MTtcbiAgfTtcblxuICBhcmVhLmxpbmVYMCA9XG4gIGFyZWEubGluZVkwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MCk7XG4gIH07XG5cbiAgYXJlYS5saW5lWTEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgwKS55KHkxKTtcbiAgfTtcblxuICBhcmVhLmxpbmVYMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDEpLnkoeTApO1xuICB9O1xuXG4gIGFyZWEuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBhcmVhKSA6IGRlZmluZWQ7XG4gIH07XG5cbiAgYXJlYS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBhcmVhKSA6IGN1cnZlO1xuICB9O1xuXG4gIGFyZWEuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgYXJlYSkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBhcmVhO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYiA8IGEgPyAtMSA6IGIgPiBhID8gMSA6IGIgPj0gYSA/IDAgOiBOYU47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkKSB7XG4gIHJldHVybiBkO1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgZGVzY2VuZGluZyBmcm9tIFwiLi9kZXNjZW5kaW5nXCI7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHlcIjtcbmltcG9ydCB7dGF1fSBmcm9tIFwiLi9tYXRoXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsdWUgPSBpZGVudGl0eSxcbiAgICAgIHNvcnRWYWx1ZXMgPSBkZXNjZW5kaW5nLFxuICAgICAgc29ydCA9IG51bGwsXG4gICAgICBzdGFydEFuZ2xlID0gY29uc3RhbnQoMCksXG4gICAgICBlbmRBbmdsZSA9IGNvbnN0YW50KHRhdSksXG4gICAgICBwYWRBbmdsZSA9IGNvbnN0YW50KDApO1xuXG4gIGZ1bmN0aW9uIHBpZShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgaixcbiAgICAgICAgayxcbiAgICAgICAgc3VtID0gMCxcbiAgICAgICAgaW5kZXggPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGFyY3MgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGEwID0gK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgZGEgPSBNYXRoLm1pbih0YXUsIE1hdGgubWF4KC10YXUsIGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBhMCkpLFxuICAgICAgICBhMSxcbiAgICAgICAgcCA9IE1hdGgubWluKE1hdGguYWJzKGRhKSAvIG4sIHBhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLFxuICAgICAgICBwYSA9IHAgKiAoZGEgPCAwID8gLTEgOiAxKSxcbiAgICAgICAgdjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgodiA9IGFyY3NbaW5kZXhbaV0gPSBpXSA9ICt2YWx1ZShkYXRhW2ldLCBpLCBkYXRhKSkgPiAwKSB7XG4gICAgICAgIHN1bSArPSB2O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9wdGlvbmFsbHkgc29ydCB0aGUgYXJjcyBieSBwcmV2aW91c2x5LWNvbXB1dGVkIHZhbHVlcyBvciBieSBkYXRhLlxuICAgIGlmIChzb3J0VmFsdWVzICE9IG51bGwpIGluZGV4LnNvcnQoZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gc29ydFZhbHVlcyhhcmNzW2ldLCBhcmNzW2pdKTsgfSk7XG4gICAgZWxzZSBpZiAoc29ydCAhPSBudWxsKSBpbmRleC5zb3J0KGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIHNvcnQoZGF0YVtpXSwgZGF0YVtqXSk7IH0pO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgYXJjcyEgVGhleSBhcmUgc3RvcmVkIGluIHRoZSBvcmlnaW5hbCBkYXRhJ3Mgb3JkZXIuXG4gICAgZm9yIChpID0gMCwgayA9IHN1bSA/IChkYSAtIG4gKiBwYSkgLyBzdW0gOiAwOyBpIDwgbjsgKytpLCBhMCA9IGExKSB7XG4gICAgICBqID0gaW5kZXhbaV0sIHYgPSBhcmNzW2pdLCBhMSA9IGEwICsgKHYgPiAwID8gdiAqIGsgOiAwKSArIHBhLCBhcmNzW2pdID0ge1xuICAgICAgICBkYXRhOiBkYXRhW2pdLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgIHN0YXJ0QW5nbGU6IGEwLFxuICAgICAgICBlbmRBbmdsZTogYTEsXG4gICAgICAgIHBhZEFuZ2xlOiBwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBhcmNzO1xuICB9XG5cbiAgcGllLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiB2YWx1ZTtcbiAgfTtcblxuICBwaWUuc29ydFZhbHVlcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3J0VmFsdWVzID0gXywgc29ydCA9IG51bGwsIHBpZSkgOiBzb3J0VmFsdWVzO1xuICB9O1xuXG4gIHBpZS5zb3J0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnQgPSBfLCBzb3J0VmFsdWVzID0gbnVsbCwgcGllKSA6IHNvcnQ7XG4gIH07XG5cbiAgcGllLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RhcnRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogc3RhcnRBbmdsZTtcbiAgfTtcblxuICBwaWUuZW5kQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZW5kQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IGVuZEFuZ2xlO1xuICB9O1xuXG4gIHBpZS5wYWRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogcGFkQW5nbGU7XG4gIH07XG5cbiAgcmV0dXJuIHBpZTtcbn1cbiIsImltcG9ydCBjdXJ2ZUxpbmVhciBmcm9tIFwiLi9saW5lYXJcIjtcblxuZXhwb3J0IHZhciBjdXJ2ZVJhZGlhbExpbmVhciA9IGN1cnZlUmFkaWFsKGN1cnZlTGluZWFyKTtcblxuZnVuY3Rpb24gUmFkaWFsKGN1cnZlKSB7XG4gIHRoaXMuX2N1cnZlID0gY3VydmU7XG59XG5cblJhZGlhbC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY3VydmUuYXJlYVN0YXJ0KCk7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmFyZWFFbmQoKTtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJ2ZS5saW5lU3RhcnQoKTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY3VydmUubGluZUVuZCgpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oYSwgcikge1xuICAgIHRoaXMuX2N1cnZlLnBvaW50KHIgKiBNYXRoLnNpbihhKSwgciAqIC1NYXRoLmNvcyhhKSk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGN1cnZlUmFkaWFsKGN1cnZlKSB7XG5cbiAgZnVuY3Rpb24gcmFkaWFsKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFJhZGlhbChjdXJ2ZShjb250ZXh0KSk7XG4gIH1cblxuICByYWRpYWwuX2N1cnZlID0gY3VydmU7XG5cbiAgcmV0dXJuIHJhZGlhbDtcbn1cbiIsImltcG9ydCBjdXJ2ZVJhZGlhbCwge2N1cnZlUmFkaWFsTGluZWFyfSBmcm9tIFwiLi9jdXJ2ZS9yYWRpYWxcIjtcbmltcG9ydCBsaW5lIGZyb20gXCIuL2xpbmVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVSYWRpYWwobCkge1xuICB2YXIgYyA9IGwuY3VydmU7XG5cbiAgbC5hbmdsZSA9IGwueCwgZGVsZXRlIGwueDtcbiAgbC5yYWRpdXMgPSBsLnksIGRlbGV0ZSBsLnk7XG5cbiAgbC5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGMoY3VydmVSYWRpYWwoXykpIDogYygpLl9jdXJ2ZTtcbiAgfTtcblxuICByZXR1cm4gbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBsaW5lUmFkaWFsKGxpbmUoKS5jdXJ2ZShjdXJ2ZVJhZGlhbExpbmVhcikpO1xufVxuIiwiaW1wb3J0IGN1cnZlUmFkaWFsLCB7Y3VydmVSYWRpYWxMaW5lYXJ9IGZyb20gXCIuL2N1cnZlL3JhZGlhbFwiO1xuaW1wb3J0IGFyZWEgZnJvbSBcIi4vYXJlYVwiO1xuaW1wb3J0IHtsaW5lUmFkaWFsfSBmcm9tIFwiLi9saW5lUmFkaWFsXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBhID0gYXJlYSgpLmN1cnZlKGN1cnZlUmFkaWFsTGluZWFyKSxcbiAgICAgIGMgPSBhLmN1cnZlLFxuICAgICAgeDAgPSBhLmxpbmVYMCxcbiAgICAgIHgxID0gYS5saW5lWDEsXG4gICAgICB5MCA9IGEubGluZVkwLFxuICAgICAgeTEgPSBhLmxpbmVZMTtcblxuICBhLmFuZ2xlID0gYS54LCBkZWxldGUgYS54O1xuICBhLnN0YXJ0QW5nbGUgPSBhLngwLCBkZWxldGUgYS54MDtcbiAgYS5lbmRBbmdsZSA9IGEueDEsIGRlbGV0ZSBhLngxO1xuICBhLnJhZGl1cyA9IGEueSwgZGVsZXRlIGEueTtcbiAgYS5pbm5lclJhZGl1cyA9IGEueTAsIGRlbGV0ZSBhLnkwO1xuICBhLm91dGVyUmFkaXVzID0gYS55MSwgZGVsZXRlIGEueTE7XG4gIGEubGluZVN0YXJ0QW5nbGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGxpbmVSYWRpYWwoeDAoKSk7IH0sIGRlbGV0ZSBhLmxpbmVYMDtcbiAgYS5saW5lRW5kQW5nbGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGxpbmVSYWRpYWwoeDEoKSk7IH0sIGRlbGV0ZSBhLmxpbmVYMTtcbiAgYS5saW5lSW5uZXJSYWRpdXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGxpbmVSYWRpYWwoeTAoKSk7IH0sIGRlbGV0ZSBhLmxpbmVZMDtcbiAgYS5saW5lT3V0ZXJSYWRpdXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGxpbmVSYWRpYWwoeTEoKSk7IH0sIGRlbGV0ZSBhLmxpbmVZMTtcblxuICBhLmN1cnZlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gYyhjdXJ2ZVJhZGlhbChfKSkgOiBjKCkuX2N1cnZlO1xuICB9O1xuXG4gIHJldHVybiBhO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4gWyh5ID0gK3kpICogTWF0aC5jb3MoeCAtPSBNYXRoLlBJIC8gMiksIHkgKiBNYXRoLnNpbih4KV07XG59XG4iLCJleHBvcnQgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuIiwiaW1wb3J0IHtwYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4uL2FycmF5XCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4uL2NvbnN0YW50XCI7XG5pbXBvcnQge3ggYXMgcG9pbnRYLCB5IGFzIHBvaW50WX0gZnJvbSBcIi4uL3BvaW50XCI7XG5pbXBvcnQgcG9pbnRSYWRpYWwgZnJvbSBcIi4uL3BvaW50UmFkaWFsXCI7XG5cbmZ1bmN0aW9uIGxpbmtTb3VyY2UoZCkge1xuICByZXR1cm4gZC5zb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGxpbmtUYXJnZXQoZCkge1xuICByZXR1cm4gZC50YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGxpbmsoY3VydmUpIHtcbiAgdmFyIHNvdXJjZSA9IGxpbmtTb3VyY2UsXG4gICAgICB0YXJnZXQgPSBsaW5rVGFyZ2V0LFxuICAgICAgeCA9IHBvaW50WCxcbiAgICAgIHkgPSBwb2ludFksXG4gICAgICBjb250ZXh0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBsaW5rKCkge1xuICAgIHZhciBidWZmZXIsIGFyZ3YgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksIHMgPSBzb3VyY2UuYXBwbHkodGhpcywgYXJndiksIHQgPSB0YXJnZXQuYXBwbHkodGhpcywgYXJndik7XG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gcGF0aCgpO1xuICAgIGN1cnZlKGNvbnRleHQsICt4LmFwcGx5KHRoaXMsIChhcmd2WzBdID0gcywgYXJndikpLCAreS5hcHBseSh0aGlzLCBhcmd2KSwgK3guYXBwbHkodGhpcywgKGFyZ3ZbMF0gPSB0LCBhcmd2KSksICt5LmFwcGx5KHRoaXMsIGFyZ3YpKTtcbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGxpbmsuc291cmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvdXJjZSA9IF8sIGxpbmspIDogc291cmNlO1xuICB9O1xuXG4gIGxpbmsudGFyZ2V0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRhcmdldCA9IF8sIGxpbmspIDogdGFyZ2V0O1xuICB9O1xuXG4gIGxpbmsueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmspIDogeDtcbiAgfTtcblxuICBsaW5rLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5rKSA6IHk7XG4gIH07XG5cbiAgbGluay5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8pLCBsaW5rKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGN1cnZlSG9yaXpvbnRhbChjb250ZXh0LCB4MCwgeTAsIHgxLCB5MSkge1xuICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICBjb250ZXh0LmJlemllckN1cnZlVG8oeDAgPSAoeDAgKyB4MSkgLyAyLCB5MCwgeDAsIHkxLCB4MSwgeTEpO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZVZlcnRpY2FsKGNvbnRleHQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCwgeTAgPSAoeTAgKyB5MSkgLyAyLCB4MSwgeTAsIHgxLCB5MSk7XG59XG5cbmZ1bmN0aW9uIGN1cnZlUmFkaWFsKGNvbnRleHQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBwMCA9IHBvaW50UmFkaWFsKHgwLCB5MCksXG4gICAgICBwMSA9IHBvaW50UmFkaWFsKHgwLCB5MCA9ICh5MCArIHkxKSAvIDIpLFxuICAgICAgcDIgPSBwb2ludFJhZGlhbCh4MSwgeTApLFxuICAgICAgcDMgPSBwb2ludFJhZGlhbCh4MSwgeTEpO1xuICBjb250ZXh0Lm1vdmVUbyhwMFswXSwgcDBbMV0pO1xuICBjb250ZXh0LmJlemllckN1cnZlVG8ocDFbMF0sIHAxWzFdLCBwMlswXSwgcDJbMV0sIHAzWzBdLCBwM1sxXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5rSG9yaXpvbnRhbCgpIHtcbiAgcmV0dXJuIGxpbmsoY3VydmVIb3Jpem9udGFsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmtWZXJ0aWNhbCgpIHtcbiAgcmV0dXJuIGxpbmsoY3VydmVWZXJ0aWNhbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5rUmFkaWFsKCkge1xuICB2YXIgbCA9IGxpbmsoY3VydmVSYWRpYWwpO1xuICBsLmFuZ2xlID0gbC54LCBkZWxldGUgbC54O1xuICBsLnJhZGl1cyA9IGwueSwgZGVsZXRlIGwueTtcbiAgcmV0dXJuIGw7XG59XG4iLCJpbXBvcnQge3BpLCB0YXV9IGZyb20gXCIuLi9tYXRoXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyBwaSk7XG4gICAgY29udGV4dC5tb3ZlVG8ociwgMCk7XG4gICAgY29udGV4dC5hcmMoMCwgMCwgciwgMCwgdGF1KTtcbiAgfVxufTtcbiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyA1KSAvIDI7XG4gICAgY29udGV4dC5tb3ZlVG8oLTMgKiByLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgLTMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygzICogciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKDMgKiByLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAzICogcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIDMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgcik7XG4gICAgY29udGV4dC5saW5lVG8oLTMgKiByLCByKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwidmFyIHRhbjMwID0gTWF0aC5zcXJ0KDEgLyAzKSxcbiAgICB0YW4zMF8yID0gdGFuMzAgKiAyO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgeSA9IE1hdGguc3FydChzaXplIC8gdGFuMzBfMiksXG4gICAgICAgIHggPSB5ICogdGFuMzA7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXkpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIDApO1xuICAgIGNvbnRleHQubGluZVRvKDAsIHkpO1xuICAgIGNvbnRleHQubGluZVRvKC14LCAwKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtwaSwgdGF1fSBmcm9tIFwiLi4vbWF0aFwiO1xuXG52YXIga2EgPSAwLjg5MDgxMzA5MTUyOTI4NTIyODEwLFxuICAgIGtyID0gTWF0aC5zaW4ocGkgLyAxMCkgLyBNYXRoLnNpbig3ICogcGkgLyAxMCksXG4gICAga3ggPSBNYXRoLnNpbih0YXUgLyAxMCkgKiBrcixcbiAgICBreSA9IC1NYXRoLmNvcyh0YXUgLyAxMCkgKiBrcjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAqIGthKSxcbiAgICAgICAgeCA9IGt4ICogcixcbiAgICAgICAgeSA9IGt5ICogcjtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCA1OyArK2kpIHtcbiAgICAgIHZhciBhID0gdGF1ICogaSAvIDUsXG4gICAgICAgICAgYyA9IE1hdGguY29zKGEpLFxuICAgICAgICAgIHMgPSBNYXRoLnNpbihhKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHMgKiByLCAtYyAqIHIpO1xuICAgICAgY29udGV4dC5saW5lVG8oYyAqIHggLSBzICogeSwgcyAqIHggKyBjICogeSk7XG4gICAgfVxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJleHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgdyA9IE1hdGguc3FydChzaXplKSxcbiAgICAgICAgeCA9IC13IC8gMjtcbiAgICBjb250ZXh0LnJlY3QoeCwgeCwgdywgdyk7XG4gIH1cbn07XG4iLCJ2YXIgc3FydDMgPSBNYXRoLnNxcnQoMyk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciB5ID0gLU1hdGguc3FydChzaXplIC8gKHNxcnQzICogMykpO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIHkgKiAyKTtcbiAgICBjb250ZXh0LmxpbmVUbygtc3FydDMgKiB5LCAteSk7XG4gICAgY29udGV4dC5saW5lVG8oc3FydDMgKiB5LCAteSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsInZhciBjID0gLTAuNSxcbiAgICBzID0gTWF0aC5zcXJ0KDMpIC8gMixcbiAgICBrID0gMSAvIE1hdGguc3FydCgxMiksXG4gICAgYSA9IChrIC8gMiArIDEpICogMztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIGEpLFxuICAgICAgICB4MCA9IHIgLyAyLFxuICAgICAgICB5MCA9IHIgKiBrLFxuICAgICAgICB4MSA9IHgwLFxuICAgICAgICB5MSA9IHIgKiBrICsgcixcbiAgICAgICAgeDIgPSAteDEsXG4gICAgICAgIHkyID0geTE7XG4gICAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4MSwgeTEpO1xuICAgIGNvbnRleHQubGluZVRvKHgyLCB5Mik7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgwIC0gcyAqIHkwLCBzICogeDAgKyBjICogeTApO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MSAtIHMgKiB5MSwgcyAqIHgxICsgYyAqIHkxKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDIgLSBzICogeTIsIHMgKiB4MiArIGMgKiB5Mik7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgwICsgcyAqIHkwLCBjICogeTAgLSBzICogeDApO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MSArIHMgKiB5MSwgYyAqIHkxIC0gcyAqIHgxKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDIgKyBzICogeTIsIGMgKiB5MiAtIHMgKiB4Mik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsImltcG9ydCB7cGF0aH0gZnJvbSBcImQzLXBhdGhcIjtcbmltcG9ydCBjaXJjbGUgZnJvbSBcIi4vc3ltYm9sL2NpcmNsZVwiO1xuaW1wb3J0IGNyb3NzIGZyb20gXCIuL3N5bWJvbC9jcm9zc1wiO1xuaW1wb3J0IGRpYW1vbmQgZnJvbSBcIi4vc3ltYm9sL2RpYW1vbmRcIjtcbmltcG9ydCBzdGFyIGZyb20gXCIuL3N5bWJvbC9zdGFyXCI7XG5pbXBvcnQgc3F1YXJlIGZyb20gXCIuL3N5bWJvbC9zcXVhcmVcIjtcbmltcG9ydCB0cmlhbmdsZSBmcm9tIFwiLi9zeW1ib2wvdHJpYW5nbGVcIjtcbmltcG9ydCB3eWUgZnJvbSBcIi4vc3ltYm9sL3d5ZVwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5cbmV4cG9ydCB2YXIgc3ltYm9scyA9IFtcbiAgY2lyY2xlLFxuICBjcm9zcyxcbiAgZGlhbW9uZCxcbiAgc3F1YXJlLFxuICBzdGFyLFxuICB0cmlhbmdsZSxcbiAgd3llXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHR5cGUgPSBjb25zdGFudChjaXJjbGUpLFxuICAgICAgc2l6ZSA9IGNvbnN0YW50KDY0KSxcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHN5bWJvbCgpIHtcbiAgICB2YXIgYnVmZmVyO1xuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGJ1ZmZlciA9IHBhdGgoKTtcbiAgICB0eXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykuZHJhdyhjb250ZXh0LCArc2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIHN5bWJvbC50eXBlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHR5cGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBzeW1ib2wpIDogdHlwZTtcbiAgfTtcblxuICBzeW1ib2wuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzaXplID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHN5bWJvbCkgOiBzaXplO1xuICB9O1xuXG4gIHN5bWJvbC5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXywgc3ltYm9sKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIHN5bWJvbDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge31cbiIsImV4cG9ydCBmdW5jdGlvbiBwb2ludCh0aGF0LCB4LCB5KSB7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICAoMiAqIHRoYXQuX3gwICsgdGhhdC5feDEpIC8gMyxcbiAgICAoMiAqIHRoYXQuX3kwICsgdGhhdC5feTEpIC8gMyxcbiAgICAodGhhdC5feDAgKyAyICogdGhhdC5feDEpIC8gMyxcbiAgICAodGhhdC5feTAgKyAyICogdGhhdC5feTEpIC8gMyxcbiAgICAodGhhdC5feDAgKyA0ICogdGhhdC5feDEgKyB4KSAvIDYsXG4gICAgKHRoYXQuX3kwICsgNCAqIHRoYXQuX3kxICsgeSkgLyA2XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBCYXNpcyhjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5CYXNpcy5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMzogcG9pbnQodGhpcywgdGhpcy5feDEsIHRoaXMuX3kxKTsgLy8gcHJvY2VlZFxuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2NvbnRleHQubGluZVRvKCg1ICogdGhpcy5feDAgKyB0aGlzLl94MSkgLyA2LCAoNSAqIHRoaXMuX3kwICsgdGhpcy5feTEpIC8gNik7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJhc2lzKGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3BcIjtcbmltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2Jhc2lzXCI7XG5cbmZ1bmN0aW9uIEJhc2lzQ2xvc2VkKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkJhc2lzQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oKHRoaXMuX3gyICsgMiAqIHRoaXMuX3gzKSAvIDMsICh0aGlzLl95MiArIDIgKiB0aGlzLl95MykgLyAzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oKHRoaXMuX3gzICsgMiAqIHRoaXMuX3gyKSAvIDMsICh0aGlzLl95MyArIDIgKiB0aGlzLl95MikgLyAzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MiwgdGhpcy5feTIpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl94MiA9IHgsIHRoaXMuX3kyID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5OyB0aGlzLl9jb250ZXh0Lm1vdmVUbygodGhpcy5feDAgKyA0ICogdGhpcy5feDEgKyB4KSAvIDYsICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHkpIC8gNik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQmFzaXNDbG9zZWQoY29udGV4dCk7XG59XG4iLCJpbXBvcnQge3BvaW50fSBmcm9tIFwiLi9iYXNpc1wiO1xuXG5mdW5jdGlvbiBCYXNpc09wZW4oY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuQmFzaXNPcGVuLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdmFyIHgwID0gKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgeCkgLyA2LCB5MCA9ICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHkpIC8gNjsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgwLCB5MCkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4MCwgeTApOyBicmVhaztcbiAgICAgIGNhc2UgMzogdGhpcy5fcG9pbnQgPSA0OyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCYXNpc09wZW4oY29udGV4dCk7XG59XG4iLCJpbXBvcnQge0Jhc2lzfSBmcm9tIFwiLi9iYXNpc1wiO1xuXG5mdW5jdGlvbiBCdW5kbGUoY29udGV4dCwgYmV0YSkge1xuICB0aGlzLl9iYXNpcyA9IG5ldyBCYXNpcyhjb250ZXh0KTtcbiAgdGhpcy5fYmV0YSA9IGJldGE7XG59XG5cbkJ1bmRsZS5wcm90b3R5cGUgPSB7XG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IFtdO1xuICAgIHRoaXMuX3kgPSBbXTtcbiAgICB0aGlzLl9iYXNpcy5saW5lU3RhcnQoKTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSB0aGlzLl94LFxuICAgICAgICB5ID0gdGhpcy5feSxcbiAgICAgICAgaiA9IHgubGVuZ3RoIC0gMTtcblxuICAgIGlmIChqID4gMCkge1xuICAgICAgdmFyIHgwID0geFswXSxcbiAgICAgICAgICB5MCA9IHlbMF0sXG4gICAgICAgICAgZHggPSB4W2pdIC0geDAsXG4gICAgICAgICAgZHkgPSB5W2pdIC0geTAsXG4gICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgIHQ7XG5cbiAgICAgIHdoaWxlICgrK2kgPD0gaikge1xuICAgICAgICB0ID0gaSAvIGo7XG4gICAgICAgIHRoaXMuX2Jhc2lzLnBvaW50KFxuICAgICAgICAgIHRoaXMuX2JldGEgKiB4W2ldICsgKDEgLSB0aGlzLl9iZXRhKSAqICh4MCArIHQgKiBkeCksXG4gICAgICAgICAgdGhpcy5fYmV0YSAqIHlbaV0gKyAoMSAtIHRoaXMuX2JldGEpICogKHkwICsgdCAqIGR5KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gbnVsbDtcbiAgICB0aGlzLl9iYXNpcy5saW5lRW5kKCk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5feC5wdXNoKCt4KTtcbiAgICB0aGlzLl95LnB1c2goK3kpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKGJldGEpIHtcblxuICBmdW5jdGlvbiBidW5kbGUoY29udGV4dCkge1xuICAgIHJldHVybiBiZXRhID09PSAxID8gbmV3IEJhc2lzKGNvbnRleHQpIDogbmV3IEJ1bmRsZShjb250ZXh0LCBiZXRhKTtcbiAgfVxuXG4gIGJ1bmRsZS5iZXRhID0gZnVuY3Rpb24oYmV0YSkge1xuICAgIHJldHVybiBjdXN0b20oK2JldGEpO1xuICB9O1xuXG4gIHJldHVybiBidW5kbGU7XG59KSgwLjg1KTtcbiIsImV4cG9ydCBmdW5jdGlvbiBwb2ludCh0aGF0LCB4LCB5KSB7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICB0aGF0Ll94MSArIHRoYXQuX2sgKiAodGhhdC5feDIgLSB0aGF0Ll94MCksXG4gICAgdGhhdC5feTEgKyB0aGF0Ll9rICogKHRoYXQuX3kyIC0gdGhhdC5feTApLFxuICAgIHRoYXQuX3gyICsgdGhhdC5fayAqICh0aGF0Ll94MSAtIHgpLFxuICAgIHRoYXQuX3kyICsgdGhhdC5fayAqICh0aGF0Ll95MSAtIHkpLFxuICAgIHRoYXQuX3gyLFxuICAgIHRoYXQuX3kyXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDYXJkaW5hbChjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHBvaW50KHRoaXMsIHRoaXMuX3gxLCB0aGlzLl95MSk7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5feDEgPSB4LCB0aGlzLl95MSA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG5cbiAgZnVuY3Rpb24gY2FyZGluYWwoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQ2FyZGluYWwoY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKDApO1xuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3BcIjtcbmltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2NhcmRpbmFsXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBDYXJkaW5hbENsb3NlZChjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPSB0aGlzLl94NSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IHRoaXMuX3k1ID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g1LCB0aGlzLl95NSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDUgPSB4LCB0aGlzLl95NSA9IHk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCB0ZW5zaW9uKTtcbiAgfVxuXG4gIGNhcmRpbmFsLnRlbnNpb24gPSBmdW5jdGlvbih0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XG4gIH07XG5cbiAgcmV0dXJuIGNhcmRpbmFsO1xufSkoMCk7XG4iLCJpbXBvcnQge3BvaW50fSBmcm9tIFwiLi9jYXJkaW5hbFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gQ2FyZGluYWxPcGVuKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbn1cblxuQ2FyZGluYWxPcGVuLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbE9wZW4oY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKDApO1xuIiwiaW1wb3J0IHtlcHNpbG9ufSBmcm9tIFwiLi4vbWF0aFwiO1xuaW1wb3J0IHtDYXJkaW5hbH0gZnJvbSBcIi4vY2FyZGluYWxcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50KHRoYXQsIHgsIHkpIHtcbiAgdmFyIHgxID0gdGhhdC5feDEsXG4gICAgICB5MSA9IHRoYXQuX3kxLFxuICAgICAgeDIgPSB0aGF0Ll94MixcbiAgICAgIHkyID0gdGhhdC5feTI7XG5cbiAgaWYgKHRoYXQuX2wwMV9hID4gZXBzaWxvbikge1xuICAgIHZhciBhID0gMiAqIHRoYXQuX2wwMV8yYSArIDMgKiB0aGF0Ll9sMDFfYSAqIHRoYXQuX2wxMl9hICsgdGhhdC5fbDEyXzJhLFxuICAgICAgICBuID0gMyAqIHRoYXQuX2wwMV9hICogKHRoYXQuX2wwMV9hICsgdGhhdC5fbDEyX2EpO1xuICAgIHgxID0gKHgxICogYSAtIHRoYXQuX3gwICogdGhhdC5fbDEyXzJhICsgdGhhdC5feDIgKiB0aGF0Ll9sMDFfMmEpIC8gbjtcbiAgICB5MSA9ICh5MSAqIGEgLSB0aGF0Ll95MCAqIHRoYXQuX2wxMl8yYSArIHRoYXQuX3kyICogdGhhdC5fbDAxXzJhKSAvIG47XG4gIH1cblxuICBpZiAodGhhdC5fbDIzX2EgPiBlcHNpbG9uKSB7XG4gICAgdmFyIGIgPSAyICogdGhhdC5fbDIzXzJhICsgMyAqIHRoYXQuX2wyM19hICogdGhhdC5fbDEyX2EgKyB0aGF0Ll9sMTJfMmEsXG4gICAgICAgIG0gPSAzICogdGhhdC5fbDIzX2EgKiAodGhhdC5fbDIzX2EgKyB0aGF0Ll9sMTJfYSk7XG4gICAgeDIgPSAoeDIgKiBiICsgdGhhdC5feDEgKiB0aGF0Ll9sMjNfMmEgLSB4ICogdGhhdC5fbDEyXzJhKSAvIG07XG4gICAgeTIgPSAoeTIgKiBiICsgdGhhdC5feTEgKiB0aGF0Ll9sMjNfMmEgLSB5ICogdGhhdC5fbDEyXzJhKSAvIG07XG4gIH1cblxuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHRoYXQuX3gyLCB0aGF0Ll95Mik7XG59XG5cbmZ1bmN0aW9uIENhdG11bGxSb20oY29udGV4dCwgYWxwaGEpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2FscGhhID0gYWxwaGE7XG59XG5cbkNhdG11bGxSb20ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG5cbiAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgIHZhciB4MjMgPSB0aGlzLl94MiAtIHgsXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbChjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKDAuNSk7XG4iLCJpbXBvcnQge0NhcmRpbmFsQ2xvc2VkfSBmcm9tIFwiLi9jYXJkaW5hbENsb3NlZFwiO1xuaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3BcIjtcbmltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2NhdG11bGxSb21cIjtcblxuZnVuY3Rpb24gQ2F0bXVsbFJvbUNsb3NlZChjb250ZXh0LCBhbHBoYSkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbn1cblxuQ2F0bXVsbFJvbUNsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID0gdGhpcy5feDUgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSB0aGlzLl95NSA9IE5hTjtcbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPVxuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDUsIHRoaXMuX3k1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuXG4gICAgaWYgKHRoaXMuX3BvaW50KSB7XG4gICAgICB2YXIgeDIzID0gdGhpcy5feDIgLSB4LFxuICAgICAgICAgIHkyMyA9IHRoaXMuX3kyIC0geTtcbiAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KHgyMyAqIHgyMyArIHkyMyAqIHkyMywgdGhpcy5fYWxwaGEpKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDUgPSB4LCB0aGlzLl95NSA9IHk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tQ2xvc2VkKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKDAuNSk7XG4iLCJpbXBvcnQge0NhcmRpbmFsT3Blbn0gZnJvbSBcIi4vY2FyZGluYWxPcGVuXCI7XG5pbXBvcnQge3BvaW50fSBmcm9tIFwiLi9jYXRtdWxsUm9tXCI7XG5cbmZ1bmN0aW9uIENhdG11bGxSb21PcGVuKGNvbnRleHQsIGFscGhhKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9hbHBoYSA9IGFscGhhO1xufVxuXG5DYXRtdWxsUm9tT3Blbi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcblxuICAgIGlmICh0aGlzLl9wb2ludCkge1xuICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCxcbiAgICAgICAgICB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tT3Blbihjb250ZXh0LCBhbHBoYSkgOiBuZXcgQ2FyZGluYWxPcGVuKGNvbnRleHQsIDApO1xuICB9XG5cbiAgY2F0bXVsbFJvbS5hbHBoYSA9IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrYWxwaGEpO1xuICB9O1xuXG4gIHJldHVybiBjYXRtdWxsUm9tO1xufSkoMC41KTtcbiIsImltcG9ydCBub29wIGZyb20gXCIuLi9ub29wXCI7XG5cbmZ1bmN0aW9uIExpbmVhckNsb3NlZChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5MaW5lYXJDbG9zZWQucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IG5vb3AsXG4gIGFyZWFFbmQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fcG9pbnQpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgaWYgKHRoaXMuX3BvaW50KSB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICBlbHNlIHRoaXMuX3BvaW50ID0gMSwgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBMaW5lYXJDbG9zZWQoY29udGV4dCk7XG59XG4iLCJmdW5jdGlvbiBzaWduKHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLTEgOiAxO1xufVxuXG4vLyBDYWxjdWxhdGUgdGhlIHNsb3BlcyBvZiB0aGUgdGFuZ2VudHMgKEhlcm1pdGUtdHlwZSBpbnRlcnBvbGF0aW9uKSBiYXNlZCBvblxuLy8gdGhlIGZvbGxvd2luZyBwYXBlcjogU3RlZmZlbiwgTS4gMTk5MC4gQSBTaW1wbGUgTWV0aG9kIGZvciBNb25vdG9uaWNcbi8vIEludGVycG9sYXRpb24gaW4gT25lIERpbWVuc2lvbi4gQXN0cm9ub215IGFuZCBBc3Ryb3BoeXNpY3MsIFZvbC4gMjM5LCBOTy5cbi8vIE5PVihJSSksIFAuIDQ0MywgMTk5MC5cbmZ1bmN0aW9uIHNsb3BlMyh0aGF0LCB4MiwgeTIpIHtcbiAgdmFyIGgwID0gdGhhdC5feDEgLSB0aGF0Ll94MCxcbiAgICAgIGgxID0geDIgLSB0aGF0Ll94MSxcbiAgICAgIHMwID0gKHRoYXQuX3kxIC0gdGhhdC5feTApIC8gKGgwIHx8IGgxIDwgMCAmJiAtMCksXG4gICAgICBzMSA9ICh5MiAtIHRoYXQuX3kxKSAvIChoMSB8fCBoMCA8IDAgJiYgLTApLFxuICAgICAgcCA9IChzMCAqIGgxICsgczEgKiBoMCkgLyAoaDAgKyBoMSk7XG4gIHJldHVybiAoc2lnbihzMCkgKyBzaWduKHMxKSkgKiBNYXRoLm1pbihNYXRoLmFicyhzMCksIE1hdGguYWJzKHMxKSwgMC41ICogTWF0aC5hYnMocCkpIHx8IDA7XG59XG5cbi8vIENhbGN1bGF0ZSBhIG9uZS1zaWRlZCBzbG9wZS5cbmZ1bmN0aW9uIHNsb3BlMih0aGF0LCB0KSB7XG4gIHZhciBoID0gdGhhdC5feDEgLSB0aGF0Ll94MDtcbiAgcmV0dXJuIGggPyAoMyAqICh0aGF0Ll95MSAtIHRoYXQuX3kwKSAvIGggLSB0KSAvIDIgOiB0O1xufVxuXG4vLyBBY2NvcmRpbmcgdG8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViaWNfSGVybWl0ZV9zcGxpbmUjUmVwcmVzZW50YXRpb25zXG4vLyBcInlvdSBjYW4gZXhwcmVzcyBjdWJpYyBIZXJtaXRlIGludGVycG9sYXRpb24gaW4gdGVybXMgb2YgY3ViaWMgQsOpemllciBjdXJ2ZXNcbi8vIHdpdGggcmVzcGVjdCB0byB0aGUgZm91ciB2YWx1ZXMgcDAsIHAwICsgbTAgLyAzLCBwMSAtIG0xIC8gMywgcDFcIi5cbmZ1bmN0aW9uIHBvaW50KHRoYXQsIHQwLCB0MSkge1xuICB2YXIgeDAgPSB0aGF0Ll94MCxcbiAgICAgIHkwID0gdGhhdC5feTAsXG4gICAgICB4MSA9IHRoYXQuX3gxLFxuICAgICAgeTEgPSB0aGF0Ll95MSxcbiAgICAgIGR4ID0gKHgxIC0geDApIC8gMztcbiAgdGhhdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgwICsgZHgsIHkwICsgZHggKiB0MCwgeDEgLSBkeCwgeTEgLSBkeCAqIHQxLCB4MSwgeTEpO1xufVxuXG5mdW5jdGlvbiBNb25vdG9uZVgoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTW9ub3RvbmVYLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID1cbiAgICB0aGlzLl90MCA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDEsIHRoaXMuX3kxKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHBvaW50KHRoaXMsIHRoaXMuX3QwLCBzbG9wZTIodGhpcywgdGhpcy5fdDApKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHQxID0gTmFOO1xuXG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgaWYgKHggPT09IHRoaXMuX3gxICYmIHkgPT09IHRoaXMuX3kxKSByZXR1cm47IC8vIElnbm9yZSBjb2luY2lkZW50IHBvaW50cy5cbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHBvaW50KHRoaXMsIHNsb3BlMih0aGlzLCB0MSA9IHNsb3BlMyh0aGlzLCB4LCB5KSksIHQxKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB0aGlzLl90MCwgdDEgPSBzbG9wZTModGhpcywgeCwgeSkpOyBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICAgIHRoaXMuX3QwID0gdDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gTW9ub3RvbmVZKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IG5ldyBSZWZsZWN0Q29udGV4dChjb250ZXh0KTtcbn1cblxuKE1vbm90b25lWS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vbm90b25lWC5wcm90b3R5cGUpKS5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgTW9ub3RvbmVYLnByb3RvdHlwZS5wb2ludC5jYWxsKHRoaXMsIHksIHgpO1xufTtcblxuZnVuY3Rpb24gUmVmbGVjdENvbnRleHQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUmVmbGVjdENvbnRleHQucHJvdG90eXBlID0ge1xuICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5fY29udGV4dC5tb3ZlVG8oeSwgeCk7IH0sXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7IHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7IH0sXG4gIGxpbmVUbzogZnVuY3Rpb24oeCwgeSkgeyB0aGlzLl9jb250ZXh0LmxpbmVUbyh5LCB4KTsgfSxcbiAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHsgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHkxLCB4MSwgeTIsIHgyLCB5LCB4KTsgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vbm90b25lWChjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTW9ub3RvbmVYKGNvbnRleHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbW9ub3RvbmVZKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBNb25vdG9uZVkoY29udGV4dCk7XG59XG4iLCJmdW5jdGlvbiBOYXR1cmFsKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbk5hdHVyYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3ggPSBbXTtcbiAgICB0aGlzLl95ID0gW107XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4ID0gdGhpcy5feCxcbiAgICAgICAgeSA9IHRoaXMuX3ksXG4gICAgICAgIG4gPSB4Lmxlbmd0aDtcblxuICAgIGlmIChuKSB7XG4gICAgICB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeFswXSwgeVswXSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4WzBdLCB5WzBdKTtcbiAgICAgIGlmIChuID09PSAyKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHhbMV0sIHlbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHB4ID0gY29udHJvbFBvaW50cyh4KSxcbiAgICAgICAgICAgIHB5ID0gY29udHJvbFBvaW50cyh5KTtcbiAgICAgICAgZm9yICh2YXIgaTAgPSAwLCBpMSA9IDE7IGkxIDwgbjsgKytpMCwgKytpMSkge1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhweFswXVtpMF0sIHB5WzBdW2kwXSwgcHhbMV1baTBdLCBweVsxXVtpMF0sIHhbaTFdLCB5W2kxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiBuID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gICAgdGhpcy5feCA9IHRoaXMuX3kgPSBudWxsO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuX3gucHVzaCgreCk7XG4gICAgdGhpcy5feS5wdXNoKCt5KTtcbiAgfVxufTtcblxuLy8gU2VlIGh0dHBzOi8vd3d3LnBhcnRpY2xlaW5jZWxsLmNvbS8yMDEyL2Jlemllci1zcGxpbmVzLyBmb3IgZGVyaXZhdGlvbi5cbmZ1bmN0aW9uIGNvbnRyb2xQb2ludHMoeCkge1xuICB2YXIgaSxcbiAgICAgIG4gPSB4Lmxlbmd0aCAtIDEsXG4gICAgICBtLFxuICAgICAgYSA9IG5ldyBBcnJheShuKSxcbiAgICAgIGIgPSBuZXcgQXJyYXkobiksXG4gICAgICByID0gbmV3IEFycmF5KG4pO1xuICBhWzBdID0gMCwgYlswXSA9IDIsIHJbMF0gPSB4WzBdICsgMiAqIHhbMV07XG4gIGZvciAoaSA9IDE7IGkgPCBuIC0gMTsgKytpKSBhW2ldID0gMSwgYltpXSA9IDQsIHJbaV0gPSA0ICogeFtpXSArIDIgKiB4W2kgKyAxXTtcbiAgYVtuIC0gMV0gPSAyLCBiW24gLSAxXSA9IDcsIHJbbiAtIDFdID0gOCAqIHhbbiAtIDFdICsgeFtuXTtcbiAgZm9yIChpID0gMTsgaSA8IG47ICsraSkgbSA9IGFbaV0gLyBiW2kgLSAxXSwgYltpXSAtPSBtLCByW2ldIC09IG0gKiByW2kgLSAxXTtcbiAgYVtuIC0gMV0gPSByW24gLSAxXSAvIGJbbiAtIDFdO1xuICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAwOyAtLWkpIGFbaV0gPSAocltpXSAtIGFbaSArIDFdKSAvIGJbaV07XG4gIGJbbiAtIDFdID0gKHhbbl0gKyBhW24gLSAxXSkgLyAyO1xuICBmb3IgKGkgPSAwOyBpIDwgbiAtIDE7ICsraSkgYltpXSA9IDIgKiB4W2kgKyAxXSAtIGFbaSArIDFdO1xuICByZXR1cm4gW2EsIGJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTmF0dXJhbChjb250ZXh0KTtcbn1cbiIsImZ1bmN0aW9uIFN0ZXAoY29udGV4dCwgdCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fdCA9IHQ7XG59XG5cblN0ZXAucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKDAgPCB0aGlzLl90ICYmIHRoaXMuX3QgPCAxICYmIHRoaXMuX3BvaW50ID09PSAyKSB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCB0aGlzLl95KTtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgaWYgKHRoaXMuX2xpbmUgPj0gMCkgdGhpcy5fdCA9IDEgLSB0aGlzLl90LCB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmICh0aGlzLl90IDw9IDApIHtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCB5KTtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgeDEgPSB0aGlzLl94ICogKDEgLSB0aGlzLl90KSArIHggKiB0aGlzLl90O1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgxLCB0aGlzLl95KTtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4MSwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3ggPSB4LCB0aGlzLl95ID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IFN0ZXAoY29udGV4dCwgMC41KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBCZWZvcmUoY29udGV4dCkge1xuICByZXR1cm4gbmV3IFN0ZXAoY29udGV4dCwgMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGVwQWZ0ZXIoY29udGV4dCkge1xuICByZXR1cm4gbmV3IFN0ZXAoY29udGV4dCwgMSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAxKSkgcmV0dXJuO1xuICBmb3IgKHZhciBpID0gMSwgaiwgczAsIHMxID0gc2VyaWVzW29yZGVyWzBdXSwgbiwgbSA9IHMxLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHMwID0gczEsIHMxID0gc2VyaWVzW29yZGVyW2ldXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBzMVtqXVsxXSArPSBzMVtqXVswXSA9IGlzTmFOKHMwW2pdWzFdKSA/IHMwW2pdWzBdIDogczBbal1bMV07XG4gICAgfVxuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgdmFyIG4gPSBzZXJpZXMubGVuZ3RoLCBvID0gbmV3IEFycmF5KG4pO1xuICB3aGlsZSAoLS1uID49IDApIG9bbl0gPSBuO1xuICByZXR1cm4gbztcbn1cbiIsImltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnRcIjtcbmltcG9ydCBvZmZzZXROb25lIGZyb20gXCIuL29mZnNldC9ub25lXCI7XG5pbXBvcnQgb3JkZXJOb25lIGZyb20gXCIuL29yZGVyL25vbmVcIjtcblxuZnVuY3Rpb24gc3RhY2tWYWx1ZShkLCBrZXkpIHtcbiAgcmV0dXJuIGRba2V5XTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBrZXlzID0gY29uc3RhbnQoW10pLFxuICAgICAgb3JkZXIgPSBvcmRlck5vbmUsXG4gICAgICBvZmZzZXQgPSBvZmZzZXROb25lLFxuICAgICAgdmFsdWUgPSBzdGFja1ZhbHVlO1xuXG4gIGZ1bmN0aW9uIHN0YWNrKGRhdGEpIHtcbiAgICB2YXIga3ogPSBrZXlzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIGksXG4gICAgICAgIG0gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgbiA9IGt6Lmxlbmd0aCxcbiAgICAgICAgc3ogPSBuZXcgQXJyYXkobiksXG4gICAgICAgIG96O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZm9yICh2YXIga2kgPSBreltpXSwgc2kgPSBzeltpXSA9IG5ldyBBcnJheShtKSwgaiA9IDAsIHNpajsgaiA8IG07ICsraikge1xuICAgICAgICBzaVtqXSA9IHNpaiA9IFswLCArdmFsdWUoZGF0YVtqXSwga2ksIGosIGRhdGEpXTtcbiAgICAgICAgc2lqLmRhdGEgPSBkYXRhW2pdO1xuICAgICAgfVxuICAgICAgc2kua2V5ID0ga2k7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgb3ogPSBvcmRlcihzeik7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN6W296W2ldXS5pbmRleCA9IGk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KHN6LCBveik7XG4gICAgcmV0dXJuIHN6O1xuICB9XG5cbiAgc3RhY2sua2V5cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChrZXlzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChzbGljZS5jYWxsKF8pKSwgc3RhY2spIDoga2V5cztcbiAgfTtcblxuICBzdGFjay52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2YWx1ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBzdGFjaykgOiB2YWx1ZTtcbiAgfTtcblxuICBzdGFjay5vcmRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvcmRlciA9IF8gPT0gbnVsbCA/IG9yZGVyTm9uZSA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoc2xpY2UuY2FsbChfKSksIHN0YWNrKSA6IG9yZGVyO1xuICB9O1xuXG4gIHN0YWNrLm9mZnNldCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvZmZzZXQgPSBfID09IG51bGwgPyBvZmZzZXROb25lIDogXywgc3RhY2spIDogb2Zmc2V0O1xuICB9O1xuXG4gIHJldHVybiBzdGFjaztcbn1cbiIsImltcG9ydCBub25lIGZyb20gXCIuL25vbmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VyaWVzLCBvcmRlcikge1xuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMCkpIHJldHVybjtcbiAgZm9yICh2YXIgaSwgbiwgaiA9IDAsIG0gPSBzZXJpZXNbMF0ubGVuZ3RoLCB5OyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh5ID0gaSA9IDA7IGkgPCBuOyArK2kpIHkgKz0gc2VyaWVzW2ldW2pdWzFdIHx8IDA7XG4gICAgaWYgKHkpIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHNlcmllc1tpXVtqXVsxXSAvPSB5O1xuICB9XG4gIG5vbmUoc2VyaWVzLCBvcmRlcik7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAxKSkgcmV0dXJuO1xuICBmb3IgKHZhciBpLCBqID0gMCwgZCwgZHksIHlwLCB5biwgbiwgbSA9IHNlcmllc1tvcmRlclswXV0ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh5cCA9IHluID0gMCwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgoZHkgPSAoZCA9IHNlcmllc1tvcmRlcltpXV1bal0pWzFdIC0gZFswXSkgPj0gMCkge1xuICAgICAgICBkWzBdID0geXAsIGRbMV0gPSB5cCArPSBkeTtcbiAgICAgIH0gZWxzZSBpZiAoZHkgPCAwKSB7XG4gICAgICAgIGRbMV0gPSB5biwgZFswXSA9IHluICs9IGR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZFswXSA9IHlwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IG5vbmUgZnJvbSBcIi4vbm9uZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAwKSkgcmV0dXJuO1xuICBmb3IgKHZhciBqID0gMCwgczAgPSBzZXJpZXNbb3JkZXJbMF1dLCBuLCBtID0gczAubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHkgPSAwOyBpIDwgbjsgKytpKSB5ICs9IHNlcmllc1tpXVtqXVsxXSB8fCAwO1xuICAgIHMwW2pdWzFdICs9IHMwW2pdWzBdID0gLXkgLyAyO1xuICB9XG4gIG5vbmUoc2VyaWVzLCBvcmRlcik7XG59XG4iLCJpbXBvcnQgbm9uZSBmcm9tIFwiLi9ub25lXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApIHx8ICEoKG0gPSAoczAgPSBzZXJpZXNbb3JkZXJbMF1dKS5sZW5ndGgpID4gMCkpIHJldHVybjtcbiAgZm9yICh2YXIgeSA9IDAsIGogPSAxLCBzMCwgbSwgbjsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGkgPSAwLCBzMSA9IDAsIHMyID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIHNpID0gc2VyaWVzW29yZGVyW2ldXSxcbiAgICAgICAgICBzaWowID0gc2lbal1bMV0gfHwgMCxcbiAgICAgICAgICBzaWoxID0gc2lbaiAtIDFdWzFdIHx8IDAsXG4gICAgICAgICAgczMgPSAoc2lqMCAtIHNpajEpIC8gMjtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaTsgKytrKSB7XG4gICAgICAgIHZhciBzayA9IHNlcmllc1tvcmRlcltrXV0sXG4gICAgICAgICAgICBza2owID0gc2tbal1bMV0gfHwgMCxcbiAgICAgICAgICAgIHNrajEgPSBza1tqIC0gMV1bMV0gfHwgMDtcbiAgICAgICAgczMgKz0gc2tqMCAtIHNrajE7XG4gICAgICB9XG4gICAgICBzMSArPSBzaWowLCBzMiArPSBzMyAqIHNpajA7XG4gICAgfVxuICAgIHMwW2ogLSAxXVsxXSArPSBzMFtqIC0gMV1bMF0gPSB5O1xuICAgIGlmIChzMSkgeSAtPSBzMiAvIHMxO1xuICB9XG4gIHMwW2ogLSAxXVsxXSArPSBzMFtqIC0gMV1bMF0gPSB5O1xuICBub25lKHNlcmllcywgb3JkZXIpO1xufVxuIiwiaW1wb3J0IG5vbmUgZnJvbSBcIi4vbm9uZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgdmFyIHN1bXMgPSBzZXJpZXMubWFwKHN1bSk7XG4gIHJldHVybiBub25lKHNlcmllcykuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBzdW1zW2FdIC0gc3Vtc1tiXTsgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdW0oc2VyaWVzKSB7XG4gIHZhciBzID0gMCwgaSA9IC0xLCBuID0gc2VyaWVzLmxlbmd0aCwgdjtcbiAgd2hpbGUgKCsraSA8IG4pIGlmICh2ID0gK3Nlcmllc1tpXVsxXSkgcyArPSB2O1xuICByZXR1cm4gcztcbn1cbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlcmllcykge1xuICByZXR1cm4gYXNjZW5kaW5nKHNlcmllcykucmV2ZXJzZSgpO1xufVxuIiwiaW1wb3J0IG5vbmUgZnJvbSBcIi4vbm9uZVwiO1xuaW1wb3J0IHtzdW19IGZyb20gXCIuL2FzY2VuZGluZ1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgdmFyIG4gPSBzZXJpZXMubGVuZ3RoLFxuICAgICAgaSxcbiAgICAgIGosXG4gICAgICBzdW1zID0gc2VyaWVzLm1hcChzdW0pLFxuICAgICAgb3JkZXIgPSBub25lKHNlcmllcykuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBzdW1zW2JdIC0gc3Vtc1thXTsgfSksXG4gICAgICB0b3AgPSAwLFxuICAgICAgYm90dG9tID0gMCxcbiAgICAgIHRvcHMgPSBbXSxcbiAgICAgIGJvdHRvbXMgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgaiA9IG9yZGVyW2ldO1xuICAgIGlmICh0b3AgPCBib3R0b20pIHtcbiAgICAgIHRvcCArPSBzdW1zW2pdO1xuICAgICAgdG9wcy5wdXNoKGopO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3R0b20gKz0gc3Vtc1tqXTtcbiAgICAgIGJvdHRvbXMucHVzaChqKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYm90dG9tcy5yZXZlcnNlKCkuY29uY2F0KHRvcHMpO1xufVxuIiwiaW1wb3J0IG5vbmUgZnJvbSBcIi4vbm9uZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgcmV0dXJuIG5vbmUoc2VyaWVzKS5yZXZlcnNlKCk7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgYXJjfSBmcm9tIFwiLi9hcmNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBhcmVhfSBmcm9tIFwiLi9hcmVhXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbGluZX0gZnJvbSBcIi4vbGluZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHBpZX0gZnJvbSBcIi4vcGllXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYXJlYVJhZGlhbCwgZGVmYXVsdCBhcyByYWRpYWxBcmVhfSBmcm9tIFwiLi9hcmVhUmFkaWFsXCI7IC8vIE5vdGU6IHJhZGlhbEFyZWEgaXMgZGVwcmVjYXRlZCFcbmV4cG9ydCB7ZGVmYXVsdCBhcyBsaW5lUmFkaWFsLCBkZWZhdWx0IGFzIHJhZGlhbExpbmV9IGZyb20gXCIuL2xpbmVSYWRpYWxcIjsgLy8gTm90ZTogcmFkaWFsTGluZSBpcyBkZXByZWNhdGVkIVxuZXhwb3J0IHtkZWZhdWx0IGFzIHBvaW50UmFkaWFsfSBmcm9tIFwiLi9wb2ludFJhZGlhbFwiO1xuZXhwb3J0IHtsaW5rSG9yaXpvbnRhbCwgbGlua1ZlcnRpY2FsLCBsaW5rUmFkaWFsfSBmcm9tIFwiLi9saW5rL2luZGV4XCI7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2wsIHN5bWJvbHN9IGZyb20gXCIuL3N5bWJvbFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbENpcmNsZX0gZnJvbSBcIi4vc3ltYm9sL2NpcmNsZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbENyb3NzfSBmcm9tIFwiLi9zeW1ib2wvY3Jvc3NcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzeW1ib2xEaWFtb25kfSBmcm9tIFwiLi9zeW1ib2wvZGlhbW9uZFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbFNxdWFyZX0gZnJvbSBcIi4vc3ltYm9sL3NxdWFyZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbFN0YXJ9IGZyb20gXCIuL3N5bWJvbC9zdGFyXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3ltYm9sVHJpYW5nbGV9IGZyb20gXCIuL3N5bWJvbC90cmlhbmdsZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN5bWJvbFd5ZX0gZnJvbSBcIi4vc3ltYm9sL3d5ZVwiO1xuXG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVCYXNpc0Nsb3NlZH0gZnJvbSBcIi4vY3VydmUvYmFzaXNDbG9zZWRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUJhc2lzT3Blbn0gZnJvbSBcIi4vY3VydmUvYmFzaXNPcGVuXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVCYXNpc30gZnJvbSBcIi4vY3VydmUvYmFzaXNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUJ1bmRsZX0gZnJvbSBcIi4vY3VydmUvYnVuZGxlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVDYXJkaW5hbENsb3NlZH0gZnJvbSBcIi4vY3VydmUvY2FyZGluYWxDbG9zZWRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhcmRpbmFsT3Blbn0gZnJvbSBcIi4vY3VydmUvY2FyZGluYWxPcGVuXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY3VydmVDYXJkaW5hbH0gZnJvbSBcIi4vY3VydmUvY2FyZGluYWxcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhdG11bGxSb21DbG9zZWR9IGZyb20gXCIuL2N1cnZlL2NhdG11bGxSb21DbG9zZWRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUNhdG11bGxSb21PcGVufSBmcm9tIFwiLi9jdXJ2ZS9jYXRtdWxsUm9tT3BlblwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlQ2F0bXVsbFJvbX0gZnJvbSBcIi4vY3VydmUvY2F0bXVsbFJvbVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlTGluZWFyQ2xvc2VkfSBmcm9tIFwiLi9jdXJ2ZS9saW5lYXJDbG9zZWRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjdXJ2ZUxpbmVhcn0gZnJvbSBcIi4vY3VydmUvbGluZWFyXCI7XG5leHBvcnQge21vbm90b25lWCBhcyBjdXJ2ZU1vbm90b25lWCwgbW9ub3RvbmVZIGFzIGN1cnZlTW9ub3RvbmVZfSBmcm9tIFwiLi9jdXJ2ZS9tb25vdG9uZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlTmF0dXJhbH0gZnJvbSBcIi4vY3VydmUvbmF0dXJhbFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGN1cnZlU3RlcCwgc3RlcEFmdGVyIGFzIGN1cnZlU3RlcEFmdGVyLCBzdGVwQmVmb3JlIGFzIGN1cnZlU3RlcEJlZm9yZX0gZnJvbSBcIi4vY3VydmUvc3RlcFwiO1xuXG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2t9IGZyb20gXCIuL3N0YWNrXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2tPZmZzZXRFeHBhbmR9IGZyb20gXCIuL29mZnNldC9leHBhbmRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09mZnNldERpdmVyZ2luZ30gZnJvbSBcIi4vb2Zmc2V0L2RpdmVyZ2luZ1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT2Zmc2V0Tm9uZX0gZnJvbSBcIi4vb2Zmc2V0L25vbmVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09mZnNldFNpbGhvdWV0dGV9IGZyb20gXCIuL29mZnNldC9zaWxob3VldHRlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2tPZmZzZXRXaWdnbGV9IGZyb20gXCIuL29mZnNldC93aWdnbGVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09yZGVyQXNjZW5kaW5nfSBmcm9tIFwiLi9vcmRlci9hc2NlbmRpbmdcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGFja09yZGVyRGVzY2VuZGluZ30gZnJvbSBcIi4vb3JkZXIvZGVzY2VuZGluZ1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT3JkZXJJbnNpZGVPdXR9IGZyb20gXCIuL29yZGVyL2luc2lkZU91dFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0YWNrT3JkZXJOb25lfSBmcm9tIFwiLi9vcmRlci9ub25lXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RhY2tPcmRlclJldmVyc2V9IGZyb20gXCIuL29yZGVyL3JldmVyc2VcIjtcbiIsInZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cbnZhciBQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9pbnQoX3JlZikge1xuICAgIHZhciBfcmVmJHggPSBfcmVmLngsXG4gICAgICAgIHggPSBfcmVmJHggPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHgsXG4gICAgICAgIF9yZWYkeSA9IF9yZWYueSxcbiAgICAgICAgeSA9IF9yZWYkeSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkeTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQb2ludCk7XG5cbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhQb2ludCwgW3tcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0aGlzLngsXG4gICAgICAgIHk6IHRoaXMueVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0FycmF5JCQxKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLngsIHRoaXMueV07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQb2ludDtcbn0oKTtcblxuZXhwb3J0IHsgUG9pbnQgfTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgYXJjLCBwaWUsIGxpbmUsIHJhZGlhbExpbmUsIGFyZWEsIHN0YWNrLCBzdGFja09yZGVyQXNjZW5kaW5nLCBzdGFja09yZGVyRGVzY2VuZGluZywgc3RhY2tPcmRlckluc2lkZU91dCwgc3RhY2tPcmRlck5vbmUsIHN0YWNrT3JkZXJSZXZlcnNlLCBzdGFja09mZnNldEV4cGFuZCwgc3RhY2tPZmZzZXREaXZlcmdpbmcsIHN0YWNrT2Zmc2V0Tm9uZSwgc3RhY2tPZmZzZXRTaWxob3VldHRlLCBzdGFja09mZnNldFdpZ2dsZSwgbGlua0hvcml6b250YWwsIGxpbmtWZXJ0aWNhbCwgbGlua1JhZGlhbCB9IGZyb20gJ2QzLXNoYXBlJztcbmltcG9ydCB7IEdyb3VwIH0gZnJvbSAnQHZ4L2dyb3VwJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnQHZ4L3BvaW50JztcbmltcG9ydCB7IGN1cnZlTGluZWFyIH0gZnJvbSAnQHZ4L2N1cnZlJztcbmltcG9ydCB7IHBhdGggfSBmcm9tICdkMy1wYXRoJztcblxuZnVuY3Rpb24gY2FsbE9yVmFsdWUobWF5YmVGbiwgZGF0YSkge1xuICBpZiAodHlwZW9mIG1heWJlRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVGbihkYXRhKTtcbiAgfVxuICByZXR1cm4gbWF5YmVGbjtcbn1cblxuZnVuY3Rpb24gYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMocmVzdFByb3BzKS5yZWR1Y2UoZnVuY3Rpb24gKHJldCwgY3VyKSB7XG4gICAgcmV0W2N1cl0gPSBjYWxsT3JWYWx1ZShyZXN0UHJvcHNbY3VyXSwgZGF0YSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSwge30pO1xufVxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xuICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlO1xuICAgIHRhcmdldFtpXSA9IG9ialtpXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgdG9Db25zdW1hYmxlQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXJyKTtcbiAgfVxufTtcblxuQXJjLnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBkYXRhOiBQcm9wVHlwZXMuYW55LFxuICBjZW50cm9pZDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgaW5uZXJSYWRpdXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIG91dGVyUmFkaXVzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBjb3JuZXJSYWRpdXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHN0YXJ0QW5nbGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIGVuZEFuZ2xlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBwYWRBbmdsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgcGFkUmFkaXVzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pXG59O1xuXG5mdW5jdGlvbiBBcmMoX3JlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY2VudHJvaWQgPSBfcmVmLmNlbnRyb2lkLFxuICAgICAgaW5uZXJSYWRpdXMgPSBfcmVmLmlubmVyUmFkaXVzLFxuICAgICAgb3V0ZXJSYWRpdXMgPSBfcmVmLm91dGVyUmFkaXVzLFxuICAgICAgY29ybmVyUmFkaXVzID0gX3JlZi5jb3JuZXJSYWRpdXMsXG4gICAgICBzdGFydEFuZ2xlID0gX3JlZi5zdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUgPSBfcmVmLmVuZEFuZ2xlLFxuICAgICAgcGFkQW5nbGUgPSBfcmVmLnBhZEFuZ2xlLFxuICAgICAgcGFkUmFkaXVzID0gX3JlZi5wYWRSYWRpdXMsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NsYXNzTmFtZScsICdkYXRhJywgJ2NlbnRyb2lkJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgJ2Nvcm5lclJhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJywgJ3BhZEFuZ2xlJywgJ3BhZFJhZGl1cyddKTtcblxuICB2YXIgYXJjJCQxID0gYXJjKCk7XG4gIGlmIChjZW50cm9pZCkgYXJjJCQxLmNlbnRyb2lkKGNlbnRyb2lkKTtcbiAgaWYgKGlubmVyUmFkaXVzKSBhcmMkJDEuaW5uZXJSYWRpdXMoaW5uZXJSYWRpdXMpO1xuICBpZiAob3V0ZXJSYWRpdXMpIGFyYyQkMS5vdXRlclJhZGl1cyhvdXRlclJhZGl1cyk7XG4gIGlmIChjb3JuZXJSYWRpdXMpIGFyYyQkMS5jb3JuZXJSYWRpdXMoY29ybmVyUmFkaXVzKTtcbiAgaWYgKHN0YXJ0QW5nbGUpIGFyYyQkMS5zdGFydEFuZ2xlKHN0YXJ0QW5nbGUpO1xuICBpZiAoZW5kQW5nbGUpIGFyYyQkMS5lbmRBbmdsZShlbmRBbmdsZSk7XG4gIGlmIChwYWRBbmdsZSkgYXJjJCQxLnBhZEFuZ2xlKHBhZEFuZ2xlKTtcbiAgaWYgKHBhZFJhZGl1cykgYXJjJCQxLnBhZFJhZGl1cyhwYWRSYWRpdXMpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHsgY2xhc3NOYW1lOiBjeCgndngtYXJjJywgY2xhc3NOYW1lKSwgZDogYXJjJCQxKGRhdGEpIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cblBpZS5wcm9wVHlwZXMgPSB7XG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXksXG4gIGNlbnRyb2lkOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBpbm5lclJhZGl1czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgb3V0ZXJSYWRpdXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIGNvcm5lclJhZGl1czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgc3RhcnRBbmdsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgZW5kQW5nbGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHBhZEFuZ2xlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBwYWRSYWRpdXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHBpZVNvcnQ6IFByb3BUeXBlcy5mdW5jLFxuICBwaWVTb3J0VmFsdWVzOiBQcm9wVHlwZXMuZnVuYyxcbiAgcGllVmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gUGllKF9yZWYpIHtcbiAgdmFyIF9yZWYkY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmJGNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJGNsYXNzTmFtZSxcbiAgICAgIF9yZWYkdG9wID0gX3JlZi50b3AsXG4gICAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdG9wLFxuICAgICAgX3JlZiRsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbGVmdCA9IF9yZWYkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkbGVmdCxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjZW50cm9pZCA9IF9yZWYuY2VudHJvaWQsXG4gICAgICBfcmVmJGlubmVyUmFkaXVzID0gX3JlZi5pbm5lclJhZGl1cyxcbiAgICAgIGlubmVyUmFkaXVzID0gX3JlZiRpbm5lclJhZGl1cyA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkaW5uZXJSYWRpdXMsXG4gICAgICBvdXRlclJhZGl1cyA9IF9yZWYub3V0ZXJSYWRpdXMsXG4gICAgICBjb3JuZXJSYWRpdXMgPSBfcmVmLmNvcm5lclJhZGl1cyxcbiAgICAgIF9yZWYkc3RhcnRBbmdsZSA9IF9yZWYuc3RhcnRBbmdsZSxcbiAgICAgIHN0YXJ0QW5nbGUgPSBfcmVmJHN0YXJ0QW5nbGUgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSA9IF9yZWYuZW5kQW5nbGUsXG4gICAgICBwYWRBbmdsZSA9IF9yZWYucGFkQW5nbGUsXG4gICAgICBwYWRSYWRpdXMgPSBfcmVmLnBhZFJhZGl1cyxcbiAgICAgIHBpZVNvcnQgPSBfcmVmLnBpZVNvcnQsXG4gICAgICBwaWVTb3J0VmFsdWVzID0gX3JlZi5waWVTb3J0VmFsdWVzLFxuICAgICAgcGllVmFsdWUgPSBfcmVmLnBpZVZhbHVlLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydjbGFzc05hbWUnLCAndG9wJywgJ2xlZnQnLCAnZGF0YScsICdjZW50cm9pZCcsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cycsICdjb3JuZXJSYWRpdXMnLCAnc3RhcnRBbmdsZScsICdlbmRBbmdsZScsICdwYWRBbmdsZScsICdwYWRSYWRpdXMnLCAncGllU29ydCcsICdwaWVTb3J0VmFsdWVzJywgJ3BpZVZhbHVlJywgJ2NoaWxkcmVuJ10pO1xuXG4gIHZhciBwYXRoJCQxID0gYXJjKCk7XG4gIHBhdGgkJDEuaW5uZXJSYWRpdXMoaW5uZXJSYWRpdXMpO1xuICBpZiAob3V0ZXJSYWRpdXMpIHBhdGgkJDEub3V0ZXJSYWRpdXMob3V0ZXJSYWRpdXMpO1xuICBpZiAoY29ybmVyUmFkaXVzKSBwYXRoJCQxLmNvcm5lclJhZGl1cyhjb3JuZXJSYWRpdXMpO1xuICBpZiAocGFkUmFkaXVzKSBwYXRoJCQxLnBhZFJhZGl1cyhwYWRSYWRpdXMpO1xuICB2YXIgcGllJCQxID0gcGllKCk7XG4gIGlmIChwaWVTb3J0ICE9PSB1bmRlZmluZWQpIHBpZSQkMS5zb3J0KHBpZVNvcnQpO1xuICBpZiAocGllU29ydFZhbHVlcyAhPT0gdW5kZWZpbmVkKSBwaWUkJDEuc29ydFZhbHVlcyhwaWVTb3J0VmFsdWVzKTtcbiAgaWYgKHBpZVZhbHVlKSBwaWUkJDEudmFsdWUocGllVmFsdWUpO1xuICBpZiAocGFkQW5nbGUgIT0gbnVsbCkgcGllJCQxLnBhZEFuZ2xlKHBhZEFuZ2xlKTtcbiAgaWYgKHN0YXJ0QW5nbGUgIT0gbnVsbCkgcGllJCQxLnN0YXJ0QW5nbGUoc3RhcnRBbmdsZSk7XG4gIGlmIChlbmRBbmdsZSAhPSBudWxsKSBwaWUkJDEuZW5kQW5nbGUoZW5kQW5nbGUpO1xuICB2YXIgYXJjcyA9IHBpZSQkMShkYXRhKTtcbiAgdmFyIHJlbmRlckZ1bmN0aW9uQXJnID0ge1xuICAgIGFyY3M6IGFyY3MsXG4gICAgZ2VuZXJhdGVQYXRoUHJvcHM6IGZ1bmN0aW9uIGdlbmVyYXRlUGF0aFByb3BzKGFyYyQkMSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LXBpZS1hcmMnLCBjbGFzc05hbWUpLFxuICAgICAgICBkOiBwYXRoJCQxKGFyYyQkMSlcbiAgICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIF9leHRlbmRzKHt9LCBhcmMkJDEsIHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjZW50cm9pZDogY2VudHJvaWQgPyBwYXRoJCQxLmNlbnRyb2lkKGFyYyQkMSkgOiB1bmRlZmluZWRcbiAgICAgIH0pKSk7XG4gICAgfSxcbiAgICBnZW5lcmF0ZUNlbnRyb2lkOiBmdW5jdGlvbiBnZW5lcmF0ZUNlbnRyb2lkKGFyYyQkMSkge1xuICAgICAgcmV0dXJuIGNlbnRyb2lkICYmIGNlbnRyb2lkKHBhdGgkJDEuY2VudHJvaWQoYXJjJCQxKSwgYXJjJCQxKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgY2xhc3NOYW1lOiAndngtcGllLWFyY3MtZ3JvdXAnLCB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgIGNoaWxkcmVuID8gY2hpbGRyZW4ocmVuZGVyRnVuY3Rpb25BcmcpIDogYXJjcy5tYXAoZnVuY3Rpb24gKGFyYyQkMSwgaSkge1xuICAgICAgdmFyIHBhdGhQcm9wcyA9IHJlbmRlckZ1bmN0aW9uQXJnLmdlbmVyYXRlUGF0aFByb3BzKGFyYyQkMSwgaSk7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2cnLFxuICAgICAgICB7IGtleTogJ3BpZS1hcmMtJyArIGkgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIHBhdGhQcm9wcyksXG4gICAgICAgIHJlbmRlckZ1bmN0aW9uQXJnLmdlbmVyYXRlQ2VudHJvaWQoYXJjJCQxKVxuICAgICAgKTtcbiAgICB9KVxuICApO1xufVxuXG5MaW5lLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5lKF9yZWYpIHtcbiAgdmFyIF9yZWYkZnJvbSA9IF9yZWYuZnJvbSxcbiAgICAgIGZyb20gPSBfcmVmJGZyb20gPT09IHVuZGVmaW5lZCA/IG5ldyBQb2ludCh7IHg6IDAsIHk6IDAgfSkgOiBfcmVmJGZyb20sXG4gICAgICBfcmVmJHRvID0gX3JlZi50byxcbiAgICAgIHRvID0gX3JlZiR0byA9PT0gdW5kZWZpbmVkID8gbmV3IFBvaW50KHsgeDogMSwgeTogMSB9KSA6IF9yZWYkdG8sXG4gICAgICBfcmVmJHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlID0gX3JlZiRzdHJva2UgPT09IHVuZGVmaW5lZCA/ICdibGFjaycgOiBfcmVmJHN0cm9rZSxcbiAgICAgIF9yZWYkc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmJHN0cm9rZVdpZHRoID09PSB1bmRlZmluZWQgPyAxIDogX3JlZiRzdHJva2VXaWR0aCxcbiAgICAgIF9yZWYkc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmJHN0cm9rZURhc2hhcnJheSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJHN0cm9rZURhc2hhcnJheSxcbiAgICAgIF9yZWYkdHJhbnNmb3JtID0gX3JlZi50cmFuc2Zvcm0sXG4gICAgICB0cmFuc2Zvcm0gPSBfcmVmJHRyYW5zZm9ybSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJHRyYW5zZm9ybSxcbiAgICAgIF9yZWYkY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmJGNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJGNsYXNzTmFtZSxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2Zyb20nLCAndG8nLCAnc3Ryb2tlJywgJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZURhc2hhcnJheScsICd0cmFuc2Zvcm0nLCAnY2xhc3NOYW1lJywgJ2RhdGEnLCAnaW5uZXJSZWYnXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2xpbmUnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5lJywgY2xhc3NOYW1lKSxcbiAgICB4MTogZnJvbS54LFxuICAgIHkxOiBmcm9tLnksXG4gICAgeDI6IHRvLngsXG4gICAgeTI6IHRvLnksXG4gICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbkxpbmVQYXRoLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICB4U2NhbGU6IFByb3BUeXBlcy5mdW5jLFxuICB5U2NhbGU6IFByb3BUeXBlcy5mdW5jLFxuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXksXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgZGVmaW5lZDogUHJvcFR5cGVzLmZ1bmMsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGdseXBoOiBQcm9wVHlwZXMuZnVuYyxcbiAgY3VydmU6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5lUGF0aChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgeFNjYWxlID0gX3JlZi54U2NhbGUsXG4gICAgICB5U2NhbGUgPSBfcmVmLnlTY2FsZSxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgX3JlZiRkZWZpbmVkID0gX3JlZi5kZWZpbmVkLFxuICAgICAgZGVmaW5lZCA9IF9yZWYkZGVmaW5lZCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IDogX3JlZiRkZWZpbmVkLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBfcmVmJHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlID0gX3JlZiRzdHJva2UgPT09IHVuZGVmaW5lZCA/ICdzdGVlbGJsdWUnIDogX3JlZiRzdHJva2UsXG4gICAgICBfcmVmJHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZiRzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkID8gMiA6IF9yZWYkc3Ryb2tlV2lkdGgsXG4gICAgICBfcmVmJHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZiRzdHJva2VEYXNoYXJyYXkgPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiRzdHJva2VEYXNoYXJyYXksXG4gICAgICBfcmVmJHN0cm9rZURhc2hvZmZzZXQgPSBfcmVmLnN0cm9rZURhc2hvZmZzZXQsXG4gICAgICBzdHJva2VEYXNob2Zmc2V0ID0gX3JlZiRzdHJva2VEYXNob2Zmc2V0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRzdHJva2VEYXNob2Zmc2V0LFxuICAgICAgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxuICAgICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdW5kZWZpbmVkID8gJ25vbmUnIDogX3JlZiRmaWxsLFxuICAgICAgX3JlZiRjdXJ2ZSA9IF9yZWYuY3VydmUsXG4gICAgICBjdXJ2ZSA9IF9yZWYkY3VydmUgPT09IHVuZGVmaW5lZCA/IGN1cnZlTGluZWFyIDogX3JlZiRjdXJ2ZSxcbiAgICAgIGdseXBoID0gX3JlZi5nbHlwaCxcbiAgICAgIGlubmVyUmVmID0gX3JlZi5pbm5lclJlZixcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2hpbGRyZW4nLCAnZGF0YScsICd4U2NhbGUnLCAneVNjYWxlJywgJ3gnLCAneScsICdkZWZpbmVkJywgJ2NsYXNzTmFtZScsICdzdHJva2UnLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZURhc2hvZmZzZXQnLCAnZmlsbCcsICdjdXJ2ZScsICdnbHlwaCcsICdpbm5lclJlZiddKTtcblxuICB2YXIgcGF0aCQkMSA9IGxpbmUoKS54KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geFNjYWxlKHguYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSkueShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHlTY2FsZSh5LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pLmRlZmluZWQoZGVmaW5lZCkuY3VydmUoY3VydmUpO1xuICBpZiAoY2hpbGRyZW4pIHJldHVybiBjaGlsZHJlbih7IHBhdGg6IHBhdGgkJDEgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICdnJyxcbiAgICBudWxsLFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgY2xhc3NOYW1lOiBjeCgndngtbGluZXBhdGgnLCBjbGFzc05hbWUpLFxuICAgICAgZDogcGF0aCQkMShkYXRhKSxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgICBzdHJva2VEYXNob2Zmc2V0OiBzdHJva2VEYXNob2Zmc2V0LFxuICAgICAgZmlsbDogZmlsbFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSksXG4gICAgZ2x5cGggJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdnJyxcbiAgICAgIHsgY2xhc3NOYW1lOiAndngtbGluZXBhdGgtZ2x5cGhzJyB9LFxuICAgICAgZGF0YS5tYXAoZ2x5cGgpXG4gICAgKVxuICApO1xufVxuXG5MaW5lUmFkaWFsLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5lUmFkaWFsKF9yZWYpIHtcbiAgdmFyIF9yZWYkY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmJGNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJGNsYXNzTmFtZSxcbiAgICAgIGFuZ2xlID0gX3JlZi5hbmdsZSxcbiAgICAgIHJhZGl1cyA9IF9yZWYucmFkaXVzLFxuICAgICAgZGVmaW5lZCA9IF9yZWYuZGVmaW5lZCxcbiAgICAgIGN1cnZlID0gX3JlZi5jdXJ2ZSxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NsYXNzTmFtZScsICdhbmdsZScsICdyYWRpdXMnLCAnZGVmaW5lZCcsICdjdXJ2ZScsICdkYXRhJywgJ2lubmVyUmVmJ10pO1xuXG4gIHZhciBwYXRoJCQxID0gcmFkaWFsTGluZSgpO1xuICBpZiAoYW5nbGUpIHBhdGgkJDEuYW5nbGUoYW5nbGUpO1xuICBpZiAocmFkaXVzKSBwYXRoJCQxLnJhZGl1cyhyYWRpdXMpO1xuICBpZiAoZGVmaW5lZCkgcGF0aCQkMS5kZWZpbmVkKGRlZmluZWQpO1xuICBpZiAoY3VydmUpIHBhdGgkJDEuY3VydmUoY3VydmUpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAnZycsXG4gICAgbnVsbCxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgcmVmOiBpbm5lclJlZixcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmUtcmFkaWFsJywgY2xhc3NOYW1lKSxcbiAgICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpXG4gICk7XG59XG5cbkFyZWEucHJvcFR5cGVzID0ge1xuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeDA6IFByb3BUeXBlcy5mdW5jLFxuICB4MTogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICB5MDogUHJvcFR5cGVzLmZ1bmMsXG4gIHkxOiBQcm9wVHlwZXMuZnVuYyxcbiAgeFNjYWxlOiBQcm9wVHlwZXMuZnVuYyxcbiAgeVNjYWxlOiBQcm9wVHlwZXMuZnVuYyxcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LFxuICBkZWZpbmVkOiBQcm9wVHlwZXMuZnVuYyxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmFycmF5XSksXG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgc3Ryb2tlRGFzaGFycmF5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHJva2VXaWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgc3Ryb2tlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBmaWxsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjdXJ2ZTogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIEFyZWEoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHgwID0gX3JlZi54MCxcbiAgICAgIHgxID0gX3JlZi54MSxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB5MCA9IF9yZWYueTAsXG4gICAgICB5MSA9IF9yZWYueTEsXG4gICAgICB4U2NhbGUgPSBfcmVmLnhTY2FsZSxcbiAgICAgIHlTY2FsZSA9IF9yZWYueVNjYWxlLFxuICAgICAgX3JlZiRkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgZGF0YSA9IF9yZWYkZGF0YSA9PT0gdW5kZWZpbmVkID8gW10gOiBfcmVmJGRhdGEsXG4gICAgICBfcmVmJGRlZmluZWQgPSBfcmVmLmRlZmluZWQsXG4gICAgICBkZWZpbmVkID0gX3JlZiRkZWZpbmVkID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gOiBfcmVmJGRlZmluZWQsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgX3JlZiRzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VXaWR0aCA9IF9yZWYkc3Ryb2tlV2lkdGggPT09IHVuZGVmaW5lZCA/IDIgOiBfcmVmJHN0cm9rZVdpZHRoLFxuICAgICAgX3JlZiRzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYkc3Ryb2tlID09PSB1bmRlZmluZWQgPyAnYmxhY2snIDogX3JlZiRzdHJva2UsXG4gICAgICBfcmVmJGZpbGwgPSBfcmVmLmZpbGwsXG4gICAgICBmaWxsID0gX3JlZiRmaWxsID09PSB1bmRlZmluZWQgPyAncmdiYSgwLDAsMCwwLjMpJyA6IF9yZWYkZmlsbCxcbiAgICAgIGN1cnZlID0gX3JlZi5jdXJ2ZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZi5pbm5lclJlZixcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2hpbGRyZW4nLCAneCcsICd4MCcsICd4MScsICd5JywgJ3kwJywgJ3kxJywgJ3hTY2FsZScsICd5U2NhbGUnLCAnZGF0YScsICdkZWZpbmVkJywgJ2NsYXNzTmFtZScsICdzdHJva2VEYXNoYXJyYXknLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlJywgJ2ZpbGwnLCAnY3VydmUnLCAnaW5uZXJSZWYnXSk7XG5cbiAgdmFyIHBhdGgkJDEgPSBhcmVhKCk7XG4gIGlmICh4KSBwYXRoJCQxLngoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4U2NhbGUoeC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KTtcbiAgaWYgKHgwKSBwYXRoJCQxLngwKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geFNjYWxlKHgwLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pO1xuICBpZiAoeDEpIHBhdGgkJDEueDEoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4U2NhbGUoeDEuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSk7XG4gIGlmICh5KSBwYXRoJCQxLnkoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB5U2NhbGUoeS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KTtcbiAgaWYgKHkwKSBwYXRoJCQxLnkwKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geVNjYWxlKHkwLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pO1xuICBpZiAoeTEpIHBhdGgkJDEueTEoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB5U2NhbGUoeTEuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSk7XG4gIGlmIChkZWZpbmVkKSBwYXRoJCQxLmRlZmluZWQoZGVmaW5lZCk7XG4gIGlmIChjdXJ2ZSkgcGF0aCQkMS5jdXJ2ZShjdXJ2ZSk7XG4gIGlmIChjaGlsZHJlbikgcmV0dXJuIGNoaWxkcmVuKHsgcGF0aDogcGF0aCQkMSB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2cnLFxuICAgIG51bGwsXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICAgIHJlZjogaW5uZXJSZWYsXG4gICAgICBjbGFzc05hbWU6IGN4KCd2eC1hcmVhJywgY2xhc3NOYW1lKSxcbiAgICAgIGQ6IHBhdGgkJDEoZGF0YSksXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgZmlsbDogZmlsbFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSlcbiAgKTtcbn1cblxuQXJlYUNsb3NlZC5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gQXJlYUNsb3NlZChfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHkwID0gX3JlZi55MCxcbiAgICAgIHhTY2FsZSA9IF9yZWYueFNjYWxlLFxuICAgICAgeVNjYWxlID0gX3JlZi55U2NhbGUsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgX3JlZiRkZWZpbmVkID0gX3JlZi5kZWZpbmVkLFxuICAgICAgZGVmaW5lZCA9IF9yZWYkZGVmaW5lZCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IDogX3JlZiRkZWZpbmVkLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIF9yZWYkc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmJHN0cm9rZVdpZHRoID09PSB1bmRlZmluZWQgPyAyIDogX3JlZiRzdHJva2VXaWR0aCxcbiAgICAgIF9yZWYkc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2UgPSBfcmVmJHN0cm9rZSA9PT0gdW5kZWZpbmVkID8gJ2JsYWNrJyA6IF9yZWYkc3Ryb2tlLFxuICAgICAgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxuICAgICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdW5kZWZpbmVkID8gJ3JnYmEoMCwwLDAsMC4zKScgOiBfcmVmJGZpbGwsXG4gICAgICBjdXJ2ZSA9IF9yZWYuY3VydmUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3gnLCAneScsICd5MCcsICd4U2NhbGUnLCAneVNjYWxlJywgJ2RhdGEnLCAnZGVmaW5lZCcsICdjbGFzc05hbWUnLCAnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZScsICdmaWxsJywgJ2N1cnZlJywgJ2lubmVyUmVmJ10pO1xuXG4gIHZhciBwYXRoJCQxID0gYXJlYSgpLngoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4U2NhbGUoeC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KS55MCh5MCB8fCB5U2NhbGUucmFuZ2UoKVswXSkueTEoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB5U2NhbGUoeS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KS5kZWZpbmVkKGRlZmluZWQpO1xuICBpZiAoY3VydmUpIHBhdGgkJDEuY3VydmUoY3VydmUpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAnZycsXG4gICAgbnVsbCxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgcmVmOiBpbm5lclJlZixcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWFyZWEtY2xvc2VkJywgY2xhc3NOYW1lKSxcbiAgICAgIGQ6IHBhdGgkJDEoZGF0YSksXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgZmlsbDogZmlsbFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSlcbiAgKTtcbn1cblxuQXJlYVN0YWNrLnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGtleXM6IFByb3BUeXBlcy5hcnJheSxcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LFxuICBjdXJ2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIGRlZmluZWQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuYm9vbF0pLFxuICB4OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICB4MDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgeDE6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHkwOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICB5MTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgZ2x5cGg6IFByb3BUeXBlcy5ib29sLFxuICByZXZlcnNlOiBQcm9wVHlwZXMuYm9vbFxufTtcblxuZnVuY3Rpb24gQXJlYVN0YWNrKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAga2V5cyA9IF9yZWYua2V5cyxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjdXJ2ZSA9IF9yZWYuY3VydmUsXG4gICAgICBkZWZpbmVkID0gX3JlZi5kZWZpbmVkLFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHgwID0gX3JlZi54MCxcbiAgICAgIHgxID0gX3JlZi54MSxcbiAgICAgIHkwID0gX3JlZi55MCxcbiAgICAgIHkxID0gX3JlZi55MSxcbiAgICAgIGdseXBoID0gX3JlZi5nbHlwaCxcbiAgICAgIF9yZWYkcmV2ZXJzZSA9IF9yZWYucmV2ZXJzZSxcbiAgICAgIHJldmVyc2UgPSBfcmVmJHJldmVyc2UgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRyZXZlcnNlLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydjbGFzc05hbWUnLCAna2V5cycsICdkYXRhJywgJ2N1cnZlJywgJ2RlZmluZWQnLCAneCcsICd4MCcsICd4MScsICd5MCcsICd5MScsICdnbHlwaCcsICdyZXZlcnNlJ10pO1xuXG4gIHZhciBzdGFjayQkMSA9IHN0YWNrKCk7XG4gIGlmIChrZXlzKSBzdGFjayQkMS5rZXlzKGtleXMpO1xuXG4gIHZhciBwYXRoJCQxID0gYXJlYSgpO1xuICBpZiAoeCkgcGF0aCQkMS54KHgpO1xuICBpZiAoeDApIHBhdGgkJDEueDAoeDApO1xuICBpZiAoeDEpIHBhdGgkJDEueDEoeDEpO1xuICBpZiAoeTApIHBhdGgkJDEueTAoeTApO1xuICBpZiAoeTEpIHBhdGgkJDEueTEoeTEpO1xuICBpZiAoY3VydmUpIHBhdGgkJDEuY3VydmUoY3VydmUpO1xuICBpZiAoZGVmaW5lZCkgcGF0aCQkMS5kZWZpbmVkKGRlZmluZWQpO1xuXG4gIHZhciBzZXJpZXNEYXRhID0gc3RhY2skJDEoZGF0YSk7XG4gIGlmIChyZXZlcnNlKSBzZXJpZXNEYXRhLnJldmVyc2UoKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAnZycsXG4gICAgbnVsbCxcbiAgICBzZXJpZXNEYXRhLm1hcChmdW5jdGlvbiAoc2VyaWVzLCBpKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICAgICAgY2xhc3NOYW1lOiBjeCgndngtYXJlYS1zdGFjaycsIGNsYXNzTmFtZSksXG4gICAgICAgIGtleTogJ2FyZWEtc3RhY2stJyArIGkgKyAnLScgKyAoc2VyaWVzLmtleSB8fCAnJyksXG4gICAgICAgIGQ6IHBhdGgkJDEoc2VyaWVzKVxuICAgICAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywge1xuICAgICAgICBkYXR1bTogc2VyaWVzW2ldLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgc2VyaWVzOiBzZXJpZXNcbiAgICAgIH0pKSk7XG4gICAgfSksXG4gICAgISFnbHlwaCAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2cnLFxuICAgICAgeyBjbGFzc05hbWU6ICd2eC1hcmVhLXN0YWNrLWdseXBocycgfSxcbiAgICAgIGRhdGEubWFwKGdseXBoKVxuICAgIClcbiAgKTtcbn1cblxuQmFyLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBCYXIoX3JlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgX3JlZiR4ID0gX3JlZi54LFxuICAgICAgeCA9IF9yZWYkeCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkeCxcbiAgICAgIF9yZWYkeSA9IF9yZWYueSxcbiAgICAgIHkgPSBfcmVmJHkgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHksXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICAgIHJ4ID0gX3JlZi5yeCxcbiAgICAgIHJ5ID0gX3JlZi5yeSxcbiAgICAgIF9yZWYkZmlsbCA9IF9yZWYuZmlsbCxcbiAgICAgIGZpbGwgPSBfcmVmJGZpbGwgPT09IHVuZGVmaW5lZCA/ICdzdGVlbGJsdWUnIDogX3JlZiRmaWxsLFxuICAgICAgZmlsbE9wYWNpdHkgPSBfcmVmLmZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIHN0cm9rZUxpbmVjYXAgPSBfcmVmLnN0cm9rZUxpbmVjYXAsXG4gICAgICBzdHJva2VMaW5lam9pbiA9IF9yZWYuc3Ryb2tlTGluZWpvaW4sXG4gICAgICBzdHJva2VNaXRlcmxpbWl0ID0gX3JlZi5zdHJva2VNaXRlcmxpbWl0LFxuICAgICAgc3Ryb2tlT3BhY2l0eSA9IF9yZWYuc3Ryb2tlT3BhY2l0eSxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCcsICdyeCcsICdyeScsICdmaWxsJywgJ2ZpbGxPcGFjaXR5JywgJ3N0cm9rZScsICdzdHJva2VXaWR0aCcsICdzdHJva2VEYXNoYXJyYXknLCAnc3Ryb2tlTGluZWNhcCcsICdzdHJva2VMaW5lam9pbicsICdzdHJva2VNaXRlcmxpbWl0JywgJ3N0cm9rZU9wYWNpdHknXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3JlY3QnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1iYXInLCBjbGFzc05hbWUpLFxuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgcng6IHJ4LFxuICAgIHJ5OiByeSxcbiAgICBmaWxsOiBmaWxsLFxuICAgIGZpbGxPcGFjaXR5OiBmaWxsT3BhY2l0eSxcbiAgICBzdHJva2U6IHN0cm9rZSxcbiAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgc3Ryb2tlTGluZWNhcDogc3Ryb2tlTGluZWNhcCxcbiAgICBzdHJva2VMaW5lam9pbjogc3Ryb2tlTGluZWpvaW4sXG4gICAgc3Ryb2tlTWl0ZXJsaW1pdDogc3Ryb2tlTWl0ZXJsaW1pdCxcbiAgICBzdHJva2VPcGFjaXR5OiBzdHJva2VPcGFjaXR5XG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbkJhckdyb3VwLnByb3BUeXBlcyA9IHtcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHgwOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4MFNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4MVNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB5U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHpTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAga2V5czogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlclxufTtcblxuZnVuY3Rpb24gQmFyR3JvdXAoX3JlZikge1xuICB2YXIgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgdG9wID0gX3JlZi50b3AsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgeDAgPSBfcmVmLngwLFxuICAgICAgeDBTY2FsZSA9IF9yZWYueDBTY2FsZSxcbiAgICAgIHgxU2NhbGUgPSBfcmVmLngxU2NhbGUsXG4gICAgICB5U2NhbGUgPSBfcmVmLnlTY2FsZSxcbiAgICAgIHpTY2FsZSA9IF9yZWYuelNjYWxlLFxuICAgICAga2V5cyA9IF9yZWYua2V5cyxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydkYXRhJywgJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICd4MCcsICd4MFNjYWxlJywgJ3gxU2NhbGUnLCAneVNjYWxlJywgJ3pTY2FsZScsICdrZXlzJywgJ2hlaWdodCddKTtcblxuICB2YXIgZm9ybWF0ID0geDBTY2FsZS50aWNrRm9ybWF0ID8geDBTY2FsZS50aWNrRm9ybWF0KCkgOiBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkO1xuICB9O1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBHcm91cCxcbiAgICB7IGNsYXNzTmFtZTogY3goJ3Z4LWJhci1ncm91cCcsIGNsYXNzTmFtZSksIHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgZGF0YSAmJiBkYXRhLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEdyb3VwLFxuICAgICAgICB7IGtleTogJ2Jhci1ncm91cC0nICsgaSArICctJyArIHgwKGQpLCBsZWZ0OiB4MFNjYWxlKHgwKGQpKSB9LFxuICAgICAgICBrZXlzICYmIGtleXMubWFwKGZ1bmN0aW9uIChrZXksIGopIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBkW2tleV07XG4gICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICBrZXk6ICdiYXItZ3JvdXAtYmFyLScgKyBpICsgJy0nICsgaiArICctJyArIHZhbHVlICsgJy0nICsga2V5LFxuICAgICAgICAgICAgeDogeDFTY2FsZShrZXkpLFxuICAgICAgICAgICAgeTogeVNjYWxlKHZhbHVlKSxcbiAgICAgICAgICAgIHdpZHRoOiB4MVNjYWxlLmJhbmR3aWR0aCgpLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgLSB5U2NhbGUodmFsdWUpLFxuICAgICAgICAgICAgZmlsbDogelNjYWxlKGtleSksXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIHg6IGZvcm1hdCh4MChkKSksXG4gICAgICAgICAgICAgIGRhdGE6IGRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXN0UHJvcHMpKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSlcbiAgKTtcbn1cblxuQmFyR3JvdXBIb3Jpem9udGFsLnByb3BUeXBlcyA9IHtcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHkwOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB5MFNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB5MVNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHpTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAga2V5czogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyXG59O1xuXG5mdW5jdGlvbiBCYXJHcm91cEhvcml6b250YWwoX3JlZikge1xuICB2YXIgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgdG9wID0gX3JlZi50b3AsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgeTAgPSBfcmVmLnkwLFxuICAgICAgeTBTY2FsZSA9IF9yZWYueTBTY2FsZSxcbiAgICAgIHkxU2NhbGUgPSBfcmVmLnkxU2NhbGUsXG4gICAgICB4U2NhbGUgPSBfcmVmLnhTY2FsZSxcbiAgICAgIHpTY2FsZSA9IF9yZWYuelNjYWxlLFxuICAgICAga2V5cyA9IF9yZWYua2V5cyxcbiAgICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnZGF0YScsICdjbGFzc05hbWUnLCAndG9wJywgJ2xlZnQnLCAneTAnLCAneTBTY2FsZScsICd5MVNjYWxlJywgJ3hTY2FsZScsICd6U2NhbGUnLCAna2V5cycsICd3aWR0aCddKTtcblxuICB2YXIgZm9ybWF0ID0geTBTY2FsZS50aWNrRm9ybWF0ID8geTBTY2FsZS50aWNrRm9ybWF0KCkgOiBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkO1xuICB9O1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBHcm91cCxcbiAgICB7IGNsYXNzTmFtZTogY3goJ3Z4LWJhci1ncm91cC1ob3Jpem9udGFsJywgY2xhc3NOYW1lKSwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBkYXRhICYmIGRhdGEubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgR3JvdXAsXG4gICAgICAgIHsga2V5OiAnYmFyLWdyb3VwLScgKyBpICsgJy0nICsgeTAoZCksIHRvcDogeTBTY2FsZSh5MChkKSkgfSxcbiAgICAgICAga2V5cyAmJiBrZXlzLm1hcChmdW5jdGlvbiAoa2V5LCBqKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZFtrZXldO1xuICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEJhciwgX2V4dGVuZHMoe1xuICAgICAgICAgICAga2V5OiAnYmFyLWdyb3VwLWJhci0nICsgaSArICctJyArIGogKyAnLScgKyB2YWx1ZSArICctJyArIGtleSxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiB5MVNjYWxlKGtleSksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGggLSB4U2NhbGUodmFsdWUpLFxuICAgICAgICAgICAgaGVpZ2h0OiB5MVNjYWxlLmJhbmR3aWR0aCgpLFxuICAgICAgICAgICAgZmlsbDogelNjYWxlKGtleSksXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIHk6IGZvcm1hdCh5MChkKSksXG4gICAgICAgICAgICAgIGRhdGE6IGRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXN0UHJvcHMpKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gb2JqSGFzTWV0aG9kKG9iaiwgZnVuY05hbWUpIHtcbiAgcmV0dXJuICEhb2JqW2Z1bmNOYW1lXSAmJiB0eXBlb2Ygb2JqW2Z1bmNOYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuQmFyU3RhY2sucHJvcFR5cGVzID0ge1xuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgeDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgeFNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB5U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHpTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAga2V5czogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyLFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyXG59O1xuXG5mdW5jdGlvbiBCYXJTdGFjayhfcmVmKSB7XG4gIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICB0b3AgPSBfcmVmLnRvcCxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeFNjYWxlID0gX3JlZi54U2NhbGUsXG4gICAgICB5U2NhbGUgPSBfcmVmLnlTY2FsZSxcbiAgICAgIHpTY2FsZSA9IF9yZWYuelNjYWxlLFxuICAgICAga2V5cyA9IF9yZWYua2V5cyxcbiAgICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydkYXRhJywgJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICd4JywgJ3hTY2FsZScsICd5U2NhbGUnLCAnelNjYWxlJywgJ2tleXMnLCAnd2lkdGgnLCAnaGVpZ2h0J10pO1xuXG4gIHZhciBzZXJpZXMgPSBzdGFjaygpLmtleXMoa2V5cykoZGF0YSk7XG4gIHZhciBmb3JtYXQgPSB4U2NhbGUudGlja0Zvcm1hdCA/IHhTY2FsZS50aWNrRm9ybWF0KCkgOiBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkO1xuICB9O1xuICB2YXIgeFJhbmdlID0geFNjYWxlLnJhbmdlKCk7XG4gIHZhciB4RG9tYWluID0geFNjYWxlLmRvbWFpbigpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBHcm91cCxcbiAgICB7IGNsYXNzTmFtZTogY3goJ3Z4LWJhci1zdGFjaycsIGNsYXNzTmFtZSksIHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgc2VyaWVzICYmIHNlcmllcy5tYXAoZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBHcm91cCxcbiAgICAgICAgeyBrZXk6ICd2eC1iYXItc3RhY2stJyArIGkgfSxcbiAgICAgICAgcy5tYXAoZnVuY3Rpb24gKGQsIGlpKSB7XG4gICAgICAgICAgdmFyIGJhckhlaWdodCA9IHlTY2FsZShkWzBdKSAtIHlTY2FsZShkWzFdKTtcbiAgICAgICAgICB2YXIgYmFyV2lkdGggPSB3aWR0aCB8fCAob2JqSGFzTWV0aG9kKHhTY2FsZSwgJ2JhbmR3aWR0aCcpID8geFNjYWxlLmJhbmR3aWR0aCgpIDogTWF0aC5hYnMoeFJhbmdlW3hSYW5nZS5sZW5ndGggLSAxXSAtIHhSYW5nZVswXSkgLyB4RG9tYWluLmxlbmd0aCk7XG5cbiAgICAgICAgICB2YXIgYmFyWCA9IG9iakhhc01ldGhvZCh4U2NhbGUsICdiYW5kd2lkdGgnKSA/IHhTY2FsZSh4KGQuZGF0YSkpIDogeFNjYWxlKHgoZC5kYXRhKSkgLSBiYXJXaWR0aCAvIDI7XG4gICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICBrZXk6ICdiYXItZ3JvdXAtYmFyLScgKyBpICsgJy0nICsgaWkgKyAnLScgKyBzLmtleSxcbiAgICAgICAgICAgIHg6IGJhclgsXG4gICAgICAgICAgICB5OiB5U2NhbGUoZFsxXSksXG4gICAgICAgICAgICB3aWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICAgIGZpbGw6IHpTY2FsZShzLmtleSksXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHBhZGRpbmdJbm5lcjogb2JqSGFzTWV0aG9kKHhTY2FsZSwgJ3BhZGRpbmdJbm5lcicpICYmIHhTY2FsZS5wYWRkaW5nSW5uZXIoKSxcbiAgICAgICAgICAgICAgcGFkZGluZ091dGVyOiBvYmpIYXNNZXRob2QoeFNjYWxlLCAncGFkZGluZ091dGVyJykgJiYgeFNjYWxlLnBhZGRpbmdPdXRlcigpLFxuICAgICAgICAgICAgICBzdGVwOiBvYmpIYXNNZXRob2QoeFNjYWxlLCAnc3RlcCcpICYmIHhTY2FsZS5zdGVwKCksXG4gICAgICAgICAgICAgIGtleTogcy5rZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBkWzFdLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICAgICAgd2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgICB4OiB4KGQuZGF0YSksXG4gICAgICAgICAgICAgIHhGb3JtYXR0ZWQ6IGZvcm1hdCh4KGQuZGF0YSkpLFxuICAgICAgICAgICAgICBkYXRhOiBkLmRhdGFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXN0UHJvcHMpKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSlcbiAgKTtcbn1cblxuQmFyU3RhY2tIb3Jpem9udGFsLnByb3BUeXBlcyA9IHtcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHk6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHhTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgeVNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB6U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGtleXM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlclxufTtcblxuZnVuY3Rpb24gQmFyU3RhY2tIb3Jpem9udGFsKF9yZWYpIHtcbiAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB4U2NhbGUgPSBfcmVmLnhTY2FsZSxcbiAgICAgIHlTY2FsZSA9IF9yZWYueVNjYWxlLFxuICAgICAgelNjYWxlID0gX3JlZi56U2NhbGUsXG4gICAgICBrZXlzID0gX3JlZi5rZXlzLFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2RhdGEnLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3knLCAneFNjYWxlJywgJ3lTY2FsZScsICd6U2NhbGUnLCAna2V5cycsICd3aWR0aCcsICdoZWlnaHQnXSk7XG5cbiAgdmFyIHNlcmllcyA9IHN0YWNrKCkua2V5cyhrZXlzKShkYXRhKTtcbiAgdmFyIGZvcm1hdCA9IHlTY2FsZS50aWNrRm9ybWF0ID8geVNjYWxlLnRpY2tGb3JtYXQoKSA6IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH07XG4gIHZhciB5UmFuZ2UgPSB5U2NhbGUucmFuZ2UoKTtcbiAgdmFyIHlEb21haW4gPSB5U2NhbGUuZG9tYWluKCk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgY2xhc3NOYW1lOiBjeCgndngtYmFyLXN0YWNrLWhvcml6b250YWwnLCBjbGFzc05hbWUpLCB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgIHNlcmllcyAmJiBzZXJpZXMubWFwKGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgR3JvdXAsXG4gICAgICAgIHsga2V5OiAndngtYmFyLXN0YWNrLWhvcml6b250YWwtJyArIGkgfSxcbiAgICAgICAgcy5tYXAoZnVuY3Rpb24gKGQsIGlpKSB7XG4gICAgICAgICAgdmFyIGJhcldpZHRoID0geFNjYWxlKGRbMV0pIC0geFNjYWxlKGRbMF0pO1xuICAgICAgICAgIHZhciBiYXJIZWlnaHQgPSB3aWR0aCB8fCAob2JqSGFzTWV0aG9kKHlTY2FsZSwgJ2JhbmR3aWR0aCcpID8geVNjYWxlLmJhbmR3aWR0aCgpIDogTWF0aC5hYnMoeVJhbmdlW3lSYW5nZS5sZW5ndGggLSAxXSAtIHlSYW5nZVswXSkgLyB5RG9tYWluLmxlbmd0aCk7XG5cbiAgICAgICAgICB2YXIgYmFyWSA9IG9iakhhc01ldGhvZCh5U2NhbGUsICdiYW5kd2lkdGgnKSA/IHlTY2FsZSh5KGQuZGF0YSkpIDogeVNjYWxlKHkoZC5kYXRhKSkgLSBiYXJIZWlnaHQgLyAyO1xuICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEJhciwgX2V4dGVuZHMoe1xuICAgICAgICAgICAga2V5OiAnYmFyLWdyb3VwLWJhci0nICsgaSArICctJyArIGlpICsgJy0nICsgcy5rZXksXG4gICAgICAgICAgICB4OiB4U2NhbGUoZFswXSksXG4gICAgICAgICAgICB5OiBiYXJZLFxuICAgICAgICAgICAgd2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICBmaWxsOiB6U2NhbGUocy5rZXkpLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBwYWRkaW5nSW5uZXI6IG9iakhhc01ldGhvZCh5U2NhbGUsICdwYWRkaW5nSW5uZXInKSAmJiB5U2NhbGUucGFkZGluZ0lubmVyKCksXG4gICAgICAgICAgICAgIHBhZGRpbmdPdXRlcjogb2JqSGFzTWV0aG9kKHlTY2FsZSwgJ3BhZGRpbmdPdXRlcicpICYmIHlTY2FsZS5wYWRkaW5nT3V0ZXIoKSxcbiAgICAgICAgICAgICAgc3RlcDogb2JqSGFzTWV0aG9kKHlTY2FsZSwgJ3N0ZXAnKSAmJiB5U2NhbGUuc3RlcCgpLFxuICAgICAgICAgICAgICBrZXk6IHMua2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogZFswXSxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICAgIHdpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICAgICAgeTogeShkLmRhdGEpLFxuICAgICAgICAgICAgICB5Rm9ybWF0dGVkOiBmb3JtYXQoeShkLmRhdGEpKSxcbiAgICAgICAgICAgICAgZGF0YTogZC5kYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzdFByb3BzKSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cbnZhciBTVEFDS19PUkRFUlMgPSB7XG4gIGFzY2VuZGluZzogc3RhY2tPcmRlckFzY2VuZGluZyxcbiAgZGVzY2VuZGluZzogc3RhY2tPcmRlckRlc2NlbmRpbmcsXG4gIGluc2lkZW91dDogc3RhY2tPcmRlckluc2lkZU91dCxcbiAgbm9uZTogc3RhY2tPcmRlck5vbmUsXG4gIHJldmVyc2U6IHN0YWNrT3JkZXJSZXZlcnNlXG59O1xuXG52YXIgU1RBQ0tfT1JERVJfTkFNRVMgPSBPYmplY3Qua2V5cyhTVEFDS19PUkRFUlMpO1xuXG5mdW5jdGlvbiBzdGFja09yZGVyKG9yZGVyKSB7XG4gIHJldHVybiBTVEFDS19PUkRFUlNbb3JkZXJdIHx8IFNUQUNLX09SREVSUy5ub25lO1xufVxuXG52YXIgU1RBQ0tfT0ZGU0VUUyA9IHtcbiAgZXhwYW5kOiBzdGFja09mZnNldEV4cGFuZCxcbiAgZGl2ZXJnaW5nOiBzdGFja09mZnNldERpdmVyZ2luZyxcbiAgbm9uZTogc3RhY2tPZmZzZXROb25lLFxuICBzaWxob3VldHRlOiBzdGFja09mZnNldFNpbGhvdWV0dGUsXG4gIHdpZ2dsZTogc3RhY2tPZmZzZXRXaWdnbGVcbn07XG5cbnZhciBTVEFDS19PRkZTRVRfTkFNRVMgPSBPYmplY3Qua2V5cyhTVEFDS19PRkZTRVRTKTtcblxuZnVuY3Rpb24gc3RhY2tPZmZzZXQob2Zmc2V0KSB7XG4gIHJldHVybiBTVEFDS19PRkZTRVRTW29mZnNldF0gfHwgU1RBQ0tfT0ZGU0VUUy5ub25lO1xufVxuXG5TdGFjay5wcm9wVHlwZXMgPSB7XG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBrZXlzOiBQcm9wVHlwZXMuYXJyYXksXG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheSxcbiAgY3VydmU6IFByb3BUeXBlcy5mdW5jLFxuICBkZWZpbmVkOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLmJvb2xdKSxcbiAgeDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgeDA6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHgxOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICB5OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICB5MDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgeTE6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBvcmRlcjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5hcnJheSwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBvZmZzZXQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuYXJyYXksIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgcmVuZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgcmV2ZXJzZTogUHJvcFR5cGVzLmJvb2xcbn07XG5cbmZ1bmN0aW9uIFN0YWNrKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIHRvcCA9IF9yZWYkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0b3AsXG4gICAgICBfcmVmJGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBsZWZ0ID0gX3JlZiRsZWZ0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRsZWZ0LFxuICAgICAga2V5cyA9IF9yZWYua2V5cyxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjdXJ2ZSA9IF9yZWYuY3VydmUsXG4gICAgICBkZWZpbmVkID0gX3JlZi5kZWZpbmVkLFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHgwID0gX3JlZi54MCxcbiAgICAgIHgxID0gX3JlZi54MSxcbiAgICAgIHkwID0gX3JlZi55MCxcbiAgICAgIHkxID0gX3JlZi55MSxcbiAgICAgIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgIG9yZGVyID0gX3JlZi5vcmRlcixcbiAgICAgIG9mZnNldCA9IF9yZWYub2Zmc2V0LFxuICAgICAgcmVuZGVyID0gX3JlZi5yZW5kZXIsXG4gICAgICBfcmVmJHJldmVyc2UgPSBfcmVmLnJldmVyc2UsXG4gICAgICByZXZlcnNlID0gX3JlZiRyZXZlcnNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkcmV2ZXJzZSxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ2tleXMnLCAnZGF0YScsICdjdXJ2ZScsICdkZWZpbmVkJywgJ3gnLCAneDAnLCAneDEnLCAneTAnLCAneTEnLCAndmFsdWUnLCAnb3JkZXInLCAnb2Zmc2V0JywgJ3JlbmRlcicsICdyZXZlcnNlJ10pO1xuXG4gIHZhciBzdGFjayQkMSA9IHN0YWNrKCk7XG4gIGlmIChrZXlzKSBzdGFjayQkMS5rZXlzKGtleXMpO1xuICBpZiAodmFsdWUpIHN0YWNrJCQxLnZhbHVlKHZhbHVlKTtcbiAgaWYgKG9yZGVyKSBzdGFjayQkMS5vcmRlcihzdGFja09yZGVyKG9yZGVyKSk7XG4gIGlmIChvZmZzZXQpIHN0YWNrJCQxLm9mZnNldChzdGFja09mZnNldChvZmZzZXQpKTtcblxuICB2YXIgcGF0aCQkMSA9IGFyZWEoKTtcbiAgaWYgKHgpIHBhdGgkJDEueCh4KTtcbiAgaWYgKHgwKSBwYXRoJCQxLngwKHgwKTtcbiAgaWYgKHgxKSBwYXRoJCQxLngxKHgxKTtcbiAgaWYgKHkwKSBwYXRoJCQxLnkwKHkwKTtcbiAgaWYgKHkxKSBwYXRoJCQxLnkxKHkxKTtcbiAgaWYgKGN1cnZlKSBwYXRoJCQxLmN1cnZlKGN1cnZlKTtcbiAgaWYgKGRlZmluZWQpIHBhdGgkJDEuZGVmaW5lZChkZWZpbmVkKTtcblxuICB2YXIgc2VyaWVzRGF0YSA9IHN0YWNrJCQxKGRhdGEpO1xuICBpZiAocmV2ZXJzZSkgc2VyaWVzRGF0YS5yZXZlcnNlKCk7XG5cbiAgaWYgKHJlbmRlcikge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgR3JvdXAsXG4gICAgICB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgICByZW5kZXIoeyBzZXJpZXNEYXRhOiBzZXJpZXNEYXRhLCBwYXRoOiBwYXRoJCQxIH0pXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBzZXJpZXNEYXRhLm1hcChmdW5jdGlvbiAoc2VyaWVzLCBpKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICAgICAgY2xhc3NOYW1lOiBjeCgndngtc3RhY2snLCBjbGFzc05hbWUpLFxuICAgICAgICBrZXk6ICdzdGFjay0nICsgaSArICctJyArIChzZXJpZXMua2V5IHx8ICcnKSxcbiAgICAgICAgZDogcGF0aCQkMShzZXJpZXMpXG4gICAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCB7XG4gICAgICAgIGRhdHVtOiBzZXJpZXNbaV0sXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICBzZXJpZXM6IHNlcmllc1xuICAgICAgfSkpKTtcbiAgICB9KVxuICApO1xufVxuXG52YXIgZGVncmVlc1RvUmFkaWFucyA9IGZ1bmN0aW9uIGRlZ3JlZXNUb1JhZGlhbnMoZGVncmVlcykge1xuICByZXR1cm4gTWF0aC5QSSAvIDE4MCAqIGRlZ3JlZXM7XG59O1xuXG5mdW5jdGlvbiBwYXRoSG9yaXpvbnRhbERpYWdvbmFsKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbGluayA9IGxpbmtIb3Jpem9udGFsKCk7XG4gICAgbGluay54KHgpO1xuICAgIGxpbmsueSh5KTtcbiAgICBsaW5rLnNvdXJjZShzb3VyY2UpO1xuICAgIGxpbmsudGFyZ2V0KHRhcmdldCk7XG4gICAgcmV0dXJuIGxpbmsoZGF0YSk7XG4gIH07XG59XG5cbkxpbmtIb3Jpem9udGFsLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rSG9yaXpvbnRhbChfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoSG9yaXpvbnRhbERpYWdvbmFsKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmstaG9yaXpvbnRhbCcsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoVmVydGljYWxEaWFnb25hbChfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGxpbmsgPSBsaW5rVmVydGljYWwoKTtcbiAgICBsaW5rLngoeCk7XG4gICAgbGluay55KHkpO1xuICAgIGxpbmsuc291cmNlKHNvdXJjZSk7XG4gICAgbGluay50YXJnZXQodGFyZ2V0KTtcbiAgICByZXR1cm4gbGluayhkYXRhKTtcbiAgfTtcbn1cblxuTGlua1ZlcnRpY2FsLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rVmVydGljYWwoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3BhdGgnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFZlcnRpY2FsRGlhZ29uYWwoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHkgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluay12ZXJ0aWNhbCcsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoUmFkaWFsRGlhZ29uYWwoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIGFuZ2xlID0gX3JlZi5hbmdsZSxcbiAgICAgIHJhZGl1cyA9IF9yZWYucmFkaXVzO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBsaW5rID0gbGlua1JhZGlhbCgpO1xuICAgIGxpbmsuYW5nbGUoYW5nbGUpO1xuICAgIGxpbmsucmFkaXVzKHJhZGl1cyk7XG4gICAgbGluay5zb3VyY2Uoc291cmNlKTtcbiAgICBsaW5rLnRhcmdldCh0YXJnZXQpO1xuICAgIHJldHVybiBsaW5rKGRhdGEpO1xuICB9O1xufVxuXG5MaW5rUmFkaWFsLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBhbmdsZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHJhZGl1czogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rUmFkaWFsKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJGFuZ2xlID0gX3JlZjIuYW5nbGUsXG4gICAgICBhbmdsZSA9IF9yZWYyJGFuZ2xlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiRhbmdsZSxcbiAgICAgIF9yZWYyJHJhZGl1cyA9IF9yZWYyLnJhZGl1cyxcbiAgICAgIHJhZGl1cyA9IF9yZWYyJHJhZGl1cyA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkcmFkaXVzLFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ2FuZ2xlJywgJ3JhZGl1cycsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhSYWRpYWxEaWFnb25hbCh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgYW5nbGU6IGFuZ2xlLCByYWRpdXM6IHJhZGl1cyB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rLXJhZGl1cycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoSG9yaXpvbnRhbEN1cnZlKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHBlcmNlbnQgPSBfcmVmLnBlcmNlbnQ7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc3ggPSB4KHNvdXJjZURhdGEpO1xuICAgIHZhciBzeSA9IHkoc291cmNlRGF0YSk7XG4gICAgdmFyIHR4ID0geCh0YXJnZXREYXRhKTtcbiAgICB2YXIgdHkgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIGR4ID0gdHggLSBzeDtcbiAgICB2YXIgZHkgPSB0eSAtIHN5O1xuICAgIHZhciBpeCA9IHBlcmNlbnQgKiAoZHggKyBkeSk7XG4gICAgdmFyIGl5ID0gcGVyY2VudCAqIChkeSAtIGR4KTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHN4LCBzeSk7XG4gICAgcGF0aCQkMS5iZXppZXJDdXJ2ZVRvKHN4ICsgaXgsIHN5ICsgaXksIHR4ICsgaXksIHR5IC0gaXgsIHR4LCB0eSk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rSG9yaXpvbnRhbEN1cnZlLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwZXJjZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rSG9yaXpvbnRhbEN1cnZlKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICBfcmVmMiRwZXJjZW50ID0gX3JlZjIucGVyY2VudCxcbiAgICAgIHBlcmNlbnQgPSBfcmVmMiRwZXJjZW50ID09PSB1bmRlZmluZWQgPyAwLjIgOiBfcmVmMiRwZXJjZW50LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCcsICdwZXJjZW50J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhIb3Jpem9udGFsQ3VydmUoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHksIHBlcmNlbnQ6IHBlcmNlbnQgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoVmVydGljYWxDdXJ2ZShfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICBwZXJjZW50ID0gX3JlZi5wZXJjZW50O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzb3VyY2VEYXRhID0gc291cmNlKGRhdGEpO1xuICAgIHZhciB0YXJnZXREYXRhID0gdGFyZ2V0KGRhdGEpO1xuXG4gICAgdmFyIHN4ID0geChzb3VyY2VEYXRhKTtcbiAgICB2YXIgc3kgPSB5KHNvdXJjZURhdGEpO1xuICAgIHZhciB0eCA9IHgodGFyZ2V0RGF0YSk7XG4gICAgdmFyIHR5ID0geSh0YXJnZXREYXRhKTtcblxuICAgIHZhciBkeCA9IHR4IC0gc3g7XG4gICAgdmFyIGR5ID0gdHkgLSBzeTtcbiAgICB2YXIgaXggPSBwZXJjZW50ICogKGR4ICsgZHkpO1xuICAgIHZhciBpeSA9IHBlcmNlbnQgKiAoZHkgLSBkeCk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzeCwgc3kpO1xuICAgIHBhdGgkJDEuYmV6aWVyQ3VydmVUbyhzeCArIGl4LCBzeSArIGl5LCB0eCArIGl5LCB0eSAtIGl4LCB0eCwgdHkpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua1ZlcnRpY2FsQ3VydmUucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtWZXJ0aWNhbEN1cnZlKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICBfcmVmMiRwZXJjZW50ID0gX3JlZjIucGVyY2VudCxcbiAgICAgIHBlcmNlbnQgPSBfcmVmMiRwZXJjZW50ID09PSB1bmRlZmluZWQgPyAwLjIgOiBfcmVmMiRwZXJjZW50LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCcsICdwZXJjZW50J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhWZXJ0aWNhbEN1cnZlKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5LCBwZXJjZW50OiBwZXJjZW50IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aFJhZGlhbEN1cnZlKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHBlcmNlbnQgPSBfcmVmLnBlcmNlbnQ7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc2EgPSB4KHNvdXJjZURhdGEpIC0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIHNyID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdGEgPSB4KHRhcmdldERhdGEpIC0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIHRyID0geSh0YXJnZXREYXRhKTtcblxuICAgIHZhciBzYyA9IE1hdGguY29zKHNhKTtcbiAgICB2YXIgc3MgPSBNYXRoLnNpbihzYSk7XG4gICAgdmFyIHRjID0gTWF0aC5jb3ModGEpO1xuICAgIHZhciB0cyA9IE1hdGguc2luKHRhKTtcblxuICAgIHZhciBzeCA9IHNyICogc2M7XG4gICAgdmFyIHN5ID0gc3IgKiBzcztcbiAgICB2YXIgdHggPSB0ciAqIHRjO1xuICAgIHZhciB0eSA9IHRyICogdHM7XG5cbiAgICB2YXIgZHggPSB0eCAtIHN4O1xuICAgIHZhciBkeSA9IHR5IC0gc3k7XG4gICAgdmFyIGl4ID0gcGVyY2VudCAqIChkeCArIGR5KTtcbiAgICB2YXIgaXkgPSBwZXJjZW50ICogKGR5IC0gZHgpO1xuXG4gICAgdmFyIHBhdGgkJDEgPSBwYXRoKCk7XG4gICAgcGF0aCQkMS5tb3ZlVG8oc3gsIHN5KTtcbiAgICBwYXRoJCQxLmJlemllckN1cnZlVG8oc3ggKyBpeCwgc3kgKyBpeSwgdHggKyBpeSwgdHkgLSBpeCwgdHgsIHR5KTtcblxuICAgIHJldHVybiBwYXRoJCQxLnRvU3RyaW5nKCk7XG4gIH07XG59XG5cbkxpbmtSYWRpYWxDdXJ2ZS5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgcGVyY2VudDogUHJvcFR5cGVzLm51bWJlcixcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGlua1JhZGlhbEN1cnZlKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICBfcmVmMiRwZXJjZW50ID0gX3JlZjIucGVyY2VudCxcbiAgICAgIHBlcmNlbnQgPSBfcmVmMiRwZXJjZW50ID09PSB1bmRlZmluZWQgPyAwLjIgOiBfcmVmMiRwZXJjZW50LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCcsICdwZXJjZW50J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhSYWRpYWxDdXJ2ZSh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSwgcGVyY2VudDogcGVyY2VudCB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhIb3Jpem9udGFsTGluZShfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc3ggPSB4KHNvdXJjZURhdGEpO1xuICAgIHZhciBzeSA9IHkoc291cmNlRGF0YSk7XG4gICAgdmFyIHR4ID0geCh0YXJnZXREYXRhKTtcbiAgICB2YXIgdHkgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIHBhdGgkJDEgPSBwYXRoKCk7XG4gICAgcGF0aCQkMS5tb3ZlVG8oc3gsIHN5KTtcbiAgICBwYXRoJCQxLmxpbmVUbyh0eCwgdHkpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua0hvcml6b250YWxMaW5lLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuYyxcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rSG9yaXpvbnRhbExpbmUoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3BhdGgnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aEhvcml6b250YWxMaW5lKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aFZlcnRpY2FsTGluZShfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc3ggPSB4KHNvdXJjZURhdGEpO1xuICAgIHZhciBzeSA9IHkoc291cmNlRGF0YSk7XG4gICAgdmFyIHR4ID0geCh0YXJnZXREYXRhKTtcbiAgICB2YXIgdHkgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIHBhdGgkJDEgPSBwYXRoKCk7XG4gICAgcGF0aCQkMS5tb3ZlVG8oc3gsIHN5KTtcbiAgICBwYXRoJCQxLmxpbmVUbyh0eCwgdHkpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua1ZlcnRpY2FsTGluZS5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmMsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGlua1ZlcnRpY2FsTGluZShfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoVmVydGljYWxMaW5lKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aFJhZGlhbExpbmUoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzb3VyY2VEYXRhID0gc291cmNlKGRhdGEpO1xuICAgIHZhciB0YXJnZXREYXRhID0gdGFyZ2V0KGRhdGEpO1xuXG4gICAgdmFyIHNhID0geChzb3VyY2VEYXRhKSAtIE1hdGguUEkgLyAyO1xuICAgIHZhciBzciA9IHkoc291cmNlRGF0YSk7XG4gICAgdmFyIHRhID0geCh0YXJnZXREYXRhKSAtIE1hdGguUEkgLyAyO1xuICAgIHZhciB0ciA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgc2MgPSBNYXRoLmNvcyhzYSk7XG4gICAgdmFyIHNzID0gTWF0aC5zaW4oc2EpO1xuICAgIHZhciB0YyA9IE1hdGguY29zKHRhKTtcbiAgICB2YXIgdHMgPSBNYXRoLnNpbih0YSk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzciAqIHNjLCBzciAqIHNzKTtcbiAgICBwYXRoJCQxLmxpbmVUbyh0ciAqIHRjLCB0ciAqIHRzKTtcblxuICAgIHJldHVybiBwYXRoJCQxLnRvU3RyaW5nKCk7XG4gIH07XG59XG5cbkxpbmtSYWRpYWxTdGVwLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuYyxcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rUmFkaWFsU3RlcChfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoUmFkaWFsTGluZSh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhIb3Jpem9udGFsU3RlcChfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICBwZXJjZW50ID0gX3JlZi5wZXJjZW50O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzb3VyY2VEYXRhID0gc291cmNlKGRhdGEpO1xuICAgIHZhciB0YXJnZXREYXRhID0gdGFyZ2V0KGRhdGEpO1xuXG4gICAgdmFyIHN4ID0geChzb3VyY2VEYXRhKTtcbiAgICB2YXIgc3kgPSB5KHNvdXJjZURhdGEpO1xuICAgIHZhciB0eCA9IHgodGFyZ2V0RGF0YSk7XG4gICAgdmFyIHR5ID0geSh0YXJnZXREYXRhKTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHN4LCBzeSk7XG4gICAgcGF0aCQkMS5saW5lVG8oc3ggKyAodHggLSBzeCkgKiBwZXJjZW50LCBzeSk7XG4gICAgcGF0aCQkMS5saW5lVG8oc3ggKyAodHggLSBzeCkgKiBwZXJjZW50LCB0eSk7XG4gICAgcGF0aCQkMS5saW5lVG8odHgsIHR5KTtcblxuICAgIHJldHVybiBwYXRoJCQxLnRvU3RyaW5nKCk7XG4gIH07XG59XG5cbkxpbmtIb3Jpem9udGFsU3RlcC5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgcGVyY2VudDogUHJvcFR5cGVzLm51bWJlcixcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGlua0hvcml6b250YWxTdGVwKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHBlcmNlbnQgPSBfcmVmMi5wZXJjZW50LFxuICAgICAgcGVyY2VudCA9IF9yZWYyJHBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IDAuNSA6IF9yZWYyJHBlcmNlbnQsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICdwZXJjZW50JywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhIb3Jpem9udGFsU3RlcCh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSwgcGVyY2VudDogcGVyY2VudCB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhWZXJ0aWNhbFN0ZXAoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgcGVyY2VudCA9IF9yZWYucGVyY2VudDtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzeCwgc3kpO1xuICAgIHBhdGgkJDEubGluZVRvKHN4LCBzeSArICh0eSAtIHN5KSAqIHBlcmNlbnQpO1xuICAgIHBhdGgkJDEubGluZVRvKHR4LCBzeSArICh0eSAtIHN5KSAqIHBlcmNlbnQpO1xuICAgIHBhdGgkJDEubGluZVRvKHR4LCB0eSk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rVmVydGljYWxTdGVwLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwZXJjZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rVmVydGljYWxTdGVwKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHBlcmNlbnQgPSBfcmVmMi5wZXJjZW50LFxuICAgICAgcGVyY2VudCA9IF9yZWYyJHBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IDAuNSA6IF9yZWYyJHBlcmNlbnQsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICdwZXJjZW50JywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhWZXJ0aWNhbFN0ZXAoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHksIHBlcmNlbnQ6IHBlcmNlbnQgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoUmFkaWFsU3RlcChfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc3ggPSB4KHNvdXJjZURhdGEpO1xuICAgIHZhciBzeSA9IHkoc291cmNlRGF0YSk7XG4gICAgdmFyIHR4ID0geCh0YXJnZXREYXRhKTtcbiAgICB2YXIgdHkgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIHNhID0gc3ggLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgc3IgPSBzeTtcbiAgICB2YXIgdGEgPSB0eCAtIE1hdGguUEkgLyAyO1xuICAgIHZhciB0ciA9IHR5O1xuXG4gICAgdmFyIHNjID0gTWF0aC5jb3Moc2EpO1xuICAgIHZhciBzcyA9IE1hdGguc2luKHNhKTtcbiAgICB2YXIgdGMgPSBNYXRoLmNvcyh0YSk7XG4gICAgdmFyIHRzID0gTWF0aC5zaW4odGEpO1xuICAgIHZhciBzZiA9IE1hdGguYWJzKHRhIC0gc2EpID4gTWF0aC5QSSA/IHRhIDw9IHNhIDogdGEgPiBzYTtcblxuICAgIHJldHVybiAnXFxuICAgICAgTScgKyBzciAqIHNjICsgJywnICsgc3IgKiBzcyArICdcXG4gICAgICBBJyArIHNyICsgJywnICsgc3IgKyAnLDAsMCwnICsgKHNmID8gMSA6IDApICsgJywnICsgc3IgKiB0YyArICcsJyArIHNyICogdHMgKyAnXFxuICAgICAgTCcgKyB0ciAqIHRjICsgJywnICsgdHIgKiB0cyArICdcXG4gICAgJztcbiAgfTtcbn1cblxuTGlua1JhZGlhbFN0ZXAkMS5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGlua1JhZGlhbFN0ZXAkMShfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoUmFkaWFsU3RlcCh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cblBvbHlnb24ucHJvcFR5cGVzID0ge1xuICBzaWRlczogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBzaXplOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgcm90YXRlOiBQcm9wVHlwZXMubnVtYmVyXG59O1xuXG52YXIgZ2V0UG9pbnQgPSBmdW5jdGlvbiBnZXRQb2ludChfcmVmKSB7XG4gIHZhciBzaWRlcyA9IF9yZWYuc2lkZXMsXG4gICAgICBzaXplID0gX3JlZi5zaXplLFxuICAgICAgY2VudGVyID0gX3JlZi5jZW50ZXIsXG4gICAgICByb3RhdGUgPSBfcmVmLnJvdGF0ZSxcbiAgICAgIHNpZGUgPSBfcmVmLnNpZGU7XG5cbiAgdmFyIGRlZ3JlZXMgPSAzNjAgLyBzaWRlcyAqIHNpZGUgLSByb3RhdGU7XG4gIHZhciByYWRpYW5zID0gZGVncmVlc1RvUmFkaWFucyhkZWdyZWVzKTtcblxuICByZXR1cm4gbmV3IFBvaW50KHtcbiAgICB4OiBjZW50ZXIueCArIHNpemUgKiBNYXRoLmNvcyhyYWRpYW5zKSxcbiAgICB5OiBjZW50ZXIueSArIHNpemUgKiBNYXRoLnNpbihyYWRpYW5zKVxuICB9KTtcbn07XG5cbnZhciBnZXRQb2ludHMgPSBmdW5jdGlvbiBnZXRQb2ludHMoX3JlZjIpIHtcbiAgdmFyIHNpZGVzID0gX3JlZjIuc2lkZXMsXG4gICAgICBzaXplID0gX3JlZjIuc2l6ZSxcbiAgICAgIGNlbnRlciA9IF9yZWYyLmNlbnRlcixcbiAgICAgIHJvdGF0ZSA9IF9yZWYyLnJvdGF0ZTtcblxuICByZXR1cm4gW10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KEFycmF5KHNpZGVzKS5rZXlzKCkpKS5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gZ2V0UG9pbnQoe1xuICAgICAgc2lkZXM6IHNpZGVzLFxuICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgcm90YXRlOiByb3RhdGUsXG4gICAgICBzaWRlOiBzaWRlXG4gICAgfSk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gUG9seWdvbihfcmVmMykge1xuICB2YXIgc2lkZXMgPSBfcmVmMy5zaWRlcyxcbiAgICAgIF9yZWYzJHNpemUgPSBfcmVmMy5zaXplLFxuICAgICAgc2l6ZSA9IF9yZWYzJHNpemUgPT09IHVuZGVmaW5lZCA/IDI1IDogX3JlZjMkc2l6ZSxcbiAgICAgIF9yZWYzJGNlbnRlciA9IF9yZWYzLmNlbnRlcixcbiAgICAgIGNlbnRlciA9IF9yZWYzJGNlbnRlciA9PT0gdW5kZWZpbmVkID8gbmV3IFBvaW50KHsgeDogMCwgeTogMCB9KSA6IF9yZWYzJGNlbnRlcixcbiAgICAgIF9yZWYzJHJvdGF0ZSA9IF9yZWYzLnJvdGF0ZSxcbiAgICAgIHJvdGF0ZSA9IF9yZWYzJHJvdGF0ZSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYzJHJvdGF0ZSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYzLmNsYXNzTmFtZSxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYzLCBbJ3NpZGVzJywgJ3NpemUnLCAnY2VudGVyJywgJ3JvdGF0ZScsICdjbGFzc05hbWUnXSk7XG5cbiAgdmFyIHBvaW50cyA9IGdldFBvaW50cyh7XG4gICAgc2lkZXM6IHNpZGVzLFxuICAgIHNpemU6IHNpemUsXG4gICAgY2VudGVyOiBjZW50ZXIsXG4gICAgcm90YXRlOiByb3RhdGVcbiAgfSkubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAudG9BcnJheSgpO1xuICB9KS5qb2luKCcgJyk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BvbHlnb24nLCBfZXh0ZW5kcyh7IHBvaW50czogcG9pbnRzLCBjbGFzc05hbWU6IGN4KCd2eC1wb2x5Z29uJywgY2xhc3NOYW1lKSB9LCByZXN0UHJvcHMpKTtcbn1cblxuZXhwb3J0IHsgQXJjLCBQaWUsIExpbmUsIExpbmVQYXRoLCBMaW5lUmFkaWFsLCBBcmVhLCBBcmVhQ2xvc2VkLCBBcmVhU3RhY2ssIEJhciwgQmFyR3JvdXAsIEJhckdyb3VwSG9yaXpvbnRhbCwgQmFyU3RhY2ssIEJhclN0YWNrSG9yaXpvbnRhbCwgU3RhY2ssIGNhbGxPclZhbHVlLCBzdGFja09mZnNldCwgU1RBQ0tfT0ZGU0VUUywgU1RBQ0tfT0ZGU0VUX05BTUVTLCBzdGFja09yZGVyLCBTVEFDS19PUkRFUlMsIFNUQUNLX09SREVSX05BTUVTLCBkZWdyZWVzVG9SYWRpYW5zLCBMaW5rSG9yaXpvbnRhbCwgcGF0aEhvcml6b250YWxEaWFnb25hbCwgTGlua1ZlcnRpY2FsLCBwYXRoVmVydGljYWxEaWFnb25hbCwgTGlua1JhZGlhbCwgcGF0aFJhZGlhbERpYWdvbmFsLCBMaW5rSG9yaXpvbnRhbEN1cnZlLCBwYXRoSG9yaXpvbnRhbEN1cnZlLCBMaW5rVmVydGljYWxDdXJ2ZSwgcGF0aFZlcnRpY2FsQ3VydmUsIExpbmtSYWRpYWxDdXJ2ZSwgcGF0aFJhZGlhbEN1cnZlLCBMaW5rSG9yaXpvbnRhbExpbmUsIHBhdGhIb3Jpem9udGFsTGluZSwgTGlua1ZlcnRpY2FsTGluZSwgcGF0aFZlcnRpY2FsTGluZSwgTGlua1JhZGlhbFN0ZXAgYXMgTGlua1JhZGlhbExpbmUsIHBhdGhSYWRpYWxMaW5lLCBMaW5rSG9yaXpvbnRhbFN0ZXAsIHBhdGhIb3Jpem9udGFsU3RlcCwgTGlua1ZlcnRpY2FsU3RlcCwgcGF0aFZlcnRpY2FsU3RlcCwgTGlua1JhZGlhbFN0ZXAkMSBhcyBMaW5rUmFkaWFsU3RlcCwgcGF0aFJhZGlhbFN0ZXAsIFBvbHlnb24sIGdldFBvaW50cywgZ2V0UG9pbnQgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///470\n")}}]);