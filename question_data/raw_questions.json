[
  {
    "question_theme": "countOfSmallerNumbersAfterSelf",
    "question": "/*************************************************************************************** \n *\n * You are given an integer array nums and you have to return a new counts array. The \n * counts array has the property where counts[i] is the number of smaller elements to \n * the right of nums[i].\n * \n * Example:\n * \n * Given nums = [5, 2, 6, 1]\n * \n * To the right of 5 there are 2 smaller elements (2 and 1).\n * To the right of 2 there is only 1 smaller element (1).\n * To the right of 6 there is 1 smaller element (1).\n * To the right of 1 there is 0 smaller element.\n * \n * Return the array [2, 1, 1, 0].\n * \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/count-of-smaller-numbers-after-self/\n// Author : Calinescu Valentin, Hao Chen\n// Date   : 2015-12-08\n\n\n\n\n// The following idea is based on a `Binary Index Tree` or 'Fenwick Tree'\n// There are two articles explaining this technique quite well:\n// 1) http://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/\n// 2) http://cs.stackexchange.com/questions/10538/bit-what-is-the-intuition-behind-a-binary-indexed-tree-and-how-was-it-thought-a\n\n#define zeros(i) (i ^ (i - 1)) & i\nclass Solution {\npublic:\n    vector <int> sorted, sol, fenwick;\n    int n;\n    int search(int t)\n    {\n        int step = 0;\n        for(; (1 << step) <= n; step++);\n        int i = 0;\n        for(int k = step; k >= 0; k--)\n            if(i + (1 << k) < n && sorted[i + (1 << k)] <= t)\n                i += (1 << k);\n        return i;\n    }\n    int compute(int t)\n    {\n        int s = 0;\n        for(int i = t; i > 0; i -= zeros(i))\n            s += fenwick[i];\n        return s;\n    }\n    void add(int t)\n    {\n        for(int i = t; i <= n; i += zeros(i))\n            fenwick[i]++;\n    }\n    vector<int> countSmaller(vector<int>& nums) {\n        if(nums.size())\n        {\n            sorted = nums;\n            n = nums.size();\n            sort(sorted.begin(), sorted.end());\n            vector <int> f(sorted.size());\n            fenwick = f;\n            for(int i = nums.size() - 1; i >= 0; i--)\n            {\n                int pos = search(nums[i]) + 1;\n                sol.push_back(compute(pos - 1));\n                add(pos);\n            }\n            reverse(sol.begin(), sol.end());\n        }\n        return sol;\n    }\n};\n\n\n\n\n\nclass BinarySearchTreeNode\n{\n    public:\n        int val;     \n        int less;      // count of members less than val\n        int count;     // count of members equal val\n        BinarySearchTreeNode *left, *right;\n        BinarySearchTreeNode(int value) : val(value), less(0),count(1),left(NULL), right(NULL) {}\n};\n\nclass BinarySearchTree\n{\n    private:\n        BinarySearchTreeNode* root;\n    public:\n        BinarySearchTree(const int value):root(new BinarySearchTreeNode(value)){ }\n        ~BinarySearchTree() {\n            freeTree(root);\n        }\n        void insert(const int value, int &numLessThan) {\n            insert(root, value, numLessThan);\n        }\n    private:\n        void freeTree(BinarySearchTreeNode* root){\n            if (root == NULL) return;\n            if (root->left) freeTree(root->left);\n            if (root->right) freeTree(root->right);\n            delete root;\n        }\n\n        void insert(BinarySearchTreeNode* root, const int value, int &numLessThan) {\n\n            if(value < root->val) {  // left\n                root->less++;\n                if(root->left == NULL) {\n                    root->left = new BinarySearchTreeNode(value);\n                }else{\n                    this->insert(root->left, value, numLessThan);\n                }\n            } else if(value > root->val) { // right\n                numLessThan += root->less + root->count;\n                if(!root->right) {\n                    root->right = new BinarySearchTreeNode(value);\n                }else{\n                    this->insert(root->right, value, numLessThan);\n                }\n            } else {\n                numLessThan += root->less;\n                root->count++;\n                return;\n            }\n        }\n};\n\nclass Solution {\n    public:\n        vector<int> countSmaller(vector<int>& nums) {\n            vector<int> counts(nums.size());\n            if(nums.size() == 0) return counts;\n\n            BinarySearchTree tree(nums[nums.size()-1]);\n\n            for(int i = nums.size() - 2; i >= 0; i--) {\n                int numLessThan = 0;\n                tree.insert( nums[i], numLessThan);\n                counts[i] = numLessThan;\n            }\n            return counts; \n        }\n};\n"
  },
  {
    "question_theme": "rectangleArea",
    "question": "/********************************************************************************** \n * \n * Find the total area covered by two rectilinear rectangles in a 2D plane.\n * Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.\n * \n *                      Y                                        \n *                      ^                                        \n *                      |                                        \n *                      |                                        \n *                      |                                        \n *                      |                                        \n *                      |     (C,D):(3,4)                        \n *            +------------------+                               \n *            |         |        |                               \n *            |         |        |                               \n *            |         |        |               (G,H):(9,2)     \n *            |         +----------------------------+           \n *            |         |        |                   |           \n *            |         |        |                   |           \n *            |         |        |                   |           \n *            +---------|--------+-------------------|---------> X\n *      (A,B):(-3,0)    |                            |           \n *                      +----------------------------+           \n *                  (E,F):(0,-1)                                 \n *      \n *      \n *      \n * Assume that the total area is never beyond the maximum possible value of int.\n * \n * Credits:Special thanks to @mithmatt for adding this problem, creating the above image and all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/rectangle-area/\n// Author : Hao Chen\n// Date   : 2015-06-12\n\n\n#include <iostream>\nusing namespace std;\n\nnamespace leetcode \n{\n    class Point {\n        public:\n            Point(int _x, int _y):x(_x),y(_y) {}\n            int x, y;\n    };\n\n    class Rectangle {\n        public:\n            Rectangle(int a, int b, int c, int d):topLeft(a,d), bottomRight(c,b) { }\n            int Area(){\n                return (bottomRight.x - topLeft.x)*(topLeft.y - bottomRight.y); \n            }\n\n            int InclusiveArea (Rectangle &r){\n                // I include it\n                if (r.topLeft.x >= topLeft.x && r.bottomRight.x <= bottomRight.x &&\n                        r.topLeft.y <= topLeft.y && r.bottomRight.y >= bottomRight.y ) {\n                    return this->Area();\n                }\n                // it includes me\n                if (r.topLeft.x <= topLeft.x && r.bottomRight.x >= bottomRight.x &&\n                        r.topLeft.y >= topLeft.y && r.bottomRight.y <= bottomRight.y ) {\n                    return r.Area();\n                }\n                // 0 - no inclusive\n                return 0;\n            }\n\n            int OverlappedArea(Rectangle &r) {\n                int overlap_x = max(0, min(r.bottomRight.x, bottomRight.x) - max(r.topLeft.x, topLeft.x));\n                int overlap_y = max(0, min(r.topLeft.y, topLeft.y) - max(r.bottomRight.y, bottomRight.y));\n                return overlap_x * overlap_y;\n            }\n\n            Point topLeft;\n            Point bottomRight;\n    };\n};\n\n\nint computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n    using namespace leetcode;\n    Rectangle r1(A,B,C,D);\n    Rectangle r2(E,F,G,H);\n    int area = r1.InclusiveArea(r2);\n    if (area > 0) return area;\n    return r1.Area() + r2.Area() - r1.OverlappedArea(r2);\n}\n\n\n\nint main() \n{\n    //16\n    cout << \"16 : \" << computeArea(-1, -1, 1, 1, -2, -2, 2, 2) << endl;\n    //16\n    cout << \"16 : \" << computeArea(-2, -2, 2, 2, -1, -1, 1, 1) << endl;\n    //17\n    cout << \"17 : \" << computeArea(-2, -2, 2, 2, -4, 3, -3, 4) << endl;\n    //45\n    cout << \"45 : \" << computeArea(-3, -0, 3, 4, 0, -1, 9, 2) << endl;\n    //24\n    cout << \"24 : \" << computeArea(-2, -2, 2, 2, -3, -3, 3, -1) << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "maximalSquare",
    "question": "/********************************************************************************** \n * \n * Given a 2D binary matrix filled with 0's and 1's, find the largest square containing all 1's and return its area.\n * \n * For example, given the following matrix:\n * \n * 1 0 1 0 0\n * 1 0 1 1 1\n * 1 1 1 1 1\n * 1 0 0 1 0\n * \n * Return 4.\n * \n * Credits:Special thanks to @Freezen for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/maximal-square/\n// Author : Hao Chen\n// Date   : 2015-06-12\n\n\n\n\n\n\nclass Solution {\npublic:\n    inline int min(int x, int y) {\n        return x<y? x:y;\n    }\n    inline int min(int x, int y, int z) {\n        return min(x, min(y, z));\n    }\n    int maximalSquare(vector<vector<char>>& matrix) {\n        int row = matrix.size();\n        if (row <=0) return 0;\n        int col = matrix[0].size();\n        \n        int maxSize = 0;\n        vector<vector<int>> dp(row, vector<int>(col));\n        \n        for (int i=0; i<matrix.size(); i++) {\n            for (int j=0; j<matrix[i].size(); j++){\n                //convert the `char` to `int`\n                dp[i][j] = matrix[i][j] -'0';\n                //for the first row and first column, or matrix[i][j], dp[i][j] is ZERO\n                //so, it's done during the previous conversion\n                \n                // i>0 && j>0 && matrix[i][j]=='1'\n                if (i!=0 && j!=0 & dp[i][j]!=0){\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1;\n                }\n                \n                //tracking the maxSize\n                if (dp[i][j] > maxSize ){\n                    maxSize = dp[i][j];\n                }\n            }\n        }\n        \n        return maxSize*maxSize;\n    }\n};\n"
  },
  {
    "question_theme": "addAndSearchWord",
    "question": "/********************************************************************************** \n * \n * Design a data structure that supports the following two operations:\n * \n * void addWord(word)\n * bool search(word)\n * \n * search(word) can search a literal word or a regular expression string containing only letters `a-z` or `.`\n * A `.` means it can represent any one letter.\n * \n * For example:\n * \n *   addWord(\"bad\")\n *   addWord(\"dad\")\n *   addWord(\"mad\")\n *   search(\"pad\") -> false\n *   search(\"bad\") -> true\n *   search(\".ad\") -> true\n *   search(\"b..\") -> true\n * \n * Note:\n * You may assume that all words are consist of lowercase letters a-z.\n * \n * click to show hint.\n * \n * You should be familiar with how a Trie works. If not, please work on this problem: Implement Trie (Prefix Tree) first.\n * \n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/add-and-search-word-data-structure-design/\n// Author : Hao Chen\n// Date   : 2015-06-10\n\n\n#include <string.h>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nconst int MAX_CHARS = 26;\n\n\nclass TrieNode {\npublic:\n    TrieNode():isWord(false) {\n        memset(childern, 0, sizeof(childern));\n    }\n    TrieNode* & operator [] (char idx){\n        int i = (idx-'a') % MAX_CHARS;\n        return childern[i];\n    }\n    TrieNode* & operator [] (int idx){\n        int i = idx % MAX_CHARS;\n        return childern[i];\n    }\n    bool isWord;\nprivate:\n    TrieNode* childern[MAX_CHARS];\n};\n\n\n\nclass TrieTree {\npublic:\n    TrieTree():root(new TrieNode()){ }\n    ~TrieTree() { freeTree(root); }\n    \n    void put(string &s) {\n        TrieNode* node = root;\n        for (int i=0; i<s.size(); i++){\n            if ((*node)[s[i]] == NULL){\n                (*node)[s[i]] = new TrieNode();\n            }\n            node = (*node)[s[i]];\n        }\n        node->isWord = true;\n    }\n    bool search(string &s){\n        return get(s, this->root);\n    }\n\nprivate:\n\n    bool get(string &s, TrieNode* root, int idx=0){\n        TrieNode* node = root;\n        for (int i=idx; i<s.size(); i++){\n            if (s[i]!='.'){\n                node = (*node)[s[i]];\n                if (node == NULL) return false;\n            }else{\n                for (int j=0; j<MAX_CHARS; j++) {\n                    TrieNode *p = (*node)[j];\n                    if (p == NULL ) {\n                        continue;//try next\n                    }\n                    // p!=NULL\n                    if (i<s.size()-1) {\n                        if (this->get(s, p, i+1)) {\n                            return true;\n                        }\n                        continue; //try next\n                    }\n                    // p!=NULL && i == s.size()-1\n                    if (p->isWord) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n        return node->isWord; \n    }\n    \nprivate:\n    void freeTree(TrieNode* root){\n        for(int i=0; i<MAX_CHARS; i++){\n            if ((*root)[i]!=NULL){\n                freeTree((*root)[i]);\n            }\n        }\n        delete root;\n    }\n    TrieNode *root;\n};\n\nclass WordDictionary {\npublic:\n\n    // Adds a word into the data structure.\n    void addWord(string word) {\n        tree.put(word);\n    }\n\n    // Returns if the word is in the data structure. A word could\n    // contain the dot character '.' to represent any one letter.\n    bool search(string word) {\n        return tree.search(word);\n    }\nprivate:\n    TrieTree tree;\n};\n\n// Your WordDictionary object will be instantiated and called as such:\n// WordDictionary wordDictionary;\n// wordDictionary.addWord(\"word\");\n// wordDictionary.search(\"pattern\");\n\nint main()\n{\n    WordDictionary wd;\n    wd.addWord(\"a\");\n    cout << wd.search(\"a.\") <<endl;;\n    cout << wd.search(\".a\") << endl;;\n    wd.addWord(\"bad\");\n    cout << wd.search(\"bad\") <<endl;;\n    cout << wd.search(\"b..\") <<endl;;\n    return 0;\n}\n\n\n\n"
  },
  {
    "question_theme": "binaryTreeLevelOrderTraversal",
    "question": "/********************************************************************************** \n* \n* Given a binary tree, return the level order traversal of its nodes' values. \n* (ie, from left to right, level by level).\n* \n* For example:\n* Given binary tree {3,9,20,#,#,15,7},\n* \n*     3\n*    / \\\n*   9  20\n*     /  \\\n*    15   7\n* \n* return its level order traversal as:\n* \n* [\n*   [3],\n*   [9,20],\n*   [15,7]\n* ]\n* \n* confused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ.\n* \n* OJ's Binary Tree Serialization:\n* \n* The serialization of a binary tree follows a level order traversal, where '#' signifies \n* a path terminator where no node exists below.\n* \n* Here's an example:\n* \n*    1\n*   / \\\n*  2   3\n*     /\n*    4\n*     \\\n*      5\n* \n* The above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\". \n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/binary-tree-level-order-traversal/\n// Author : Hao Chen\n// Date   : 2014-07-17\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvector<vector<int> > levelOrder1(TreeNode *root);\nvector<vector<int> > levelOrder2(TreeNode *root);\nvector<vector<int> > levelOrder3(TreeNode *root);\n\n\nvector<vector<int> > levelOrder(TreeNode *root) {\n    if (random()%2){\n        return levelOrder1(root);\n    }\n    if (random()%2){\n        return levelOrder3(root);\n    }\n    return levelOrder2(root);\n}\n\nvector<vector<int> > levelOrder1(TreeNode *root) {\n    queue<TreeNode*> q;\n    vector< vector<int> > vv;\n    vector<int> v;\n    if (root){\n        v.push_back(root->val);\n        vv.push_back(v);\n    }\n    q.push(root);\n    int i=0;\n    vector<TreeNode*> vt; \n    while(q.size()>0){\n        TreeNode *p = q.front();\n        q.pop();\n        vt.push_back(p); \n        if ( p==NULL ) {\n            continue;\n        }\n        q.push(p->left);\n        q.push(p->right);\n    }\n    \n    \n    int step = 2;\n    int j; \n    for (int i=1; i<vt.size(); i=j ){\n        v.clear();\n        \n        int cnt=0;\n        for (j=i; j<i+step && j<vt.size(); j++){\n            if (vt[j]) {\n                v.push_back(vt[j]->val);\n                cnt += 2; \n            }\n        } \n        step = cnt;\n        if (v.size()>0) {\n            vv.push_back(v);\n        }\n    }\n\n    return vv;\n}\n\nvector<vector<int> > levelOrder2(TreeNode *root) {\n    vector< vector<int> > vv;\n    vector<int> v;\n    if (root){\n        v.push_back(root->val);\n        vv.push_back(v);\n    }\n\n    vector< vector<int> > vv_left, vv_right;\n    if(root && root->left) {\n        vv_left = levelOrder2(root->left);\n    }\n    if(root && root->right) {\n        vv_right = levelOrder2(root->right);\n    }\n\n    //merge\n    for(int i=0; i<vv_left.size() || i < vv_right.size(); i++){\n        if (i<vv_left.size() && i<vv_right.size()){\n            vv_left[i].insert(vv_left[i].end(), vv_right[i].begin(), vv_right[i].end());\n            vv.push_back(vv_left[i]);\n        }else if (i<vv_left.size()) {\n            vv.push_back(vv_left[i]);\n        }else {\n            vv.push_back(vv_right[i]);\n        }\n    }\n\n    return vv;\n}\n\nvector<vector<int> > levelOrder3(TreeNode *root) {\n    vector< vector<int> > vv;\n    if(root == NULL) return vv;\n\n    int level = 0; // current level.\n    TreeNode *last = root; // last node of currrent level.\n    queue<TreeNode*> q;\n\n    q.push(root);\n    vv.push_back(vector<int>());\n    while(!q.empty()) {\n        TreeNode *p = q.front();\n        q.pop();\n\n        vv[level].push_back(p->val);\n        if(p->left ) q.push(p->left);\n        if(p->right) q.push(p->right);\n\n        if(p == last) {\n            level++;\n            last = q.back();\n            vv.push_back(vector<int>()); // new buffer for next row.\n        }\n    }\n    vv.pop_back();\n\n    return vv;\n}\n\nvoid printTree(TreeNode *root)\n{\n    if (root == NULL){\n        printf(\"# \");\n        return;\n    }\n    printf(\"%d \", root->val );\n\n    printTree(root->left);\n    printTree(root->right);\n}\n\nvoid printTree_level_order(TreeNode *root)\n{\n    queue<TreeNode*> q;\n    q.push(root);\n    while (q.size()>0){\n        TreeNode* n = q.front();\n        q.pop();\n        if (n==NULL){\n            cout << \"# \";\n            continue;\n        }\n        cout << n->val << \" \";\n        q.push(n->left);\n        q.push(n->right);\n    } \n    cout << endl;\n}\n\nTreeNode* createTree(int a[], int n)\n{\n    if (n<=0) return NULL;\n\n    TreeNode **tree = new TreeNode*[n];\n\n    for(int i=0; i<n; i++) {\n        if (a[i]==0 ){\n            tree[i] = NULL;\n            continue;\n        }\n        tree[i] = new TreeNode(a[i]);\n    } \n    int pos=1;\n    for(int i=0; i<n && pos<n; i++) {    \n        if (tree[i]){\n            tree[i]->left = tree[pos++];\n            if (pos<n){\n                tree[i]->right = tree[pos++];\n            }\n        }\n    }\n    return tree[0];\n}\n\nint printMatrix(vector< vector<int> > &vv)\n{\n    for(int i=0; i<vv.size(); i++) {\n        cout << \"[\";\n        for(int j=0; j<vv[i].size(); j++) {\n            cout << \" \" << vv[i][j];\n        }\n        cout << \"]\" << endl;;\n    }\n}\n\nint main()\n{\n    TreeNode *p;\n    vector< vector<int> > vv;\n\n    int a[] = {1,2,3,4,5,0,0};\n    p = createTree(a, sizeof(a)/sizeof(int));\n    printTree_level_order(p);\n    vv = levelOrder(p);\n    printMatrix(vv);\n    cout << endl;\n    \n    int b[] = {1,0,2};\n    p = createTree(b, sizeof(b)/sizeof(int));\n    printTree_level_order(p);\n    vv = levelOrder(p);\n    printMatrix(vv);\n    cout << endl;\n\n    int c[] = {1,2,0,3,0,4,0,5};\n    p = createTree(c, sizeof(c)/sizeof(int));\n    printTree_level_order(p);\n    vv = levelOrder(p);\n    printMatrix(vv);\n    cout << endl;\n\n    int d[] = {1,2,3,4,0,0,5};\n    p = createTree(d, sizeof(d)/sizeof(int));\n    printTree_level_order(p);\n    vv = levelOrder(p);\n    printMatrix(vv);\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "removeDuplicatesFromSortedList",
    "question": "/********************************************************************************** \n* \n* Given a sorted linked list, delete all duplicates such that each element appear only once.\n* \n* For example,\n* Given 1->1->2, return 1->2.\n* Given 1->1->2->3->3, return 1->2->3.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/\n// Author : Hao Chen\n// Date   : 2014-06-21\n\n\n\n#include <stdio.h>\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode *deleteDuplicates(ListNode *head) {\n\n    for(ListNode *p=head; p && p->next; ){\n        if (p->val == p->next->val){\n            p->next = p->next->next;\n            continue;\n        }\n        p=p->next;\n    }\n    return head;\n}\n\nvoid printList(ListNode* h)\n{\n    while(h!=NULL){\n        printf(\"%d \", h->val);\n        h = h->next;\n    }\n    printf(\"\\n\");\n}\n\nListNode* createList(int a[], int n)\n{\n    ListNode *head=NULL, *p=NULL;\n    for(int i=0; i<n; i++){\n        if (head == NULL){\n            head = p = new ListNode(a[i]);\n        }else{\n            p->next = new ListNode(a[i]);\n            p = p->next;\n        }\n    }\n    return head;\n}\n\n\nint main()\n{\n    int a[]={1,1,2,3,3};\n    int b[]={1,1,1};\n\n    printList(deleteDuplicates(createList(a, sizeof(a)/sizeof(int))));\n    printList(deleteDuplicates(createList(b, sizeof(b)/sizeof(int))));\n    return 0;\n}\n\n"
  },
  {
    "question_theme": "searchForRange",
    "question": "/********************************************************************************** \n* \n* Given a sorted array of integers, find the starting and ending position of a given target value.\n* \n* Your algorithm's runtime complexity must be in the order of O(log n).\n* \n* If the target is not found in the array, return [-1, -1].\n* \n* For example,\n* Given [5, 7, 7, 8, 8, 10] and target value 8,\n* return [3, 4].\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/search-for-a-range/\n// Author : Hao Chen\n// Date   : 2014-06-26\n\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint binary_search(int A[], int low, int high, int key);\n\n\nvector<int> searchRange(int A[], int n, int target) {\n    int pos = binary_search(A, 0, n-1, target);\n\n    vector<int> v;\n    int low = -1, high = -1;\n    if (pos >=0){\n        low = high = pos;\n        int l = low;\n        do {\n            low = l;\n            l = binary_search(A, 0, low - 1, target);\n        }while (l>=0);\n\n        int h = high;\n        do {\n            high = h;\n            h = binary_search(A, high + 1, n-1, target);\n        }while (h>=0);\n    }\n\n    v.push_back(low);\n    v.push_back(high);\n    return v;\n\n}\n\nint binary_search(int A[], int low, int high, int key){\n\n    while (low<=high) {\n        int mid = low + (high-low)/2;\n        if (A[mid] == key) {\n            return mid;\n        }\n        if (key > A[mid]) {\n            low = mid + 1;\n        }\n        if (key < A[mid]) {\n            high = mid - 1;\n        }\n    }\n    return -1;\n}\n\nvoid printVector( vector<int>&  pt)\n{\n    cout << \"{ \";\n    for(int j=0; j<pt.size(); j++){\n        cout << pt[j] << \" \";\n    }\n    cout << \"} \" << endl;\n}\n\n\nint main()\n{\n    const int cnt=6;\n    int a[cnt] ={5, 7, 7, 8, 8, 10};\n\n    vector<int> v;\n    v = searchRange(a, cnt, 8);     \n    printVector(v);    \n\n\n    int b[cnt] ={5, 5, 5, 8, 8, 10};\n    v = searchRange(b, cnt, 5);     \n    printVector(v);    \n\n    int c[cnt] ={5, 5, 5, 5, 5, 5};\n    v = searchRange(c, cnt, 5);     \n    printVector(v);    \n    return 0;\n}\n"
  },
  {
    "question_theme": "removeElement",
    "question": "/********************************************************************************** \n* \n* Given an array and a value, remove all instances of that value in place and return the new length.\n* \n* The order of elements can be changed. It doesn't matter what you leave beyond the new length.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/remove-element/\n// Author : Hao Chen\n// Date   : 2014-06-19\n\n\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int pos = 0;\n        for (int i=0; i<nums.size(); i++){\n            if (nums[i] != val){\n                nums[pos++] = nums[i]; \n            }\n        }\n        return pos;\n    }\n\n    int removeElement(int A[], int n, int elem) {\n        int tail = n-1;\n        int i = 0;\n        while ( i<=tail ){\n            if (A[i]==elem){\n                A[i] = A[tail--];\n                continue;\n            }\n            i++;\n        }\n        \n        return tail+1;\n    }\n};\n"
  },
  {
    "question_theme": "firstBadVersion",
    "question": "/*************************************************************************************** \n *\n * You are a product manager and currently leading a team to develop a new product. \n * Unfortunately, the latest version of your product fails the quality check. Since \n * each version is developed based on the previous version, all the versions after a \n * bad version are also bad. \n * \n * Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad \n * one, which causes all the following ones to be bad.\n * \n * You are given an API bool isBadVersion(version) which will return whether version is \n * bad. Implement a function to find the first bad version. You should minimize the \n * number of calls to the API.\n * \n * Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating \n * all test cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/first-bad-version/\n// Author : Hao Chen\n// Date   : 2015-10-19\n\n\n\n// Forward declaration of isBadVersion API.\nbool isBadVersion(int version);\n\nclass Solution {\npublic:\n    //Binary search\n    int firstBadVersion(int n) {\n        int low=1, high=n;\n        while(low <= high) {\n            int mid = low + (high - low)/2;\n            if (isBadVersion(mid) && !isBadVersion(mid-1)){\n                return mid;\n            }\n            if (isBadVersion(mid)) {\n                high = mid - 1;\n            }else{\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n};\n"
  },
  {
    "question_theme": "bestTimeToBuyAndSellStock",
    "question": "/********************************************************************************** \n* \n* Say you have an array for which the ith element is the price of a given stock on day i.\n* \n* Design an algorithm to find the maximum profit. You may complete as many transactions \n* as you like (ie, buy one and sell one share of the stock multiple times). However, \n* you may not engage in multiple transactions at the same time (ie, you must sell the \n* stock before you buy again).\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\n// Author : Hao Chen\n// Date   : 2014-06-18\n\n\n\nclass Solution {\npublic:\n    //\n    // find all of ranges: which start a valley with the nearest peak after\n    // add their delta together \n    //\n    int maxProfit(vector<int> &prices) {\n        int max=0, begin=0, end=0;\n        bool up=false, down=false;\n        for (int i=1; i<prices.size(); i++) {\n            if (prices[i] > prices[i-1] && up==false){ // goes up\n                begin = i-1;\n                up = true;\n                down = false;\n            }\n            \n            if (prices[i] < prices[i-1] && down==false) { // goes down\n                end = i-1;\n                down = true;\n                up = false;\n                max += (prices[end] - prices[begin]);\n            }\n        }\n        // edge case \n        if (begin < prices.size() && up==true){\n            end = prices.size() - 1;\n            max += (prices[end] - prices[begin]);\n        }\n        \n        return max;\n    }\n};\n"
  },
  {
    "question_theme": "convertSortedListToBinarySearchTree",
    "question": "/********************************************************************************** \n* \n* Given a singly linked list where elements are sorted in ascending order, \n* convert it to a height balanced BST.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/\n// Author : Hao Chen\n// Date   : 2014-07-03\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\n\nTreeNode* sortedListToBST(int low, int high, ListNode*& head);\n\nTreeNode *sortedListToBST(ListNode *head) {\n    int len = 0;\n    \n    for(ListNode* p=head; p!=NULL; p=p->next){\n        len++;\n    }\n    return sortedListToBST(0, len-1, head);\n}\n\nTreeNode* sortedListToBST(int low, int high, ListNode*& head) {\n    if (low>high || head==NULL) return NULL;\n\n    int mid = low + (high - low)/2;\n\n    TreeNode* leftNode = sortedListToBST(low, mid-1, head);\n\n    TreeNode* node = new TreeNode(head->val);\n    node->left = leftNode;\n    head = head->next;\n\n    TreeNode* rightNode = sortedListToBST(mid+1, high, head);\n    node->right = rightNode;\n\n    return node;\n}\n\nvoid printTree_level_order(TreeNode *root)\n{\n    queue<TreeNode*> q;\n    q.push(root);\n    while (q.size()>0){\n        TreeNode* n = q.front();\n        q.pop();\n        if (n==NULL){\n            cout << \"# \";\n            continue;\n        }\n        cout << n->val << \" \";\n        q.push(n->left);\n        q.push(n->right);\n    }\n    cout << endl;\n}\n\nListNode* createList(int a[], int n)\n{\n    ListNode *head=NULL, *p=NULL;\n    for(int i=0; i<n; i++){\n        if (head == NULL){\n            head = p = new ListNode(a[i]);\n        }else{\n            p->next = new ListNode(a[i]);\n            p = p->next;\n        }\n    }\n    return head;\n}\n\nvoid printList(ListNode* h)\n{\n    while(h!=NULL){\n        printf(\"%d -> \", h->val);\n        h = h->next;\n    }\n    printf(\"NULL\\n\");\n}\n\n\nint main(int argc, char** argv)\n{\n    int n = 8;\n    if (argc>1){\n        n = atoi(argv[1]);\n    }\n    int *a = new int[n];\n    for(int i=0; i<n; i++){\n        a[i]=i+1;\n    }\n    ListNode* head = createList(a, n);\n    printList(head);\n    TreeNode* root = sortedListToBST(head); \n    printTree_level_order(root);\n    delete[] a; \n\n    return 0;\n}\n\n"
  },
  {
    "question_theme": "trappingRainWater",
    "question": "/********************************************************************************** \n* \n* Given n non-negative integers representing an elevation map where the width of each bar is 1, \n* compute how much water it is able to trap after raining. \n* \n* For example, \n* Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.\n*   \n*     ^                                             \n*     |                                             \n*   3 |                       +--+                  \n*     |                       |  |                  \n*   2 |          +--+xxxxxxxxx|  +--+xx+--+         \n*     |          |  |xxxxxxxxx|  |  |xx|  |         \n*   1 |   +--+xxx|  +--+xxx+--+  |  +--+  +--+      \n*     |   |  |xxx|  |  |xxx|  |  |  |  |  |  |      \n*   0 +---+--+---+--+--+---+--+--+--+--+--+--+----->\n*       0  1   0  2  1   0  1  3  2  1  2  1        \n* \n* The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, \n* 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/trapping-rain-water/\n// Author : Hao Chen\n// Date   : 2014-07-02\n\n\n\n#include <stdio.h>\n\nint trap(int a[], int n) {\n    int result = 0;\n\n    //find the highest value/position\n    int maxHigh = 0;\n    int maxIdx = 0;\n    for(int i=0; i<n; i++){\n        if (a[i] > maxHigh){\n            maxHigh = a[i];\n            maxIdx = i;\n        }\n    }\n\n    //from the left to the highest postion\n    int prevHigh = 0;\n    for(int i=0; i<maxIdx; i++){\n        if(a[i] > prevHigh){\n            prevHigh = a[i];\n        }\n        result += (prevHigh - a[i]);\n    }\n\n    //from the right to the highest postion\n    prevHigh=0;\n    for(int i=n-1; i>maxIdx; i--){\n        if(a[i] > prevHigh){\n            prevHigh = a[i];\n        }\n        result += (prevHigh - a[i]);\n    }\n\n    return result;\n}\n\n#define TEST(a) printf(\"%d\\n\", trap(a, sizeof(a)/sizeof(int)))\nint main()\n{\n    int a[]={2,0,2};\n    TEST(a);\n    int b[]={0,1,0,2,1,0,1,3,2,1,2,1};\n    TEST(b);\n    return 0;\n}\n"
  },
  {
    "question_theme": "powerOfFour",
    "question": "/*************************************************************************************** \n *\n * Given an integer (signed 32 bits), write a function to check whether it is a power \n * of 4.\n * \n * Example:\n * Given num = 16, return true.\n * Given num = 5, return false.\n * \n * Follow up: Could you solve it without loops/recursion?\n * \n * Credits:Special thanks to @yukuairoy  for adding this problem and creating all test \n * cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/power-of-four/\n// Author : Hao Chen\n// Date   : 2016-05-29\n\n\n\n\nclass Solution {\npublic:\n    bool isPowerOfFour(int num) {\n        static int mask = 0b01010101010101010101010101010101;\n        \n        //edge case\n        if (num<=0) return false;\n        \n        // there are multiple bits are 1\n        if ((num & num-1) != 0) return false;\n        \n        // check which one bit is zero, if the place is 1 or 3 or 5 or 7 or 9...,\n        // then it is the power of 4\n        if ((num & mask) != 0) return true;\n        return false;\n    }\n};\n"
  },
  {
    "question_theme": "mergeTwoSortedList",
    "question": "/********************************************************************************** \n* \n* Merge two sorted linked lists and return it as a new list. The new list should be \n* made by splicing together the nodes of the first two lists.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/merge-two-sorted-lists/\n// Author : Hao Chen\n// Date   : 2014-07-06\n\n\n\n\nclass Solution {\npublic:\n    Solution(){\n        srand(time(NULL));\n    }\n    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\n        switch (random()%3){\n            case 0:\n                return mergeTwoLists01(l1, l2);\n            case 1:\n                return mergeTwoLists02(l1, l2);\n            default:\n                return mergeTwoLists03(l1, l2);\n        }\n    }\n    \n    \n    ListNode *mergeTwoLists01(ListNode* head1, ListNode* head2){\n        ListNode *p1 = head1,  *p2=head2;\n        static ListNode dummy(0);\n    \n        dummy.next = p1;\n        ListNode *prev = &dummy;\n    \n        while(p1 && p2){\n            if(p1->val < p2->val){\n                prev = p1;\n                p1 = p1->next;\n            }else{\n                prev->next = p2;\n                p2 = p2->next;\n                prev = prev->next;\n                prev->next = p1;\n            }\n        }\n        if (p2){\n            prev->next = p2;\n        }\n    \n        return dummy.next;\n    }\n\n\n    \n    ListNode *mergeTwoLists02(ListNode *l1, ListNode *l2) {\n        ListNode *l=NULL, *p=NULL;\n        \n        while (l1!=NULL && l2!=NULL ){\n            ListNode *n=NULL;\n            if (l1->val < l2-> val){\n                n = l1;\n                l1=l1->next;\n            }else{\n                n = l2;\n                l2=l2->next;\n            }\n            if (l==NULL){\n                l = p = n;\n            }else{\n                p->next = n;\n                p = p->next;\n            }\n        }\n        \n        ListNode* rest = l1 ? l1 :l2;\n        \n        l = mergeTheRest(rest, l, p);\n       \n        \n        return l;\n    }\n\n    ListNode* mergeTheRest(ListNode* l, ListNode*head, ListNode* tail){\n        if (l){\n            if (head && tail ){\n                tail->next = l;\n            }else{\n                head = l;\n            }\n        }\n        return head;\n    }\n\n    \n    ListNode *mergeTwoLists03(ListNode *l1, ListNode *l2) {\n        ListNode *head = NULL;\n        ListNode **pTail = &head;\n        while (l1 != NULL && l2 != NULL) {\n            if (l1->val < l2->val) {\n                *pTail = l1;\n                l1 = l1->next;\n            } else {\n                *pTail = l2;\n                l2 = l2->next;\n            }\n            pTail = &(*pTail)->next;\n        }\n        *pTail = (l1 != NULL ? l1 : l2);\n        return head;\n    }\n\n};\n"
  },
  {
    "question_theme": "binarySearchTreeIterator",
    "question": "/********************************************************************************** \n * \n * Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.\n * \n * Calling next() will return the next smallest number in the BST.\n * \n * Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. \n * \n * Credits:Special thanks to @ts for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/binary-search-tree-iterator/\n// Author : Hao Chen\n// Date   : 2014-12-31\n\n\n\nclass BSTIterator {\n    private:\n        vector<int> v; \n        int pos;\n    public:\n        //Travse the Tree in-order and covert it to an array\n        BSTIterator(TreeNode *root) {\n            pos = 0;\n            vector<TreeNode*> stack;\n            while(stack.size()>0 || root !=NULL) {\n                if (root){\n                    stack.push_back(root);\n                    root = root->left;\n                }else{\n                    root = stack.back();\n                    stack.pop_back();\n                    v.push_back(root->val);\n                    root = root->right;\n                }\n            }\n        }\n\n        \n        bool hasNext() {\n            return pos < v.size();\n        }\n\n        \n        int next() {\n            return v[pos++];\n        }\n};\n"
  },
  {
    "question_theme": "excelSheetColumnTitle",
    "question": "/********************************************************************************** \n * \n * Given a positive integer, return its corresponding column title as appear in an Excel sheet.\n * \n * For example:\n * \n *     1 -> A\n *     2 -> B\n *     3 -> C\n *     ...\n *     26 -> Z\n *     27 -> AA\n *     28 -> AB \n * \n * Credits:Special thanks to @ifanchu for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/excel-sheet-column-title/\n// Author : Hao Chen\n// Date   : 2014-12-25\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <string>\nusing namespace std;\n\n\nstring base26_int2str(long long n) {\n    string ret;\n    while(n>0){\n        char ch = 'A' + (n-1)%26;\n        ret.insert(ret.begin(), ch  );\n        n -= (n-1)%26;\n        n /= 26;\n    }\n    return ret;\n}\n\nlong long base26_str2int(string& s){\n    long long ret=0;\n    for (int i=0; i<s.size(); i++){\n        int n = s[i] - 'A' + 1;\n        ret = ret*26 + n;\n    }\n    return ret;\n}\n\n\nstring convertToTitle(int n) {\n    return base26_int2str(n);\n}\n\nint main(int argc, char**argv)\n{\n    long long n = 27; \n    if (argc>1){\n        n = atoll(argv[1]);\n    }\n    string ns = base26_int2str(n);\n    n = base26_str2int(ns);\n\n    cout << n << \" = \" << ns << endl;\n\n\n    ns = \"ABCDEFG\";\n    if (argc>2){\n        ns = argv[2];\n    }\n    cout << ns << \" = \" << base26_str2int(ns) << endl;\n}\n"
  },
  {
    "question_theme": "mostCommonWord",
    "question": "/*************************************************************************************** \n *\n * Given a paragraph and a list of banned words, return the most frequent word that is \n * not in the list of banned words.  It is guaranteed there is at least one word that \n * isn't banned, and that the answer is unique.\n * \n * Words in the list of banned words are given in lowercase, and free of punctuation.  \n * Words in the paragraph are not case sensitive.  The answer is in lowercase.\n * \n * \n * Example:\n * Input: \n * paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\"\n * banned = [\"hit\"]\n * Output: \"ball\"\n * Explanation: \n * \"hit\" occurs 3 times, but it is a banned word.\n * \"ball\" occurs twice (and no other word does), so it is the most frequent non-banned \n * word in the paragraph. \n * Note that words in the paragraph are not case sensitive,\n * that punctuation is ignored (even if adjacent to words, such as \"ball,\"), \n * and that \"hit\" isn't the answer even though it occurs more because it is banned.\n * \n * \n *  \n * \n * Note: \n * \n * \n * \t1 <= paragraph.length <= 1000.\n * \t1 <= banned.length <= 100.\n * \t1 <= banned[i].length <= 10.\n * \tThe answer is unique, and written in lowercase (even if its occurrences in \n * paragraph may have uppercase symbols, and even if it is a proper noun.)\n * \tparagraph only consists of letters, spaces, or the punctuation symbols !?',;.\n * \tDifferent words in paragraph are always separated by a space.\n * \tThere are no hyphens or hyphenated words.\n * \tWords only consist of letters, never apostrophes or other punctuation \n * symbols.\n * \n * \n *  \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/most-common-word/\n// Author : Hao Chen\n// Date   : 2018-04-19\n\n\n\n\nclass Solution {\nprivate:\n    bool isLetter(char c) {\n        return c >= 'a' && c <= 'z';\n    }\npublic:\n    string mostCommonWord(string paragraph, vector<string>& banned) {\n        unordered_map<string, int> banned_map, words_map;\n        for (auto w:banned) {\n            banned_map[w]++;\n        }\n        \n        //conert the string to lower case.\n        transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\n        \n        //transfer the symbols to space.\n        for (int i=0; i<paragraph.size(); i++) {\n            if ( !isLetter(paragraph[i]) ){\n                paragraph[i] = ' ';\n            }\n        }\n        string word;\n        for(auto c:paragraph) {\n            if (isLetter(c)) { \n                word += c;\n            }else{\n                if ( word.size()>0 ) {\n                    words_map[word]++;\n                }\n                word=\"\";\n            }\n        }\n        if ( word.size()>0 ) words_map[word]++;\n        \n        string result;\n        int max_cnt=0;\n        // go through the words_map\n        for (auto const& w : words_map) {\n            \n            if ( banned_map.find(w.first) != banned_map.end() ) {\n                continue;\n            }\n            if (max_cnt < w.second) {\n                result = w.first;\n                max_cnt = w.second;\n            }\n        }\n\n        return result;\n    }\n};\n"
  },
  {
    "question_theme": "pathSum",
    "question": "/********************************************************************************** \n* \n* Given a binary tree and a sum, determine if the tree has a root-to-leaf path \n* such that adding up all the values along the path equals the given sum.\n* \n* For example:\n* Given the below binary tree and sum = 22,\n* \n*               5\n*              / \\\n*             4   8\n*            /   / \\\n*           11  13  4\n*          /  \\      \\\n*         7    2      1\n* \n* return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/path-sum/\n// Author : Hao Chen\n// Date   : 2014-06-22\n\n\n\n#include <time.h>\n\n\nclass Solution {\npublic:\n    Solution(){\n        srand(time(NULL));\n    }\n    bool hasPathSum(TreeNode *root, int sum) {\n        if (random()%2){\n            return hasPathSum1(root, sum);    \n        }\n        return hasPathSum2(root, sum);\n    }\n    \n    bool hasPathSum1(TreeNode *root, int sum) {\n        if (root==NULL) return false;\n        vector<TreeNode*> v;\n        v.push_back(root);\n        while(v.size()>0){\n            TreeNode* node = v.back();\n            v.pop_back();\n            if (node->left==NULL && node->right==NULL){\n                if (node->val == sum){\n                    return true;\n                }\n            }\n            if (node->left){\n                node->left->val += node->val;\n                v.push_back(node->left);\n            }\n            if (node->right){\n                node->right->val += node->val;\n                v.push_back(node->right);\n            }\n        }\n        return false;\n        \n    }\n    \n    bool hasPathSum2(TreeNode *root, int sum) {\n        \n        if (root==NULL) return false;\n        \n        if (root->left==NULL && root->right==NULL ){\n            return (root->val==sum);\n        }\n        \n        if (root->left){\n            root->left->val += root->val;\n            if (hasPathSum2(root->left, sum)){\n                return true;\n            }\n        }\n        \n        if (root->right){\n            root->right->val += root->val;\n            if (hasPathSum2(root->right, sum)){\n                return true;\n            }\n        }\n        \n        return false;\n    }\n\n};\n"
  },
  {
    "question_theme": "peekingIterator",
    "question": "/*************************************************************************************** \n *\n * Given an Iterator class interface with methods: next() and hasNext(), design and \n * implement a PeekingIterator that support the peek() operation -- it essentially \n * peek() at the element that will be returned by the next call to next().\n * \n * Here is an example. Assume that the iterator is initialized to the beginning of the \n * list: [1, 2, 3].\n * \n * Call next() gets you 1, the first element in the list.\n * \n * Now you call peek() and it returns 2, the next element. Calling next() after that \n * still return 2.\n * \n * You call next() the final time and it returns 3, the last element. Calling hasNext() \n * after that should return false.\n * \n *   Think of \"looking ahead\". You want to cache the next element.\n *   Is one variable sufficient? Why or why not?\n *   Test your design with call order of peek() before next() vs next() before peek().\n *   For a clean implementation, check out Google's guava library source code.\n * \n * Follow up: How would you extend your design to be generic and work with all types, \n * not just integer?\n * \n * Credits:Special thanks to @porker2008 for adding this problem and creating all test \n * cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/peeking-iterator/\n// Author : Hao Chen\n// Date   : 2015-11-10\n\n\n\n// Below is the interface for Iterator, which is already defined for you.\n// **DO NOT** modify the interface for Iterator.\nclass Iterator {\n    struct Data;\n    Data* data;\npublic:\n    Iterator(const vector<int>& nums);\n    Iterator(const Iterator& iter);\n    virtual ~Iterator();\n    // Returns the next element in the iteration.\n    int next();\n    // Returns true if the iteration has more elements.\n    bool hasNext() const;\n};\n\n\nclass PeekingIterator : public Iterator {\nprivate:\n    bool m_hasNext;\n    int m_next;\n    \n    void takeNext() {\n        m_hasNext = Iterator::hasNext();\n        if (m_hasNext) {\n            m_next = Iterator::next();\n        }  \n    }\npublic:\n    PeekingIterator(const vector<int>& nums) : Iterator(nums) {\n        // Initialize any member here.\n        // **DO NOT** save a copy of nums and manipulate it directly.\n        // You should only use the Iterator interface methods.\n        takeNext();\n    }\n\n    // Returns the next element in the iteration without advancing the iterator.\n    int peek() {\n        return m_next;\n    }\n\n    // hasNext() and next() should behave the same as in the Iterator interface.\n    // Override them if needed.\n    int next() {\n        int temp = m_next;\n        takeNext();\n        return temp;\n        \n    }\n\n    bool hasNext() const {\n        return m_hasNext;\n    }\n};\n\n"
  },
  {
    "question_theme": "shortestPalindrome",
    "question": "/********************************************************************************** \n * \n * Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. \n * Find and return the shortest palindrome you can find by performing this transformation.\n * \n * For example: \n * Given \"aacecaaa\", return \"aaacecaaa\".\n * Given \"abcd\", return \"dcbabcd\".\n * \n * Credits:Special thanks to @ifanchu for adding this problem and creating all test cases. \n * Thanks to @Freezen for additional test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/shortest-palindrome/\n// Author : Hao Chen\n// Date   : 2015-06-11\n\n\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nbool isPalindrome(string& s, int begin, int end) {\n    for (; begin<end; begin++, end-- ) {\n        if ( s[begin] != s[end] ) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Burst Force - - Time Limit Error\nstring shortestPalindrome_bf(string& s) {\n    int len = s.size();\n    int i;\n    for (i=len-1; i>=0; i--) {\n        if (isPalindrome(s, 0, i)) { \n            i++;\n            break;\n        }\n    }\n    string t = s.substr(i, len-i);\n    reverse(t.begin(), t.end());\n    return t+s;\n}\n\n//Dynamic Programming - Memory Limit Exceeded & Time Limit Error\n//  Using the method of finding longest palindrome\nstring shortestPalindrome_dp(string& s) {\n    int len = s.size();\n    if (len <=1 ) return s;\n\n    //find longest palindrome, see \"Longest Palindromic Substring\"\n    vector< vector<bool> > dp(len, vector<bool>(len, false));\n    for (int i=len-1; i>=0; i--){\n        for(int j=i; j<len; j++){\n            if (i==j || ((j-i==1 || dp[i+1][j-1]) && s[i]==s[j]) ) {\n                dp[i][j] = true;\n            }\n        } \n    }  \n\n    \n    \n    //find the longest palindrome which start from first char.\n    int pos = 0;\n    for (int i=1; i<len; i++)  {\n        if (dp[0][i]) {\n            pos = i+1;\n        } \n    }\n    string t = s.substr(pos, len - pos);\n    reverse(t.begin(), t.end());\n    return t+s;\n    \n}\n\n\n\nstring shortestPalindrome_kmp(string& s) {  \n    int len = s.size();\n    if(len <= 1) return s;\n    \n    string pattern = s + '\\0' + string(s.rbegin(), s.rend());  \n\n    //construct the partial match table\n    vector<int> prefix( pattern.size() );  \n    prefix[0] = 0;\n    for(int i = 1; i < prefix.size(); i++) {  \n        int j = prefix[i-1];  \n        while( j > 0 && pattern[i] != pattern[j] ) {\n            j = prefix[j-1];  \n        }\n        if ( pattern[i] == pattern[j] ) {\n            j++;  \n        }\n        prefix[i] = j;  \n    }  \n\n#ifdef _DEBUG\n    cout << endl;\n    for(int i=0; i<pattern.size(); i++){\n        \n        cout << (pattern[i] ? pattern[i] : '#') << \"  \";\n    }\n    cout << endl;\n    for(int i=0; i<prefix.size(); i++) {\n        cout << prefix[i] << \"  \";\n    }\n    cout << endl;\n    cout << \"-->\" << s.substr(0, prefix.back()) << \" \" << s.substr(prefix.back()) << endl;\n#endif\n\n    int pos = s.size() - prefix.back();  \n    return string(s.rbegin(), s.rbegin() + pos) + s;  \n}  \n\n\nstring shortestPalindrome(string s) {\n    return shortestPalindrome_kmp(s); \n    return shortestPalindrome_dp(s); //Memory Limit Error\n    return shortestPalindrome_bf(s); //Time Limit Error\n}\n#define TEST(s)  cout << s << \" : \" << shortestPalindrome(s) << endl\n\nint main(int argc, char**argv)\n{\n    string s = \"aabba\";\n    if (argc>1){\n        s = argv[1];\n    }\n    TEST(s);\n    TEST(\"a\");\n    TEST(\"ab\");\n    TEST(\"aba\");\n    TEST(\"abab\");\n    TEST(\"aabb\");\n    TEST(\"aacecaaa\");\n    TEST(\"abcd\");\n    TEST(\"aaabcb\");\n    return 0;\n}\n"
  },
  {
    "question_theme": "serializeAndDeserializeBinaryTree",
    "question": "/*************************************************************************************** \n *\n * Serialization is the process of converting a data structure or object into a \n * sequence of bits so that it can be stored in a file or memory buffer, or transmitted \n * across a network connection link to be reconstructed later in the same or another \n * computer environment. \n * \n * Design an algorithm to serialize and deserialize a binary tree. There is no \n * restriction on how your serialization/deserialization algorithm should work. You \n * just need to ensure that a binary tree can be serialized to a string and this string \n * can be deserialized to the original tree structure.\n * \n * For example, you may serialize the following tree\n * \n *     1\n *    / \\\n *   2   3\n *      / \\\n *     4   5\n * \n * as \"[1,2,3,null,null,4,5]\", just the same as how LeetCode OJ serializes a binary \n * tree. You do not necessarily need to follow this format, so please be creative and \n * come up with different approaches yourself.\n * \n * Note: Do not use class member/global/static variables to store states. Your \n * serialize and deserialize algorithms should be stateless.\n * \n * Credits:Special thanks to @Louis1992 for adding this problem and creating all test \n * cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/serialize-and-deserialize-binary-tree/\n// Author : Hao Chen\n// Date   : 2015-11-10\n\n\n\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\n\nclass Codec {\n    \npublic:\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        return serialize02(root);\n        return serialize01(root);\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        return deserialize02(data);\n        return deserialize01(data);\n    }      \n    \n\n\npublic:\n    // Encodes a tree to a single string.\n    string serialize01(TreeNode* root) {\n         string result;\n         vector<TreeNode*> v;\n         serializeHelper(root, v);\n         for(int i=0; i<v.size(); i++){\n             result = result + (v[i]==NULL ? \"#\" : to_string(v[i]->val)) + \" \";\n         }\n         return result;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize01(string data) {\n        vector<TreeNode*> v;\n        split(data, ' ', v);\n\n        int index = 0;\n        return deserializeHelper(v, index);\n\n    }    \n\nprivate:\n\n    void serializeHelper(TreeNode* root, vector<TreeNode*>& v) {\n        if (root==NULL) {\n            v.push_back(NULL);\n        }else{\n            v.push_back(root);\n            serializeHelper(root->left, v);\n            serializeHelper(root->right, v);\n        }\n    }\n   \n\n    TreeNode* deserializeHelper(vector<TreeNode*> &v, int& index) {\n\n        if (index >= v.size() ) return NULL;\n\n        TreeNode* root = v[index++];\n        if (root) {\n            root->left = deserializeHelper(v, index);\n            root->right = deserializeHelper(v, index);\n        }\n        return root;\n    }\n\n\n   void split(const string &s, char delim, vector<TreeNode*> &elems) {\n        stringstream ss(s);\n        string item;\n        while (getline(ss, item, delim)) {\n            TreeNode* node =  (item==\"#\" ? NULL : new TreeNode( stoi(item)) );\n            elems.push_back(node);\n        }\n\n    }\n    \n\n\n\npublic:\n    // Encodes a tree to a single string.\n    string serialize02(TreeNode* root) {\n        ostringstream out;\n        serialize(root, out);\n        return out.str();\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize02(string data) {\n        istringstream in(data);\n        return deserialize(in);\n    } \n    \nprivate:\n   void serialize(TreeNode* root, ostringstream& out) {\n        if (root==NULL) {\n            out << \"# \";\n            return;\n        }\n        out << root->val << \" \";\n        serialize(root->left, out);\n        serialize(root->right, out);\n    }\n\n    TreeNode* deserialize(istringstream& in) {\n        string val;\n        in >> val;\n        if (val == \"#\" || val.empty() ) return NULL;\n\n        TreeNode* node = new TreeNode(stoi(val));\n        node->left = deserialize(in);\n        node->right = deserialize(in);\n        return node;\n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec;\n// codec.deserialize(codec.serialize(root));\n\n\nint main(int argc, char** argv) \n{\n    string s = \"1 2 3 # # 4 5\";\n    if (argc>1){\n        s = argv[1];\n    }\n    cout << s << endl;\n    Codec codec;\n    cout << codec.serialize(codec.deserialize(s)) << endl;\n    \n    return 0;\n    \n}\n"
  },
  {
    "question_theme": "containerWithMostWater",
    "question": "/********************************************************************************** \n* \n* Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). \n* n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). \n* \n* Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n* \n* Note: You may not slant the container.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/container-with-most-water/\n// Author : Hao Chen\n// Date   : 2014-06-22\n\n\n\nclass Solution {\npublic:\n    int maxArea(vector<int> &height) {\n\n        int maxArea = 0;\n        // two pointers scan from two sides to middle\n        int left = 0; \n        int right = height.size()-1;\n\n        int area; \n        while ( left < right ){\n            // calculate the area\n            area = (right - left) * ( height[left] < height[right] ? height[left] : height[right]);\n            // tracking the maxium area\n            maxArea = area > maxArea ? area : maxArea;\n            // because the area is decided by the shorter edge\n            // so we increase the area is to increase the shorter edge\n            //\n            //     height[left] < height[right] ? left++ : right-- ;\n            //\n            // However, the above code could cause the unnecessary `area` cacluation\n            // We can do some improvement as below:\n            if (height[left] < height[right]) {\n                do {\n                    left++;\n                } while (left < right && height[left-1] >= height[left]);\n            } else {\n                do {\n                    right--;\n                } while (right > left && height[right+1] >= height[right]);\n            }\n        }\n        \n        return maxArea;\n    }\n};\n"
  },
  {
    "question_theme": "repeatedDNASequences",
    "question": "/********************************************************************************** \n * \n * All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, \n *\n * For example: \"ACGAATTCCG\". \n * When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.\n * \n * Write a function to find all the 10-letter-long sequences (substrings) that \n * occur more than once in a DNA molecule.\n * \n * For example,\n * \n * Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\n * \n * Return:\n * [\"AAAAACCCCC\", \"CCCCCAAAAA\"].\n * \n *               \n **********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/repeated-dna-sequences/\n// Author : Hao Chen\n// Date   : 2015-02-09\n\n\n#include <stdlib.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\nconst int MAX_LEN = 10;\n\nint ACGT2Int(char ch){\n    switch(ch){\n        case 'A': return 0;\n        case 'C': return 1;\n        case 'G': return 2;\n        case 'T': return 3;\n    }\n    return -1;\n}\nint DNASeqs2Int(string &s, int begin){\n    int result=0;\n    for(int i=0; i<MAX_LEN; i++){\n        result = result*4 + ACGT2Int(s[i+begin]);\n    }\n    return result;\n}\n\nvector<string> findRepeatedDnaSequences_01(string s) {\n    unordered_map<int, int> stat;\n\n    vector<string> result;\n\n    for( int i=0; i+MAX_LEN<=s.size(); i++ ){\n\n        int hash_code = DNASeqs2Int(s, i);\n        stat[hash_code]++;\n        if (stat[hash_code]==2){\n            result.push_back(s.substr(i, MAX_LEN));\n        }\n    }\n\n    return result;        \n}\n\nvector<string> findRepeatedDnaSequences_02(string s) {\n    unordered_map<size_t, int> stat;\n    hash<string> hash_func;\n\n    vector<string> result;\n\n    for( int i=0; i+MAX_LEN<=s.size(); i++ ){\n        string word = s.substr(i, MAX_LEN);\n        size_t hash_code = hash_func(word);\n        stat[hash_code]++;\n        if (stat[hash_code]==2){\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\nvector<string> findRepeatedDnaSequences(string s) {\n    srand(time(0));\n    if (random()%2){\n        return findRepeatedDnaSequences_01(s);\n    }\n    return findRepeatedDnaSequences_02(s);\n}\n\nvoid printVector( vector<string> v ) {\n    cout << \"[ \" ;\n    for(int i=0; i<v.size(); i++ ){\n        cout << v[i] << (i<v.size()-1 ? \", \" : \"\");\n    }\n    cout << \" ]\" << endl;\n}\n\nint main(int argc, char** argv)\n{\n    string s =  \"GAGAGAGAGAGAG\" ;\n    if (argc > 1){\n        s = argv[1];\n    }\n    printVector(findRepeatedDnaSequences(s));\n}\n"
  },
  {
    "question_theme": "grayCode",
    "question": "/********************************************************************************** \n* \n* The gray code is a binary numeral system where two successive values differ in only one bit.\n* \n* Given a non-negative integer n representing the total number of bits in the code, \n* print the sequence of gray code. A gray code sequence must begin with 0.\n* \n* For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:\n* \n* 00 - 0\n* 01 - 1\n* 11 - 3\n* 10 - 2\n* \n* Note:\n* For a given n, a gray code sequence is not uniquely defined.\n* \n* For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.\n* \n* For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/gray-code/\n// Author : Hao Chen\n// Date   : 2014-06-20\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nvector<int> grayCode01(int n) {\n    vector<int> v;\n    //n = 1<<n;\n    \n    int x =0;   \n    v.push_back(x); \n    for(int i=0; i<n; i++){\n        int len = v.size();\n        for (int j=0; j<len; j++){\n            x = v[j]<<1;\n            if (j%2==0){\n                v.push_back(x);\n                v.push_back(x+1);\n            }else{\n                v.push_back(x+1);\n                v.push_back(x);\n            }\n        }\n        v.erase(v.begin(), v.begin()+len);\n    }\n     \n    return v;\n}\n\n\nvector<int> grayCode02(int n) {\n    vector<int> ret;   \n    int size = 1 << n;   \n    for(int i = 0; i < size; ++i) {\n        ret.push_back((i >> 1)^i);   \n    }\n    return ret;   \n}\n\n//random invoker\nvector<int> grayCode(int n) {\n    srand(time(0));\n    if (rand()%2){\n        return grayCode01(n);\n    }\n    return grayCode02(n);\n}\n\nvoid printBits(int n, int len){\n    for(int i=len-1; i>=0; i--) {\n        if (n & (1<<i)) {\n            printf(\"1\");\n        }else{\n            printf(\"0\");\n        }\n    }\n}\n\nvoid printVector(vector<int>& v, int bit_len)\n{\n    vector<int>::iterator it;\n\n    for(it=v.begin(); it!=v.end(); ++it){\n        //bitset<bit_len> bin(*it);\n        printBits(*it, bit_len);\n        cout <<  \" \";\n        //cout << *it <<  \" \";\n    }\n    cout << endl;\n}\n\nint main(int argc, char** argv)\n{\n    int n = 2;\n    if (argc>1){\n        n = atoi(argv[1]); \n    }\n    vector<int> v = grayCode(n);\n    printVector(v, n);\n    return 0;\n}\n"
  },
  {
    "question_theme": "mergeIntervals",
    "question": "/********************************************************************************** \n* \n* Given a collection of intervals, merge all overlapping intervals.\n* \n* For example,\n* Given [1,3],[2,6],[8,10],[15,18],\n* return [1,6],[8,10],[15,18].\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/merge-intervals/\n// Author : Hao Chen\n// Date   : 2014-08-26\n\n\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Interval {\n    int start;\n    int end;\n    Interval() : start(0), end(0) {}\n    Interval(int s, int e) : start(s), end(e) {}\n};\n\n//Two factos sorting [start:end]\nbool compare(const Interval& lhs, const Interval& rhs){\n    return (lhs.start==rhs.start) ? lhs.end < rhs.end : lhs.start < rhs.start;\n}\n\nvector<Interval> merge(vector<Interval> &intervals) {\n\n    vector<Interval> result;\n\n    if (intervals.size() <= 0) return result;\n    //sort the inervals. Note: using the customized comparing function.\n    sort(intervals.begin(), intervals.end(), compare);\n    for(int i=0; i<intervals.size(); i++) { \n        int size = result.size();\n        // if the current intervals[i] is overlapped with previous interval.\n        // merge them together\n        if( size>0 && result[size-1].end >= intervals[i].start) {\n            result[size-1].end = max(result[size-1].end, intervals[i].end); \n        }else{\n            result.push_back(intervals[i]);\n        }\n    }\n    \n    return result;\n}\n\n\nint main(int argc, char**argv)\n{\n    Interval i1(1,4);\n    Interval i2(0,2);\n    Interval i3(3,5);\n    Interval i4(15,18);\n    vector<Interval> intervals;\n    intervals.push_back(i1);\n    intervals.push_back(i2);\n    intervals.push_back(i3);\n    intervals.push_back(i4);\n    \n    vector<Interval> r = merge(intervals);\n    \n    for(int i=0; i<r.size(); i++){\n        cout << \"[ \" << r[i].start << \", \" << r[i].end << \" ] \";\n    }\n    cout <<endl;\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "restoreIPAddresses",
    "question": "/********************************************************************************** \n* \n* Given a string containing only digits, restore it by returning all possible valid IP address combinations.\n* \n* For example:\n* Given \"25525511135\",\n* \n* return [\"255.255.11.135\", \"255.255.111.35\"]. (Order does not matter)\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/restore-ip-addresses/\n// Author : Hao Chen\n// Date   : 2014-08-26\n\n\n\n#include <stdlib.h>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid restoreIpAddressesHelper(string& s, int start, int partNum, string ip, vector<string>& result);\n\nvector<string> restoreIpAddresses(string s) {\n    vector<string> result;\n    string ip;\n    restoreIpAddressesHelper(s, 0, 0, ip, result);\n    return result;\n}\n\nvoid restoreIpAddressesHelper(string& s, int start, int partNum, string ip, vector<string>& result) {\n\n    int len = s.size();\n    if ( len - start < 4-partNum  || len - start > (4-partNum)*3 ) {\n        return;\n    }\n\n    if (partNum == 4 && start == len){\n        ip.erase(ip.end()-1, ip.end());\n        result.push_back(ip);\n        return;\n    }\n\n    int num = 0;\n    for (int i=start; i<start+3; i++){\n        num = num*10 + s[i]-'0';\n        if (num<256){\n            ip+=s[i];\n            restoreIpAddressesHelper(s, i+1, partNum+1, ip+'.', result);\n        }         \n        //0.0.0.0 valid, but 0.1.010.01 is not\n        if (num == 0) {\n            break;\n        }\n    }\n       \n}\n\n\nint main(int argc, char**argv)\n{\n    string s = \"25525511135\";\n    if (argc>1){\n        s = argv[1];\n    }\n\n    vector<string> result = restoreIpAddresses(s);\n\n    cout << s << endl;\n    for(int i=0; i<result.size(); i++){\n        cout << '\\t' << result[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "question_theme": "mergeKSortedLists",
    "question": "/********************************************************************************** \n* \n* Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/merge-k-sorted-lists/\n// Author : Hao Chen\n// Date   : 2014-07-06\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode *mergeTwoLists(ListNode* head1, ListNode* head2);\nListNode *mergeTwoLists01(ListNode* head1, ListNode* head2);\nListNode *mergeTwoLists02(ListNode* head1, ListNode* head2);\n\nListNode *mergeKLists(vector<ListNode *> &lists) {\n    ListNode *p, *p1, *p2;\n    while(lists.size()>1){\n        p1 = lists.back();    \n        lists.pop_back();\n        p2 = lists.back();    \n        lists.pop_back();\n        p = mergeTwoLists(p1, p2);\n        lists.insert(lists.begin(), p);\n    }\n    return lists.size()==1 ? lists[0] : NULL;\n\n    \n    \n}\n\nstatic int n=0;\nListNode *mergeTwoLists(ListNode* head1, ListNode* head2){\n    if (n){\n        //cout << \"------ method 01 ------\" <<endl;\n        return mergeTwoLists01(head1, head2);\n    }\n    //cout << \"------ method 02 ------\" <<endl;\n    return mergeTwoLists02(head1, head2);\n}\n\n\n\n\n//#define INT_MAX   2147483647\n//#define INT_MIN   (-INT_MAX - 1)\n\nListNode *mergeTwoLists01(ListNode* head1, ListNode* head2){\n    ListNode *p1 = head1,  *p2=head2;\n    static ListNode dummy(0);\n\n    dummy.next = p1;\n    ListNode *prev = &dummy;\n\n    while(p1 && p2){\n        if(p1->val < p2->val){\n            prev = p1;\n            p1 = p1->next;\n        }else{\n            prev->next = p2;\n            p2 = p2->next;\n            prev = prev->next;\n            prev->next = p1;\n        }\n    }\n    if (p2){\n        prev->next = p2;\n    }\n\n    return dummy.next;\n}\n\n\n\n\n\n\nvoid TakeOutNode(ListNode*& head, ListNode*& tail, ListNode*& p);\n\nListNode *mergeTwoLists02(ListNode* head1, ListNode* head2) {\n    ListNode *p1 = head1,  *p2=head2;\n\n    ListNode *pHead = NULL, *pTail=NULL;\n    while(p1 && p2){\n        if(p1->val < p2->val){\n            TakeOutNode(pHead, pTail, p1);\n        }else{\n            TakeOutNode(pHead, pTail, p2);\n        }\n    }\n\n    ListNode *p=NULL;\n    if (p1){\n        p = p1;\n    }else if (p2){\n        p = p2;\n    }\n    if (pHead==NULL){\n        return p;\n    }\n    pTail->next = p;\n    return pHead;\n}\n\nvoid TakeOutNode(ListNode*& head, ListNode*& tail, ListNode*& p){\n    ListNode *pNext = p->next;\n    if (head==NULL){\n        head = tail = p;\n    }else{\n        tail->next = p;\n        tail = p;\n    }\n    p->next = NULL;\n    p = pNext;\n}\n\nvoid printList(ListNode* h)\n{\n    while(h!=NULL){\n        printf(\"%d \", h->val);\n        h = h->next;\n    }\n    printf(\"\\n\");\n}\n\nListNode* createList(int a[], int n)\n{\n    ListNode *head=NULL, *p=NULL;\n    for(int i=0; i<n; i++){\n        if (head == NULL){\n            head = p = new ListNode(a[i]);\n        }else{\n            p->next = new ListNode(a[i]);\n            p = p->next;\n        }\n    }\n    return head;\n}\n\n\nint main(int argc, char**argv)\n{\n    srand(time(0));\n    if (argc>1){\n        n = atoi(argv[1]) % 2;\n    }\n\n    int a[] = {1,3,5,6,7,10};\n    int b[] = {0,4,6,8,9,11,20,30,40};\n    ListNode* p1 = createList(a, sizeof(a)/sizeof(int));\n    ListNode* p2 = createList(b, sizeof(b)/sizeof(int));\n\n    printList( mergeTwoLists(p1,p2) );\n    //mergeTwoLists(p1,p2) ;\n\n\n    vector<ListNode*> v;\n    for(int i=0; i<10240; i++) {\n        v.push_back(new ListNode(random()%100));\n    }\n    printList( mergeKLists(v) );\n    //mergeKLists(v);\n\n\n    cout << \"method \" << n+1 << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "pow",
    "question": "/********************************************************************************** \n* \n* Implement pow(x, n).\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/powx-n/\n// Author : Hao Chen\n// Date   : 2014-06-25\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n\ndouble pow(double x, int n) {\n\n    bool sign = false;\n    unsigned int exp = n;\n    if(n<0){\n        exp = -n;\n        sign = true;\n    }\n    double result = 1.0;\n    while (exp) {\n        if (exp & 1){\n            result *= x;\n        }\n        exp >>= 1;\n        x *= x;\n    }\n\n    return sign ? 1/result : result;\n\n}\n\nint main(int argc, char** argv){\n    double x=2.0;\n    int n = 3;\n    if (argc==3){\n        x = atof(argv[1]);\n        n = atoi(argv[2]);\n    }\n    printf(\"%f\\n\", pow(x, n));\n    return 0;\n}\n"
  },
  {
    "question_theme": "validPalindrome",
    "question": "/********************************************************************************** \n* \n* Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\n* \n* For example,\n* \"A man, a plan, a canal: Panama\" is a palindrome.\n* \"race a car\" is not a palindrome.\n* \n* Note:\n* Have you consider that the string might be empty? This is a good question to ask during an interview.\n* \n* For the purpose of this problem, we define empty string as valid palindrome.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/valid-palindrome/\n// Author : Hao Chen\n// Date   : 2014-06-26\n\n\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        s = removeNoise(s);\n        for(int i=0; i<s.size()/2; i++){\n            if (s[i]!= s[s.size()-i-1]){\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    string removeNoise(string& s){\n        string d;\n        for(int i=0; i<s.size(); i++){\n            if(::isalpha(s[i]) || ::isdigit(s[i])){\n                d.push_back(::tolower(s[i]));\n            }\n        }\n        return d;\n    }\n};\n"
  },
  {
    "question_theme": "longestPalindromicSubstring",
    "question": "/********************************************************************************** \n* \n* Given a string S, find the longest palindromic substring in S. \n* You may assume that the maximum length of S is 1000, \n* and there exists one unique longest palindromic substring.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/longest-palindromic-substring/\n// Author : Hao Chen\n// Date   : 2014-07-17\n\n\n\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstring findPalindrome(string s, int left, int right)\n{\n    int n = s.size();\n    int l = left;\n    int r = right;\n    while (left>=0 && right<=n-1 && s[left] == s[right]) {\n        left--;\n        right++;\n    }\n    return s.substr(left+1, right-left-1);\n}\n\n\n// This is the common solution.\n// Actuatlly it's faster than DP solution under Leetcode's test\n// the below optimized DP solution need 700ms+, this needs around 250ms.\nstring longestPalindrome_recursive_way(string s) {\n    int n = s.size();\n    if (n<=1) return s;\n\n    string longest;\n    \n    string str;\n    for (int i=0; i<n-1; i++) {\n        str = findPalindrome(s, i, i);\n        if (str.size() > longest.size()){\n            longest = str;\n        } \n        str = findPalindrome(s, i, i+1);\n        if (str.size() > longest.size()){\n            longest = str;\n        } \n    }\n\n    return longest; \n}\n\n//================================================================================\n\n\nvoid findPalindrome(string s, int left, int right, int& start, int& len)\n{\n    int n = s.size();\n    int l = left;\n    int r = right;\n    while (left>=0 && right<=n-1 && s[left] == s[right]) {\n        left--;\n        right++;\n    }\n    if (right-left-1 > len){\n        len = right-left-1;\n        start = left+1;\n    }\n}\n\n//The following solution is better than previous solution.\n//Because it remove the sub-string return in findPalindrome().\nstring longestPalindrome_recursive_way2(string s) {\n    int n = s.size();\n    if (n<=1) return s;\n\n    int start=0, len=0; \n    string longest;\n\n    string str;\n    for (int i=0; i<n-1; i++) {\n        findPalindrome(s, i, i, start, len);\n        findPalindrome(s, i, i+1, start, len);\n    }\n\n    return s.substr(start, len);\n}\n\n//================================================================================\n\n// Time/Memory Limit Exceeded\nstring longestPalindrome_dp_way(string s) {\n\n    string longest;\n\n    int n = s.size();\n    if (n<=1) return s;\n    \n    //Construct a matrix, and consdier matrix[i][j] as s[i] -> s[j] is Palindrome or not.\n\n    //using char or int could cause the `Memory Limit Error`\n    //vector< vector<char> > matrix (n, vector<char>(n));\n\n    //using bool type could cause the `Time Limit Error`\n    vector< vector<bool> > matrix (n, vector<bool>(n));\n\n    // Dynamic Programming \n    //   1) if i == j, then matrix[i][j] = true;\n    //   2) if i != j, then matrix[i][j] = (s[i]==s[j] && matrix[i+1][j-1])\n    for (int i=n-1; i>=0; i--){\n        for (int j=i; j<n; j++){\n            // The following if statement can be broken to \n            //   1) i==j, matrix[i][j] = true\n            //   2) the length from i to j is 2 or 3, then, check s[i] == s[j]\n            //   3) the length from i to j > 3, then, check s[i]==s[j] && matrix[i+1][j-1]\n            if ( i==j || (s[i]==s[j] && (j-i<2 || matrix[i+1][j-1]) ) )  {\n                matrix[i][j] = true;\n                if (longest.size() < j-i+1){\n                    longest = s.substr(i, j-i+1);\n                }\n            }\n        }\n    }\n\n    return longest;\n}\n\n// Optimized DP soltuion can be accepted by LeetCode.\nstring longestPalindrome_dp_opt_way(string s) {\n\n    int n = s.size();\n    if (n<=1) return s;\n\n    //Construct a matrix, and consdier matrix[j][i] as s[i] -> s[j] is Palindrome or not.\n    //                                 ------^^^^^^\n    //                                 NOTE: it's [j][i] not [i][j]\n\n    //Using vector  could cause the `Time Limit Error`\n    //So, use the native array\n    bool **matrix  = (bool**)malloc(n*sizeof(bool*));\n    int start=0, len=0;\n    // Dynamic Programming\n    //   1) if i == j, then matrix[i][j] = true;\n    //   2) if i != j, then matrix[i][j] = (s[i]==s[j] && matrix[i-1][j+1])\n    for (int i=0; i<n; i++){\n        matrix[i] = (bool*)malloc((i+1)*sizeof(bool));\n        memset(matrix[i], false, (i+1)*sizeof(bool));\n        matrix[i][i]=true;\n        for (int j=0; j<=i; j++){\n            // The following if statement can be broken to\n            //   1) j==i, matrix[i][j] = true\n            //   2) the length from j to i is 2 or 3, then, check s[i] == s[j]\n            //   3) the length from j to i > 3, then, check s[i]==s[j] && matrix[i-1][j+1]\n            if ( i==j || (s[j]==s[i] && (i-j<2 || matrix[i-1][j+1]) ) )  {\n                matrix[i][j] = true;\n                if (len < i-j+1){\n                    start = j;\n                    len = i-j+1;\n                }\n            }\n        }\n    }\n\n    for (int i=0; i<n; i++) { \n        free (matrix[i]);\n    }\n    free(matrix);\n\n    return s.substr(start, len);\n}\n\n\nstring longestPalindrome(string s) {\n    return longestPalindrome_dp_way(s);\n    return longestPalindrome_dp_opt_way(s);\n    return longestPalindrome_recursive_way2(s);\n    return longestPalindrome_recursive_way(s);\n}\n\nint main(int argc, char**argv)\n{\n    string s = \"abacdfgdcaba\";\n    if (argc > 1){\n        s = argv[1];\n    }\n    cout <<  s << \" : \" << longestPalindrome(s) << endl;\n\n    s = \"321012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210123210012321001232100123210123\";\n    cout <<  s << \" : \" << longestPalindrome(s) << endl;\n \n    //\"illi\"\n    s = \"iptmykvjanwiihepqhzupneckpzomgvzmyoybzfynybpfybngttozprjbupciuinpzryritfmyxyppxigitnemanreexcpwscvcwddnfjswgprabdggbgcillisyoskdodzlpbltefiz\";\n    cout <<  s << \" : \" << longestPalindrome(s) << endl;\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "slidingWindowMaximum",
    "question": "/********************************************************************************** \n * \n * Given an array nums, there is a sliding window of size k which is moving from the \n * very left of the array to the very right. You can only see the k numbers in the \n * window. Each time the sliding window moves right by one position.\n * \n * For example,\n * Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.\n *\n * Window position                Max\n * ---------------               -----\n * [1  3  -1] -3  5  3  6  7       3\n *  1 [3  -1  -3] 5  3  6  7       3\n *  1  3 [-1  -3  5] 3  6  7       5\n *  1  3  -1 [-3  5  3] 6  7       5\n *  1  3  -1  -3 [5  3  6] 7       6\n *  1  3  -1  -3  5 [3  6  7]      7\n * \n * Therefore, return the max sliding window as [3,3,5,5,6,7].\n * \n * Note: \n * You may assume k is always valid, ie: 1 \u2264 k \u2264 input array's size for non-empty \n * array.\n * \n * Follow up:\n * Could you solve it in linear time?\n * \n *   How about using a data structure such as deque (double-ended queue)?\n *   The queue size need not be the same as the window\u2019s size.\n *   Remove redundant elements and the queue should store only elements that need to be \n * considered.\n * \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/sliding-window-maximum/\n// Author : Hao Chen\n// Date   : 2015-07-19\n\n\n#include <iostream>\n#include <vector>\n#include <deque>\n#include <set>\nusing namespace std;\n\n//O(nlog(k)\nvector<int> maxSlidingWindow02(vector<int>& nums, int k) {\n    vector<int> result;\n\n    //using multiset for collecting the window data (O(nlog(k) time complexity)\n    multiset<int> w;\n\n    for(int i=0; i<nums.size(); i++) {\n        //remove the left item which leaves window \n        if (i >= k) {\n            w.erase(w.find(nums[i-k]));\n        }\n        //insert the right itme which enter the window\n        w.insert(nums[i]);\n        if (i>=k-1) {\n            result.push_back(*w.rbegin());\n        }\n    }\n\n    return result;\n}\n\n//O(n)\nvector<int> maxSlidingWindow01(vector<int>& nums, int k) {\n    vector<int> result;\n\n    //using multiset for collecting the window data (O(nlog(k) time complexity)\n    deque<int> q;\n\n    for(int i=0; i<nums.size(); i++) {\n        //remove the left item which leaves window \n        if (!q.empty() && q.front() == i - k) {\n            q.pop_front();\n        }\n        //remove all num which less than current number from the back one by one\n        while (!q.empty() && nums[q.back()] < nums[i]) {\n            q.pop_back();\n        }\n        //insert the right itme which enter the window\n        q.push_back(i);\n        if (i>=k-1) {\n            result.push_back(nums[q.front()]);\n        }\n    }\n\n    return result;\n}\n\nvector<int> maxSlidingWindow(vector<int>& nums, int k) {\n    return maxSlidingWindow01(nums, k);\n    return maxSlidingWindow02(nums, k);\n}\n\nvoid printVector( vector<int>& v ) {\n    cout << \"{ \";\n    for(int i=0; i<v.size(); i++) {\n        cout << v[i] << (i==v.size() ? \" \": \", \");\n    }\n    cout << \"}\" << endl;\n}\n\nint main(int argc, char** argv) \n{\n    int a[] = {1,3,-1,-3,5,3,6,7};\n    int k = 3;\n    vector<int> nums(a, a+sizeof(a)/sizeof(a[0]));\n    printVector(nums);\n    vector<int> result = maxSlidingWindow(nums, k);\n    printVector(result);\n}\n"
  },
  {
    "question_theme": "textJustification",
    "question": "/********************************************************************************** \n* \n* Given an array of words and a length L, format the text such that each line has \n* exactly L characters and is fully (left and right) justified.\n*  \n* \n* You should pack your words in a greedy approach; that is, pack as many words as you can in each line. \n* Pad extra spaces ' ' when necessary so that each line has exactly L characters.\n* \n* Extra spaces between words should be distributed as evenly as possible. \n* If the number of spaces on a line do not divide evenly between words, \n* the empty slots on the left will be assigned more spaces than the slots on the right.\n* \n* For the last line of text, it should be left justified and no extra space is inserted between words.\n* \n* For example,\n* words: [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\n* L: 16.\n* \n* Return the formatted lines as:\n* \n* [\n*    \"This    is    an\",\n*    \"example  of text\",\n*    \"justification.  \"\n* ]\n* \n* Note: Each word is guaranteed not to exceed L in length.\n* \n* \n* Corner Cases:\n* \n* A line other than the last line might contain only one word. What should you do in this case?\n* In this case, that line should be left-justified.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/text-justification/\n// Author : Hao Chen\n// Date   : 2014-10-11\n\n\n\n#include <math.h>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n\nvector<string> fullJustify(vector<string> &words, int L) {\n    vector<string> result;\n    \n    int len=0;\n    int start = 0;\n    int end = 0;\n    double space =0;\n    bool lastLine = false;\n    for (int i=0; i<words.size(); i++){\n        len += words[i].size();\n        if (len + i - start > L || i == words.size()-1) {\n            //remove the last one\n            if (len + i - start > L) {  \n                len -= words[i].size();\n                end = i-1;\n                lastLine = false;\n            }else{\n                end = i;\n                lastLine = true;\n            }\n            //calculate the space number\n            space = L - len;\n            int mspace;\n            int extra;\n            if (lastLine){\n                mspace = 1;\n                extra = 0;\n            } else {\n                mspace = floor(space/(end-start));\n                extra = space - mspace * (end-start);\n            }\n\n            string line = words[start];\n            for (int j=start+1; j<=end; j++) {\n                for(int k=0; k<mspace && space>0; k++, space--) {\n                    line += \" \";\n                }   \n                if (j-start-1 < extra){\n                    line += \" \";\n                    space--;\n                } \n                line += words[j];\n            }\n            //add the rest space\n            if (space>0){\n                for(; space>0; space--) {\n                    line += \" \";\n                }\n            }\n            result.push_back(line);\n            start = i;\n            i = end;\n            len = 0;\n        } \n    }\n\n    return result;\n}\n\n\nvoid printVector(vector<string> &words, bool newline=false) {\n    for(int i=0; i<words.size(); i++) {\n        cout << \"\\\"\" << words[i] << \"\\\", \";\n        if (newline) cout << endl; \n    }\n    cout << endl;\n}\n\nvoid test(const char* A[], int len, int L) {\n    vector<string> words(A, A+len);\n\n    printVector(words);\n\n    vector<string> result = fullJustify(words, L);\n    cout << endl;\n    printVector(result, true);\n\n}\n\n#define TEST(a, L) test(a, sizeof(a)/sizeof(const char*), L)\n\nint main(int argc, char** argv)\n{\n    const char* w1[]={\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"};\n    TEST(w1, 16);    \n\n    const char* w2[] = {\"What\",\"must\",\"be\",\"shall\",\"be.\"}; \n    TEST(w2, 12);\n    \n    const char* w3[] = {\"My\",\"momma\",\"always\",\"said,\",\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"};\n    TEST(w3, 20);\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "3SumClosest",
    "question": "/********************************************************************************** \n* \n* Given an array S of n integers, find three integers in S such that the sum is \n* closest to a given number, target. Return the sum of the three integers. \n* You may assume that each input would have exactly one solution.\n* \n*     For example, given array S = {-1 2 1 -4}, and target = 1.\n* \n*     The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/3sum-closest/\n// Author : Hao Chen\n// Date   : 2014-07-03\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n#define INT_MAX 2147483647\n//solution:  http://en.wikipedia.org/wiki/3SUM\n//the idea as blow:\n//  1) sort the array.\n//  2) take the element one by one, calculate the two numbers in reset array.\n//\n//notes: be careful the duplication number.\n//\n// for example:\n//    [-4,-1,-1,1,2]    target=1\n// \n//    take -4, can cacluate the \"two number problem\" of the reset array [-1,-1,1,2] while target=5\n//    [(-4),-1,-1,1,2]  target=5  distance=4\n//           ^      ^ \n//    because the -1+2 = 1 which < 5, then move the `low` pointer(skip the duplication)\n//    [(-4),-1,-1,1,2]  target=5  distance=2\n//                ^ ^ \n//    take -1(skip the duplication), can cacluate the \"two number problem\" of the reset array [1,2] while target=2\n//    [-4,-1,(-1),1,2]  target=2  distance=1\n//                ^ ^ \nint threeSumClosest(vector<int> &num, int target) {\n    //sort the array\n    sort(num.begin(), num.end());\n\n    int n = num.size();\n    int distance = INT_MAX;\n    int result;\n\n    for (int i=0; i<n-2; i++) {\n        //skip the duplication\n        if (i>0 && num[i-1]==num[i]) continue;\n        int a = num[i];\n        int low = i+1;\n        int high = n-1;\n        //convert the 3sum to 2sum problem\n        while ( low < high ) {\n            int b = num[low];\n            int c = num[high];\n            int sum = a+b+c;\n            if (sum - target == 0) {\n                //got the final soultion\n                return target;\n            } else {\n\n                //tracking the minmal distance\n                if (abs(sum-target) < distance ) {\n                    distance = abs(sum - target);\n                    result = sum;\n                }\n\n                if (sum -target> 0) {\n                    //skip the duplication\n                    while(high>0 && num[high]==num[high-1]) high--;\n                    //move the `high` pointer\n                    high--;\n                } else {\n                    //skip the duplication\n                    while(low<n && num[low]==num[low+1]) low++;\n                    //move the `low` pointer\n                    low++;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n\n\n\nint main()\n{\n    int a[] = {-1, 2, 1, -4};\n    vector<int> n(a, a+sizeof(a)/sizeof(int));\n    int target = 1;\n    cout << threeSumClosest(n, target) << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "combinations",
    "question": "/********************************************************************************** \n* \n* Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.\n* \n* For example,\n* If n = 4 and k = 2, a solution is:\n* \n* [\n*   [2,4],\n*   [3,4],\n*   [2,3],\n*   [1,2],\n*   [1,3],\n*   [1,4],\n* ]\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/combinations/\n// Author : Hao Chen\n// Date   : 2014-07-03\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid getCombination(int n, int k, vector<int>& solution, vector< vector<int> >& result );\nvector<vector<int> > combine1(int n, int k); \nvector<vector<int> > combine2(int n, int k);\n\nvector<vector<int> > combine(int n, int k) {\n    if (random()%2){\n        cout << \"recusive method!\" << endl;\n        return combine1(n, k);\n    }\n    cout << \"non-recusive method!\" << endl;\n    return combine2(n, k);\n}\n\nvector<vector<int> > combine1(int n, int k) {\n    vector<vector<int> > result;\n    vector<int> solution;\n    getCombination(n, k, solution, result);\n    return result;\n}\n\nvoid getCombination(int n, int k, vector<int>& solution, vector< vector<int> >& result ){\n    if (k==0){\n        //sort to meet LeetCode requirement\n        vector<int> v = solution;\n        sort(v.begin(), v.end());\n        result.push_back(v);\n        return;\n    }\n    for(int i=n; i>0; i--){\n        solution.push_back(i);\n        getCombination(i-1, k-1, solution, result);\n        solution.pop_back();\n    }\n}\n\nvector<vector<int> > combine2(int n, int k) {\n    \n    vector<vector<int> > result;\n    vector<int> d;\n    for (int i=0; i<n; i++){\n        d.push_back( (i<k) ? 1 : 0 );\n    }\n\n    //1) from the left, find the [1,0] pattern, change it to [0,1]\n    //2) move all of the 1 before the pattern to the most left side\n    //3) check all of 1 move to the right\n    while(1){\n        vector<int> v;\n        for(int x=0; x<n; x++){\n            if (d[x]) v.push_back(x+1);\n        }\n        result.push_back(v);\n        //step 1), find [1,0] pattern\n        int i;\n        bool found = false;\n        int ones =0;\n        for(i=0; i<n-1; i++){\n            \n            if (d[i]==1 && d[i+1]==0){\n                d[i]=0; d[i+1]=1;\n                found = true;\n                //step 2) move all of right 1 to the most left side\n                for (int j=0; j<i; j++){\n                    d[j]=( ones > 0 ) ? 1 : 0;\n                    ones--;\n                }\n                break; \n            } \n            if (d[i]==1) ones++;\n        }\n        if (!found){\n            break;\n        }\n        \n    }\n    return result;\n    \n}\n\n\n\n\nvoid printResult(vector<vector<int> >& result)\n{\n    for(int i=0; i<result.size(); i++){\n        cout << \"{\";\n        for(int j=0; j<result[i].size(); j++){\n            cout << \" \" << result[i][j];\n        }\n        cout << \" }\" <<endl;\n    }\n}\n\nint main(int argc, char** argv)\n{\n    srand(time(NULL));\n\n    int n = 4, k =2;\n    if (argc>2){\n        n = atoi(argv[1]);\n        k = atoi(argv[2]);\n    }\n    vector<vector<int> > r = combine(n, k);\n    printResult(r);\n}\n"
  },
  {
    "question_theme": "reverseString",
    "question": "/*************************************************************************************** \n *\n * Write a function that takes a string as input and returns the string reversed.\n * \n * Example:\n * Given s = \"hello\", return \"olleh\".\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/reverse-string/\n// Author : Hao Chen\n// Date   : 2016-05-29\n\n\n\nclass Solution {\npublic:\n    string reverseString(string s) {\n        int len = s.size();\n        for (int i=0; i<len/2; i++) {\n           char ch = s[i];\n           s[i] = s[len-i-1];\n           s[len-i-1] = ch;\n        } \n        return s;\n    }\n};\n"
  },
  {
    "question_theme": "perfectSquares",
    "question": "/*************************************************************************************** \n *\n * Given a positive integer n, find the least number of perfect square numbers (for \n * example, 1, 4, 9, 16, ...) which sum to n.\n * \n * For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 \n * because 13 = 4 + 9.\n * \n * Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating \n * all test cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/perfect-squares/\n// Author : Hao Chen\n// Date   : 2015-10-25\n\n\n\n\nclass Solution {\npublic:\n\n    int numSquares(int n) {\n        return numSquares_dp_opt(n); //12ms\n        return numSquares_dp(n); //232ms\n    }\n    \n    \n    int numSquares_dp(int n) {\n        if ( n <=0 ) return 0;\n        \n        int *dp = new int[n+1];\n        dp[0] = 0;\n        \n        for (int i=1; i<=n; i++ ) {\n            int m = n;\n            for (int j=1; i-j*j >= 0; j++) {\n                m = min (m, dp[i-j*j] + 1);\n            }\n            dp[i] = m;\n        }\n    \n        return dp[n];\n        delete [] dp;\n    }\n    \n    //using cache to optimize the dp algorithm\n    int numSquares_dp_opt(int n) {\n        if ( n <=0 ) return 0;\n        \n        static vector<int> dp(1, 0);\n        if (dp.size() >= (n+1) ) return dp[n];\n        \n        for (int i=dp.size(); i<=n; i++ ) {\n            int m = n;\n            for (int j=1; i-j*j >= 0; j++) {\n                m = min (m, dp[i-j*j] + 1);\n            }\n            dp.push_back(m);\n        }\n    \n        return dp[n];\n    }\n};\n\n"
  },
  {
    "question_theme": "maximalRectangle",
    "question": "/********************************************************************************** \n* \n* Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle \n* containing all ones and return its area.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/maximal-rectangle/\n// Author : Hao Chen\n// Date   : 2014-07-21\n\n\n\n#include <stdlib.h>\n#include <time.h>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// The problem can be convert to the problem - \"Largest Rectangle in Histogram\"\n//   1) we can take each row to calculate each row's histogram.\n//   2) using the algorithm of \"Largest Rectangle in Histogram\" to find the largest area histogram.\n//   3) tracking the maximal area.\n//\n// For the 1), it's easy. \n//     heights[i][j] = 1,                     if (i==0)\n//     heights[i][j] = heights[i-1][j] + 1;,  if (i>0)\n//\n// For the 2), please referr to \"Largest Rectangle in Histogram\"\n// \n\nint largestRectangleArea(vector<int> &height) {\n\n    if (height.size()<=0) return 0;\n\n    height.push_back(0);\n    vector<int> stack;\n    int maxArea=0;\n\n    for(int i=0; i<height.size(); ){\n        if (stack.size()==0 || height[i] >= height[ stack.back() ] ){\n            stack.push_back(i);\n            i++;\n        }else{\n            int topIdx = stack.back();\n            stack.pop_back();\n            int area = height[topIdx] * ( stack.size()==0 ? i  : i - stack.back() - 1 );\n            if (area > maxArea){\n                maxArea = area;\n            }\n        }\n    }\n    return maxArea;\n}\n\nint maximalRectangle(vector<vector<char> > &matrix) {\n\n    if (matrix.size()<=0 || matrix[0].size()<=0) return 0;\n    int row = matrix.size();\n    int col = matrix[0].size();\n    vector< vector<int> > heights(row, vector<int>(col));\n\n    int maxArea = 0;\n    for(int i=0; i<row; i++){\n        for(int j=0; j<col; j++) {\n            if (matrix[i][j]=='1'){\n                heights[i][j] = (i==0 ? 1 : heights[i-1][j] + 1);\n            }\n        }\n        int area = largestRectangleArea(heights[i]);\n        if (area > maxArea){\n            maxArea = area;\n        }\n    }\n\n    return maxArea;\n\n}\n\nvoid printArray(vector<int> &v)\n{\n    cout << \"{\";\n    for(int i=0; i<v.size(); i++) {\n        cout << \" \" << v[i];\n    }\n    cout << \"}\" << endl;\n}\n\nvoid test(int a[], int n)\n{\n    vector<int> v(a, a + n);\n    printArray(v);\n    cout << largestRectangleArea(v) << endl;\n}\n\nint main(int argc, char** argv)\n{\n    #define TEST(a) test(a, sizeof(a)/sizeof(int))\n\n    int a0[] = {2,1,3,1};\n    TEST(a0);\n    int a1[] = {2,1,5,6,2,3};\n    TEST(a1);\n\n\n\n    cout << \"------------------\" << endl; \n    srand(time(0));\n\n    int r = 3;\n    int c = 3;\n    if (argc>2){\n        r = atoi(argv[1]);\n        c = atoi(argv[2]);\n    }\n\n    vector< vector<char> > matrix;\n    for(int i=0; i<r; i++){\n        vector<char> v;\n        cout << \"[\";\n        for(int j=0; j<c; j++) {\n            char ch = random()%2+'0';\n            v.push_back(ch);\n            cout << \" \" << ch;\n        }\n        matrix.push_back(v);\n        cout << \" ]\" << endl;\n    }\n    cout << \"------------------\" << endl; \n    cout << \"maxArea = \" << maximalRectangle(matrix) << endl;\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "question_theme": "longestCommonPrefix",
    "question": "/********************************************************************************** \n* \n* Write a function to find the longest common prefix string amongst an array of strings.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/longest-common-prefix/\n// Author : Hao Chen\n// Date   : 2014-07-03\n\n\n\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n\nstring longestCommonPrefix(vector<string> &strs) {\n    string word;\n    if (strs.size()<=0) return word;\n    for(int i=1; i<=strs[0].size(); i++){\n        string w = strs[0].substr(0, i);\n        bool match = true;\n        int j=1;\n        for(j=1; j<strs.size(); j++){\n            if (i>strs[j].size() || w!=strs[j].substr(0, i) ) {\n                match=false;\n                break;\n            }\n        }\n        if (!match) {\n            return word;\n        }\n        word = w;\n    }\n    return word;\n}\n\nint main()\n{\n    const char* s[]={\"abab\",\"aba\",\"abc\"};\n    vector<string> v(s, s+3);\n    cout << longestCommonPrefix(v) <<endl;\n}\n"
  },
  {
    "question_theme": "binaryTreeRightSideView",
    "question": "/********************************************************************************** \n * \n * Given a binary tree, imagine yourself standing on the right side of it, return \n * the values of the nodes you can see ordered from top to bottom.\n * \n * For example:\n * Given the following binary tree,\n * \n *      1            <---\n *    /   \\\n *   2     3         <---\n *    \\     \\\n *     5     4       <---\n * \n * You should return [1, 3, 4].\n * \n * Credits:Special thanks to @amrsaqr for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/binary-tree-right-side-view/\n// Author : Hao Chen\n// Date   : 2015-04-07\n\n\n\n\nclass Solution {\npublic:\n    void rightSideViewHelper(TreeNode* root, int level, vector<int>& result) {\n        if (root == NULL) return;\n        if ( result.size() < level ) result.push_back(root->val);\n        rightSideViewHelper(root->right, level+1, result);\n        rightSideViewHelper(root->left, level+1, result);\n    }\n    \n    void rightSideViewHelper(TreeNode* root, vector<int>& result) {\n        if (root==NULL) return;\n\n        vector<TreeNode*> stack;\n        vector<int> level;\n        stack.push_back(root);\n        level.push_back(1);\n        \n        while (stack.size()>0) {\n            TreeNode* r = stack.back(); stack.pop_back();\n            int l = level.back(); level.pop_back();\n            if ( result.size() < l ) {\n                result.push_back(r->val);\n            }\n            if (r->left) {\n                stack.push_back(r->left);\n                level.push_back(l+1);\n            }\n            if (r->right) {\n                stack.push_back(r->right);\n                level.push_back(l+1);\n            }\n        }\n    }\n    vector<int> rightSideView(TreeNode *root) {\n        vector<int> result;\n        if (rand()%2){\n            rightSideViewHelper(root, 1, result);\n        }else{\n            rightSideViewHelper(root, result);\n        }\n        return result;\n    }\n};\n"
  },
  {
    "question_theme": "implementTriePrefixTree",
    "question": "/********************************************************************************** \n * \n * Implement a trie with insert, search, and startsWith methods.\n * \n * Note:\n * You may assume that all inputs are consist of lowercase letters a-z.\n * \n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/implement-trie-prefix-tree/\n// Author : Hao Chen\n// Date   : 2015-06-09\n\n\n\n\nclass TrieNode {\npublic:\n    // Initialize your data structure here.\n    TrieNode():isWord(false) {   }\n    unordered_map<char, TrieNode*> children;\n    bool isWord;\n};\n\nclass Trie {\npublic:\n    Trie() {\n        root = new TrieNode();\n    }\n\n    // Inserts a word into the trie.\n    void insert(string s) {\n        if (s.size()<=0) return;\n        TrieNode * node = root;\n        for (int i=0; i<s.size(); i++) {\n            if (node->children.find(s[i]) == node->children.end()){\n                node->children[s[i]] = new TrieNode();\n            }\n            node = node->children[s[i]];\n        }\n        node->isWord = true;\n    }\n\n    // Returns if the word is in the trie.\n    bool search(string key) {\n        return retrieve(key, true);\n    }\n\n    // Returns if there is any word in the trie\n    // that starts with the given prefix.\n    bool startsWith(string prefix) {\n        return retrieve(prefix, false);\n    }\n\nprivate:\n\n    inline bool retrieve(const string& key, bool isWord) {\n        if (key.size() <= 0) return false;\n        TrieNode * node = root;\n        for (int i=0; i<key.length(); i++) {\n            if (node->children.find(key[i]) == node->children.end()) {\n                return false;\n            }\n            node = node->children[key[i]];\n        }\n        return isWord ? node->isWord : true;\n    }\n\n    TrieNode* root;\n};\n\n// Your Trie object will be instantiated and called as such:\n// Trie trie;\n// trie.insert(\"somestring\");\n// trie.search(\"key\");\n"
  },
  {
    "question_theme": "binaryTreePaths",
    "question": "/*************************************************************************************** \n *\n * Given a binary tree, return all root-to-leaf paths.\n * \n * For example, given the following binary tree:\n * \n *    1\n *  /   \\\n * 2     3\n *  \\\n *   5\n * \n * All root-to-leaf paths are:\n * [\"1->2->5\", \"1->3\"]\n * \n * Credits:\n * Special thanks to @jianchao.li.fighter for adding this problem and creating all test \n * cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/binary-tree-paths/\n// Author : Calinescu Valentin, Hao Chen\n// Date   : 2015-10-23\n\n\n\nclass Solution {\npublic:\n    vector<string> TreePaths;\n    void DFS(TreeNode* node, string answer)\n    {\n        answer += \"->\" + to_string(node->val);\n        if(node->left == NULL && node->right == NULL)\n            TreePaths.push_back(answer);\n        else\n        {\n            if(node->left != NULL)\n                DFS(node->left, answer);\n            if(node->right != NULL)\n                DFS(node->right, answer);\n        }\n    }\n    vector<string> binaryTreePaths(TreeNode* root) {\n        if(root != NULL)\n        {\n            DFS(root, \"\");\n            for(int i = 0; i < TreePaths.size(); i++)\n                TreePaths[i].erase(TreePaths[i].begin(), TreePaths[i].begin() + 2);\n        }\n        return TreePaths;\n    }\n};\n\n\n\n\n// Another more clear DFS implementation\n\nclass Solution {\npublic:\n    void binaryTreePathsHelper(TreeNode* root, vector<int> solution, vector<string>& result ) {\n        if (!root) return;\n        \n        solution.push_back(root->val);\n        \n        //meet the leaf node, shape a path into the result\n        if (root->left==NULL && root->right==NULL){\n            if(solution.size()>0){\n                stringstream ss;\n                for(int i=0; i<solution.size(); i++){\n                    ss << solution[i] << (i<solution.size()-1 ? \"->\":\"\");\n                }\n                result.push_back(ss.str());\n            }\n            return;\n        }\n        \n        binaryTreePathsHelper(root->left, solution, result);\n        binaryTreePathsHelper(root->right, solution, result);\n        \n    }\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<string> result;\n        vector<int> solution;\n        binaryTreePathsHelper(root, solution, result);\n        return result;\n    }\n};\n"
  },
  {
    "question_theme": "surroundedRegions",
    "question": "/********************************************************************************** \n* \n* Given a 2D board containing 'X' and 'O', capture all regions surrounded by 'X'.\n* \n* A region is captured by flipping all 'O's into 'X's in that surrounded region.\n* \n* For example,\n* \n* X X X X\n* X O O X\n* X X O X\n* X O X X\n* \n* After running your function, the board should be:\n* \n* X X X X\n* X X X X\n* X X X X\n* X O X X\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/surrounded-regions/\n// Author : Hao Chen\n// Date   : 2014-10-12\n\n\n\n#include <stdlib.h>\n#include <time.h>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvoid print(vector< vector<char> > &board);\n\n\n//Runtime Error for 250 x 250 matrix\nvoid markOpen(vector< vector<char> > &board, int row, int col, int r, int c) {\n\n    if (board[r][c] == 'O'){\n\n        board[r][c]='N'; // 'N' means it's not closed\n\n        if (r < row-1) {\n            markOpen(board, row, col, r+1, c);\n        }\n        if (r > 0) {\n            markOpen(board, row, col, r-1, c);\n        }\n        if (c < col-1 ) {\n            markOpen(board, row, col, r, c+1); \n        }\n        if (c>0) {\n            markOpen(board, row, col, r, c-1);\n        }\n    }\n}\n\n//Runtime Error for 250 x 250 matrix\nvoid solve_recursively(vector< vector<char> > &board) {\n\n    if (board.size()<=0 || board[0].size()<=0) return;\n\n    int row = board.size();\n    int col = board[0].size();\n    //left & right edge\n    for (int r=0; r<row; r++){\n        if ( board[r][0] == 'O') {\n            markOpen(board, row, col, r, 0); \n        }\n        if ( board[r][col-1] == 'O') {\n            markOpen(board, row, col, r, col-1); \n        }\n    }\n    //top & bottom edge\n    for (int c=1; c<col-1; c++){\n        if ( board[0][c] == 'O') {\n            markOpen(board, row, col, 0, c); \n        }\n        if ( board[row-1][c] == 'O') {\n            markOpen(board, row, col, row-1, c); \n        }\n    }\n    print(board);\n    // change 'N' to 'O', change 'O' to 'X'\n    for (int r=0; r<row; r++) {\n        for (int c=0; c<col; c++) {\n            if (board[r][c] == 'O') {\n                board[r][c]='X';\n            } else if (board[r][c] == 'N') {\n                board[r][c]='O';\n            }\n        }\n    }\n}\n\n\n\n\nstruct position{\n    int row, col;\n    void set(int r, int c) { row = r; col = c; }\n    position(int r, int c): row(r), col(c) {}\n};\n\nvoid solve_non_recursively(vector< vector<char> > &board) {\n\n    if (board.size()<=0 || board[0].size()<=0) return;\n\n    int row = board.size();\n    int col = board[0].size();\n\n    queue<position> q;\n    position p(0,0);\n\n    //left & right edge\n    for (int r=0; r<row; r++){\n        if ( board[r][0] == 'O') {\n            board[r][0] = 'N';\n            p.set(r, 0);\n            q.push(p) ; \n        }\n        if ( board[r][col-1] == 'O') {\n            board[r][col-1] = 'N';\n            p.set(r, col-1);\n            q.push(p) ; \n        }\n    }\n    //top & bottom edge\n    for (int c=1; c<col-1; c++){\n        if ( board[0][c] == 'O') {\n            board[0][c] = 'N';\n            p.set(0, c);\n            q.push(p) ; \n        }\n        if ( board[row-1][c] == 'O') {\n            board[row-1][c] = 'N';\n            p.set(row-1, c);\n            q.push(p) ; \n        }\n    }\n\n    while (!q.empty()){\n        p = q.front();\n        q.pop(); \n        int r = p.row;\n        int c = p.col;\n        if (r < row-1 && board[r+1][c] == 'O') {\n            board[r+1][c] = 'N';\n            p.set(r+1, c);\n            q.push(p);\n        }\n        if (r > 0 && board[r-1][c] == 'O') {\n            board[r-1][c] = 'N';\n            p.set(r-1, c);\n            q.push(p);\n        }\n        if (c < col-1 && board[r][c+1] == 'O') {\n            board[r][c+1] = 'N';\n            p.set(r, c+1);\n            q.push(p);\n        }\n        if (c>0 && board[r][c-1] == 'O') {\n            board[r][c-1] = 'N';\n            p.set(r, c-1);\n            q.push(p);\n        }\n    }\n\n\n    print(board);\n    // change 'N' to 'O', change 'O' to 'X'\n    for (int r=0; r<row; r++) {\n        for (int c=0; c<col; c++) {\n            if (board[r][c] == 'O') {\n                board[r][c]='X';\n            } else if (board[r][c] == 'N') {\n                board[r][c]='O';\n            }\n        }\n    }\n}\n\n\n// refers to <Algorithm> 4th edition.\nclass UnionFind {\n    int  count_;  // number of components\n    int* rank_;   // to limits tree hights\n    int* id_;     // id[i] parent of i\npublic:\n    UnionFind(int n) {\n        count_ = n;\n        rank_ = new int[n];\n        id_ = new int[n];\n        for (int i = 0; i < n; i++) {\n            id_[i] = i;\n            rank_[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete [] rank_;\n        delete [] id_;\n    }\n\n    int count() { return count_; }\n\n    int find(int p) {\n        while (p != id_[p])    {\n            id_[p] = id_[id_[p]]; // path compression\n            p = id_[p];\n        }\n        return p;\n    }\n\n    bool connected(int p, int q) {\n        return find(p) == find(q);\n    }\n\n    void connect(int p, int q) {\n        int i = find(p);\n        int j = find(q);\n        if (i == j) return;\n        if (rank_[i] < rank_[j]) id_[i] = j;\n        else if (rank_[i] > rank_[j]) id_[j] = i;\n        else { // ==\n            id_[j] = i;\n            rank_[i]++;\n        }\n        count_--;\n    }\n};\n\nclass Solution {\npublic:\n    void solve(vector<vector<char> >& board) {\n        int n = board.size();\n        if (n == 0) return;\n        int m = board[0].size();\n\n        UnionFind uf(n*m+1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (i == 0 || i == n-1 || j == 0 || j == m-1) { // side case, connect to dummy node\n                    uf.connect(i*m + j, n*m);\n                    continue;\n                }\n                char c = board[i][j]; // inner case, connect to same neighbor\n                if (board[i+1][j] == c) uf.connect((i+1)*m + j, i*m + j);\n                if (board[i-1][j] == c) uf.connect((i-1)*m + j, i*m + j);\n                if (board[i][j+1] == c) uf.connect(i*m + (j+1), i*m + j);\n                if (board[i][j-1] == c) uf.connect(i*m + (j-1), i*m + j);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (board[i][j] == 'O' && !uf.connected(i*m + j, n*m)) {\n                    board[i][j] = 'X';\n                }\n            }\n        }\n    }\n};\n\n\nvoid solve(vector< vector<char> > &board) {\n    if (rand() % 2) {\n        Solution().solve(board);\n        return;\n    }\n    //Runtime Error for 250 x 250 matrix\n    \n    solve_non_recursively(board); \n}\n\nvoid construct(vector< vector<char> > &board, int row, int col) {\n    srand(time(0));\n    for(int i=0; i<row; i++){\n        vector<char> line;\n        for(int j=0; j<col; j++){\n            if (i==0 || j==0 || i==row-1 || j==col-1) \n                line.push_back(rand()%3 ? 'X' : 'O'); \n            else\n                line.push_back(rand()%2 ? 'X' : 'O'); \n        }\n        board.push_back(line);\n    }\n}\n\nvoid print(vector< vector<char> > &board) {\n    for(int i=0; i<board.size(); i++){\n        for(int j=0; j<board[i].size(); j++){\n            cout << board[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nint main(int argc, char** argv )\n{\n    int row, col;\n    row = col = 6;\n    if (argc>1){\n        row = atoi(argv[1]);\n    }\n    if (argc>2){\n        col = atoi(argv[2]);\n    }\n\n    vector< vector<char> > data;\n\n    construct(data, row, col);\n    print(data);\n\n    solve(data);\n    print(data);\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "productOfArrayExceptSelf",
    "question": "/********************************************************************************** \n * \n * Given an array of n integers where n > 1, nums, return an array output such that \n * output[i] is equal to the product of all the elements of nums except nums[i].\n * \n * Solve it without division and in O(n).\n * \n * For example, given [1,2,3,4], return [24,12,8,6].\n * \n * Follow up:\n * Could you solve it with constant space complexity? (Note: The output array does not \n * count as extra space for the purpose of space complexity analysis.)\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/product-of-array-except-self/\n// Author : Hao Chen\n// Date   : 2015-07-17\n\n\n\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        \n        int len = nums.size();\n        vector<int> result(len, 1);\n        \n        //from the left to right \n        for (int i=1; i<len; i++) {\n            result[i] = result[i-1]*nums[i-1];\n        }\n        //from the right to left\n        int factorial = 1;\n        for (int i=len-2; i>=0; i--){\n            factorial *= nums[i+1];\n            result[i] *= factorial;\n        }\n        return result;\n    }\n};\n\n\n\n"
  },
  {
    "question_theme": "decodeString",
    "question": "/*************************************************************************************** \n *\n * Given an encoded string, return it's decoded string.\n * \n * The encoding rule is: k[encoded_string], where the encoded_string inside the square \n * brackets is being repeated exactly k times. Note that k is guaranteed to be a \n * positive integer.\n * \n * You may assume that the input string is always valid; No extra white spaces, square \n * brackets are well-formed, etc.\n * \n * Furthermore, you may assume that the original data does not contain any digits and \n * that digits are only for those repeat numbers, k. For example, there won't be input \n * like 3a or 2[4].\n * \n * Examples:\n * \n * s = \"3[a]2[bc]\", return \"aaabcbc\".\n * s = \"3[a2[c]]\", return \"accaccacc\".\n * s = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/decode-string/\n// Author : Hao Chen\n// Date   : 2016-09-08\n\n\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        if (!isValid(s)) return \"\";\n        \n        stack<string> _stack;\n        stack<int> _nstack;\n        \n        string result;\n        string tmp;\n        int n=0;\n        for (int i=0; i<s.size(); i++) {\n            \n            if ( isNum(s[i]) ) {\n                n = 0;\n                for(; isNum(s[i]); i++ ) {\n                   n = n*10 + s[i] - '0'; \n                }\n            }\n            \n            if (s[i] == '[') {\n                tmp=\"\";\n                _stack.push(tmp);\n                _nstack.push(n);\n            } else if (s[i] == ']') {\n                n = _nstack.top(); \n                tmp=\"\";\n                for (; n>0; n--) {\n                    tmp += _stack.top();\n                }\n                _stack.pop();\n                _nstack.pop();\n                if ( ! _stack.empty() ) {\n                    _stack.top() += tmp;\n                }else {\n                    result += tmp;\n                }\n            } else {\n                if ( ! _stack.empty() ) {\n                    _stack.top() += s[i];\n                } else {\n                    result += s[i];\n                }\n                \n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n\n    //only check the following rules:\n    // 1) the number must be followed by '['\n    // 2) the '[' and ']' must be matched.\n    bool isValid(string& s) {\n        stack<char> _stack;\n        for (int i=0; i<s.size(); i++) {\n            if ( isNum(s[i]) ) {\n                for(; isNum(s[i]); i++);\n                if (s[i] != '[') {\n                    return false;\n                } \n                _stack.push('[');\n                continue;\n            } else if (s[i] == ']' ) {\n                if ( _stack.top() != '[' ) return false;\n                _stack.pop();\n            }\n        }\n        \n        return (_stack.size() == 0);\n    }\n    \n    bool isNum(char ch) {\n        return (ch>='0' && ch<='9');\n    }\n};\n\n"
  },
  {
    "question_theme": "verifyPreorderSerializationOfABinaryTree",
    "question": "/*************************************************************************************** \n *\n * One way to serialize a binary tree is to use pre-order traversal. When we encounter \n * a non-null node, we record the node's value. If it is a null node, we record using a \n * sentinel value such as #.\n * \n *      _9_\n *     /   \\\n *    3     2\n *   / \\   / \\\n *  4   1  #  6\n * / \\ / \\   / \\\n * # # # #   # #\n * \n * For example, the above binary tree can be serialized to the string \n * \"9,3,4,#,#,1,#,#,2,#,6,#,#\", where # represents a null node.\n * \n * Given a string of comma separated values, verify whether it is a correct preorder \n * traversal serialization of a binary tree. Find an algorithm without reconstructing \n * the tree.\n * \n * Each comma separated value in the string must be either an integer or a character \n * '#' representing null pointer.\n * \n * You may assume that the input format is always valid, for example it could never \n * contain two consecutive commas such as \"1,,3\".\n * \n * Example 1:\n * \"9,3,4,#,#,1,#,#,2,#,6,#,#\"\n * Return true\n * Example 2:\n * \"1,#\"\n * Return false\n * Example 3:\n * \"9,#,#,1\"\n * Return false\n * \n * Credits:Special thanks to @dietpepsi for adding this problem and creating all test \n * cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/\n// Author : Hao Chen\n// Date   : 2017-01-06\n\n\n\nclass Solution {\npublic:\n\n    // we know the following facts:\n    //   1) if we met a non-null node, then this node will generate two child node.\n    //   2) if we met a null node, then this node will generate zero child node.\n    //\n    // so the idea is, \n    //   1) we can have a counter to calculate how many node we are going to expect \n    //   2) once we have the expected node, then we can decrease the counter.\n    //   3) finally, we will check the counter is zero or not.\n    //\n    // the algorithm as below:\n    //   1) when we meet a non-null node, just simply do `counter++`. because:\n    //      1.1) we will expect 2 more node after, then we do `counter += 2`. \n    //      1.2) but the current node also meet the expection of parent node , so, it need remove 1 in counter.\n    //           finally, the `counter = counbter + 2 -1`\n    //   2) when we meet a null node, just simply do `counter--`.\n    \n    bool isValidSerialization(string preorder) {\n        vector<string> list;\n        split(preorder, ',', list);\n        //we initailize the counter as 1, \n        //because we expect at lease 1 node in the tree.\n        int node_expected = 1;\n        for (auto node : list) {\n            if (node_expected == 0) return false;\n            node == \"#\" ? node_expected-- : node_expected++;\n        }\n        return node_expected == 0;\n    }\n    \n    void split(const string &s, char delim, vector<string> &elems) {\n        stringstream ss(s);\n        string item;\n        while (getline(ss, item, delim)) {\n            elems.push_back(item);\n        }\n    }\n};\n"
  },
  {
    "question_theme": "wordSearch",
    "question": "/********************************************************************************** \n* \n* Given a 2D board and a word, find if the word exists in the grid.\n* \n* The word can be constructed from letters of sequentially adjacent cell, \n* where \"adjacent\" cells are those horizontally or vertically neighboring. \n* The same letter cell may not be used more than once.\n* \n* For example,\n* Given board = \n* \n* [\n*   [\"ABCE\"],\n*   [\"SFCS\"],\n*   [\"ADEE\"]\n* ]\n* \n* word = \"ABCCED\", -> returns true,\n* word = \"SEE\", -> returns true,\n* word = \"ABCB\", -> returns false.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/word-search/\n// Author : Hao Chen\n// Date   : 2014-07-19\n\n\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n//Recursive backtracking algorithm\nbool exist(vector<vector<char> > &board, string word, int idx, int row, int col, vector< vector<int> > &mask) {\n    int i = row;\n    int j = col;\n    if (board[i][j] == word[idx] && mask[i][j]==0 ) {\n        mask[i][j]=1; //mark the current char is matched\n        if (idx+1 == word.size()) return true;\n        //checking the next char in `word` through the right, left, up, down four directions in the `board`.\n        idx++; \n        if (( i+1<board.size()    && exist(board, word, idx, i+1, j, mask) ) ||\n            ( i>0                 && exist(board, word, idx, i-1, j, mask) ) ||\n            ( j+1<board[i].size() && exist(board, word, idx, i, j+1, mask) ) ||\n            ( j>0                 && exist(board, word, idx, i, j-1, mask) ) )\n        {\n             return true;\n        }\n        mask[i][j]=0; //cannot find any successful solution, clear the mark. (backtracking)\n    }\n\n    return false;\n}\n\nbool exist(vector<vector<char> > &board, string word) {\n    if (board.size()<=0 || word.size()<=0) return false;\n    int row = board.size();\n    int col = board[0].size();\n    //using a mask to mark which char has been selected.\n    //do not use vector<bool>, it has big performance issue, could cause Time Limit Error\n    vector< vector<int> > mask(row, vector<int>(col, 0));\n\n    for(int i=0; i<board.size(); i++) {\n        for(int j=0; j<board[i].size(); j++){\n            if ( board[i][j]==word[0] ){\n                vector< vector<int> > m = mask;\n                if( exist(board, word, 0, i, j, m) ){\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nvector< vector<char> > buildBoard(char b[][5], int r, int c) {\n    vector< vector<char> > board;\n    for (int i=0; i<r; i++){\n        vector<char> v(b[i], b[i]+c);\n        cout << b[i] << endl;\n        board.push_back(v);\n    }\n    cout << \"----------\" << endl;    \n    return board;\n}\n\nint main(int argc, char** argv)\n{\n    string s;\n    char b[3][5] ={ \"ABCE\", \"SFCS\", \"ADEE\" };\n    vector< vector<char> > board = buildBoard(b, 3, 4);\n\n    s = \"SEE\";\n    cout << s << \":\" << exist(board, s) << endl; \n    \n    s = \"ABCCED\";\n    cout << s << \":\" << exist(board, s) << endl; \n    \n    s = \"ABCB\";\n    cout << s << \":\" << exist(board, s) << endl; \n\n\n    if (argc>1){\n        s = argv[1];\n        cout << s << \":\" << exist(board, s) << endl; \n    }\n\n    cout << endl << \"----------\" << endl;    \n    char b1[3][5] ={ \"CAA\", \"AAA\", \"BCD\" };\n    board = buildBoard(b1, 3, 3);\n\n    s = \"AAB\";\n    cout << s << \":\" << exist(board, s) << endl; \n\n\n    cout << endl << \"----------\" << endl;    \n    char b2[3][5] ={ \"ABCE\", \"SFES\", \"ADEE\" };\n    board = buildBoard(b2, 3, 4);\n\n    s = \"ABCESEEEFS\";\n    cout << s << \":\" << exist(board, s) << endl; \n\n    cout << endl << \"----------\" << endl;    \n    char b3[3][5] ={ \"aaaa\", \"aaaa\", \"aaaa\" };\n    board = buildBoard(b3, 3, 4);\n\n    s = \"aaaaaaaaaaaaa\";\n    cout << s << \":\" << exist(board, s) << endl; \n\n    return 0;\n}\n"
  },
  {
    "question_theme": "insertDeleteGetRandom",
    "question": "/*************************************************************************************** \n *\n * Design a data structure that supports all following operations in average O(1) time.\n * \n * insert(val): Inserts an item val to the set if not already present.\n * remove(val): Removes an item val from the set if present.\n * getRandom: Returns a random element from current set of elements. Each element must \n * have the same probability of being returned.\n * \n * Example:\n * \n * // Init an empty set.\n * RandomizedSet randomSet = new RandomizedSet();\n * \n * // Inserts 1 to the set. Returns true as 1 was inserted successfully.\n * randomSet.insert(1);\n * \n * // Returns false as 2 does not exist in the set.\n * randomSet.remove(2);\n * \n * // Inserts 2 to the set, returns true. Set now contains [1,2].\n * randomSet.insert(2);\n * \n * // getRandom should return either 1 or 2 randomly.\n * randomSet.getRandom();\n * \n * // Removes 1 from the set, returns true. Set now contains [2].\n * randomSet.remove(1);\n * \n * // 2 was already in the set, so return false.\n * randomSet.insert(2);\n * \n * // Since 1 is the only number in the set, getRandom always return 1.\n * randomSet.getRandom();\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/insert-delete-getrandom-o1/\n// Author : Hao Chen\n// Date   : 2016-08-25\n\n\n\n\nclass RandomizedSet {\npublic:\n    \n    RandomizedSet() {\n        srand(time(NULL));\n    }\n    \n    \n    bool insert(int val) {\n        if ( find(val) ) return false; \n        data.push_back(val);\n        valpos[val] = data.size() - 1;\n        return true;\n    }\n    \n    \n    bool remove(int val) {\n        if ( !find(val) ) return false; \n        \n\t\t\n        int _idx = valpos[val];\n        int _val = data.back();\n        \n        data[_idx] = _val;\n        valpos[_val] = _idx;\n        \n        valpos.erase(val);\n        data.pop_back();\n        return true;\n    }\n    \n    \n    int getRandom() {\n        return data[ rand() % data.size() ];\n    }\n    \nprivate:    \n    unordered_map<int, int> valpos; //value position map\n    vector<int> data;\n    bool find(int val) {\n        return (valpos.find(val) != valpos.end());\n    }\n    \n};\n\n\n"
  },
  {
    "question_theme": "longestSubstringWithAtMostTwoDistinctCharacters",
    "question": "/*\n * Given a string, find the length of the longest substring T that contains at most 2 distinct characters.\n * \n * For example, Given s = \u201ceceba\u201d,\n * \n * T is \"ece\" which its length is 3.\n *",
    "answer": "// Source : https://oj.leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/\n// Author : Hao Chen\n// Date   : 2014-12-01\n\n\n\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\n\n\nint lengthOfLongestSubstringTwoDistinct(string s) {\n    int maxLen = 0;\n    int charMap[256] = {0};\n    int wordCnt = 0;\n    int start = 0;\n\n    for(int i=0; i<s.size(); i++){\n        if ( charMap[s[i]]++ == 0 ){\n            wordCnt++;\n        }\n        while (wordCnt>2){\n            charMap[s[start]]--;\n            if (charMap[s[start]]==0){\n                wordCnt--;\n            }\n            start++;\n        }\n        maxLen = max(maxLen, i - start + 1);\n    }\n\n    return maxLen;\n}\n\n\nint main(int argc, char** argv)\n{\n    string s = \"eceba\";\n    if (argc>1){\n        s = argv[1];\n    }\n    cout << s << \" : \" << lengthOfLongestSubstringTwoDistinct(s) << endl;\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "totalHammingDistance",
    "question": "/*************************************************************************************** \n *\n * The Hamming distance between two integers is the number of positions at which the \n * corresponding bits are different.\n * \n * Now your job is to find the total Hamming distance between all pairs of the given \n * numbers.\n * \n * Example:\n * Input: 4, 14, 2\n * \n * Output: 6\n * \n * Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\n * showing the four bits relevant in this case). So the answer will be:\n * HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n * \n * Note:\n * Elements of the given array are in the range of 0 to 10^9\n * Length of the array will not exceed 10^4.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/total-hamming-distance/\n// Author : Calinescu Valentin\n// Date   : 2017-01-09\n\n\n\n\nclass Solution {\npublic:\n    int totalHammingDistance(vector<int>& nums) {\n        long long solution = 0;\n        int ones[31];\n        for(int i = 0; i < 31; i++)\n            ones[i] = 0;\n        for(vector<int>::iterator it = nums.begin(); it != nums.end(); ++it)\n        {\n            for(int i = 0; (1 << i) <= *it; i++) //i is the position of the bit\n                if((1 << i) & *it)//to see if the bit at i-position is a 1\n                    ones[i]++;\n        }\n        for(int i = 0; i < 31; i++)\n            solution += ones[i] * (nums.size() - ones[i]);\n        return solution;\n    }\n};\n"
  },
  {
    "question_theme": "minimumWindowSubstring",
    "question": "/********************************************************************************** \n* \n* Given a string S and a string T, find the minimum window in S which will \n* contain all the characters in T in complexity O(n).\n* \n* For example,\n* S = \"ADOBECODEBANC\"\n* T = \"ABC\"\n* \n* Minimum window is \"BANC\".\n* \n* Note:\n*\n* > If there is no such window in S that covers all characters in T, \n*   return the emtpy string \"\".\n* \n* > If there are multiple such windows, you are guaranteed that there \n*   will always be only one unique minimum window in S.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/minimum-window-substring/\n// Author : Hao Chen\n// Date   : 2014-07-22\n\n\n\n#include <string.h>\n#include <iostream>\n#include <string>\nusing namespace std;\n\n#define INT_MAX      2147483647\n\nstring minWindow(string S, string T) {\n    string win;\n    if (S.size()<=0 || T.size()<=0 || T.size() > S.size()) return win;\n        \n    const int MAX_CHARS = 256;\n    int f[MAX_CHARS], m[MAX_CHARS];\n    \n    const int NOT_EXISTED   = -1;\n    const int NOT_FOUND     =  0;\n    memset(m, NOT_EXISTED, sizeof(m));\n    memset(f, NOT_EXISTED, sizeof(f));\n\n    \n    for(int i=0; i<T.size(); i++) {\n        m[T[i]]==NOT_EXISTED ? m[T[i]]=1 : m[T[i]]++ ; \n        f[T[i]] = NOT_FOUND; \n    }\n\n    int start =-1;\n    int winSize = INT_MAX;\n    int letterFound = 0;\n    int begin = 0;\n    for(int i=0; i<S.size(); i++) {\n         \n        if ( m[S[i]] != NOT_EXISTED ){\n            char ch = S[i];\n            f[ch]++;\n\n            \n            if (f[ch] <= m[ch]) {\n                letterFound++;\n            }\n            if ( letterFound >= T.size() ) {\n                \n                while ( f[S[begin]] == NOT_EXISTED || f[S[begin]] > m[S[begin]] ) { \n                    if ( f[S[begin]] > m[S[begin]] ) {\n                        f[S[begin]]--;\n                    }   \n                    begin++;\n                }\n                \n                if(winSize > i - begin + 1){\n                    start = begin;\n                    winSize = i - begin + 1;\n                }     \n                \n            }\n            \n        }\n    }\n\n    if (start>=0 && winSize>0) {\n        win = S.substr(start, winSize);\n    }\n    return win;\n}\n\n\nint main(int argc, char**argv)\n{\n    string S = \"ADOBECODEBANC\";\n    string T = \"ABC\";\n    if (argc>2){\n        S = argv[1];\n        T = argv[2];\n    }\n    cout << \"S = \\\"\" << S << \"\\\"  T=\\\"\" << T << \"\\\"\" <<endl;\n    cout << minWindow(S, T) << endl;\n    return 0;\n}\n\n"
  },
  {
    "question_theme": "sumRootToLeafNumber",
    "question": "/********************************************************************************** \n* \n* Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.\n* An example is the root-to-leaf path 1->2->3 which represents the number 123.\n* \n* Find the total sum of all root-to-leaf numbers.\n* \n* For example,\n* \n*     1\n*    / \\\n*   2   3\n* \n* The root-to-leaf path 1->2 represents the number 12.\n* The root-to-leaf path 1->3 represents the number 13.\n* \n* Return the sum = 12 + 13 = 25.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/sum-root-to-leaf-numbers/\n// Author : Hao Chen\n// Date   : 2014-06-21\n\n\n\n\nclass Solution {\npublic:\n    int sumNumbers(TreeNode *root) {\n    \n        if (!root) return 0;\n        \n        int sum = 0;       \n        vector<TreeNode*> v;\n        v.push_back(root);\n        while(v.size()>0){\n            TreeNode* node = v.back();\n            v.pop_back();\n            if (node->left){\n                node->left->val += (10*node->val); \n                v.push_back(node->left);\n            }\n            if (node->right){\n                node->right->val += (10*node->val); \n                v.push_back(node->right);\n            }\n            if(!node->right && !node->left){\n                sum += node->val;\n            }\n        }\n        \n        return sum;\n    }\n};\n"
  },
  {
    "question_theme": "lowestCommonAncestorOfABinaryTree",
    "question": "/********************************************************************************** \n * \n * Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the \n * tree.\n * \n * According to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is \n * defined between two nodes v and w as the lowest node in T that has both v and w as \n * descendants (where we allow a node to be a descendant of itself).\u201d\n * \n *         _______3______\n *        /              \\\n *     ___5__          ___1__\n *    /      \\        /      \\\n *    6      _2       0       8\n *          /  \\\n *          7   4\n * \n * For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example \n * is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according \n * to the LCA definition.\n *               \n *               \n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/\n// Author : Hao Chen\n// Date   : 2015-07-17\n\n\n\n\n\nclass Solution {\npublic:\n    bool findPath(TreeNode* root, TreeNode* p, vector<TreeNode*>& path) {\n        if (root==NULL) return false;\n        if (root == p) {\n            path.push_back(p);\n            return true;\n        }\n        \n        path.push_back(root);\n        if (findPath(root->left, p, path)) return true;\n        if (findPath(root->right, p, path)) return true;\n        path.pop_back();\n        \n        return false;\n    }\n\n    //Ordinary way, find the path and comapre the path.\n    TreeNode* lowestCommonAncestor01(TreeNode* root, TreeNode* p, TreeNode* q) {\n        \n        vector<TreeNode*> path1, path2;\n        \n        if (!findPath(root, p, path1)) return NULL;\n        if (!findPath(root, q, path2)) return NULL;\n        \n        int len = path1.size() < path2.size() ? path1.size() : path2.size();\n        TreeNode* result = root;\n        for(int i=0; i<len; i++) {\n            if (path1[i] != path2[i]) {\n                return result;\n            }\n            result = path1[i];\n        }\n        return result;\n    }\n    \n    //Actually, we can do the recursive search in one time\n    TreeNode* lowestCommonAncestor02(TreeNode* root, TreeNode* p, TreeNode* q) {\n        \n        //return if found or not found, return NULL if not found\n        if (root==NULL || root == p || root == q) return root;\n        \n        //find the LCA in left tree\n        TreeNode* left = lowestCommonAncestor02(root->left, p, q);\n        //find the LCA in right tree\n        TreeNode* right = lowestCommonAncestor02(root->right, p, q);\n        \n        //left==NULL means both `p` and `q` are not found in left tree.\n        if (left==NULL) return right;\n        //right==NULL means both `p` and `q` are not found in right tree.\n        if (right==NULL) return left;\n        // left!=NULL && right !=NULL, which means `p` & `q` are seperated in left and right tree.\n        return root;\n    }\n    \n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        srand(time(0));\n        if (random()%2) {\n            return lowestCommonAncestor02(root, p, q);\n        }\n        return lowestCommonAncestor01(root, p, q);\n    }\n};\n"
  },
  {
    "question_theme": "interleavingString",
    "question": "/********************************************************************************** \n* \n* Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.\n* \n* For example,\n* Given:\n* s1 = \"aabcc\",\n* s2 = \"dbbca\",\n* \n* When s3 = \"aadbbcbcac\", return true.\n* When s3 = \"aadbbbaccc\", return false.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/interleaving-string/\n// Author : Hao Chen\n// Date   : 2014-08-27\n\n\n\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n\n\n\n\n\n//Dynamic Programming\nbool isInterleave(string s1, string s2, string s3) {\n    \n    if (s1.size() + s2.size() != s3.size()) {\n        return false;\n    }\n\n    vector< vector<int> > match(s1.size()+1, vector<int>(s2.size()+1, false) );\n\n    match[0][0] = true;\n    for(int i=1; i<=s1.size(); i++) {\n        if (s1[i-1] == s3[i-1] ) {\n            match[i][0] = true;\n        }else{\n            break;\n        }\n    }\n    for(int i=1; i<=s2.size(); i++) {\n        if (s2[i-1] == s3[i-1] ) {\n            match[0][i] = true;\n        }else{\n            break;\n        }\n    }\n\n    \n    for(int i=1; i<=s1.size(); i++) {\n        for(int j=1; j<=s2.size(); j++) {\n            if (s1[i-1] == s3[i+j-1]) {\n                match[i][j] = match[i-1][j] || match[i][j];\n            }\n            if (s2[j-1] == s3[i+j-1]) {\n                match[i][j] = match[i][j-1] || match[i][j];\n            }\n        }\n    }\n    return match[s1.size()][s2.size()];\n}\n\n//Time Limit Exceeded\nbool isInterleave_dfs(string s1, string s2, string s3) {\n    if (s1.size() + s2.size() != s3.size()) {\n        return false;\n    }\n\n    const char *p1 = s1.c_str(), *p2 = s2.c_str(), *p3 = s3.c_str();\n    for (; *p3 != '\\0'; p3++){\n        if (*p3 == *p1 && *p3!=*p2) {\n            p1++;\n        }else if ( *p3 == *p2 && *p3 != *p1) {\n            p2++;\n        }else if (*p3==*p1 && *p3 ==*p2) {\n            if (isInterleave(p1+1, p2, p3+1) == false){\n                return isInterleave(p1, p2+1, p3+1);\n            }\n            return true;\n        }else{\n            return false;\n        }\n    }\n    return ( *p1 =='\\0' && *p2 =='\\0' && *p3 =='\\0' );\n}\n\n#define TEST(s1, s2, s3) cout << s1 << \", \" << s2 << \" = \" << s3 << \" : \" << isInterleave(s1,s2,s3) << endl;\nint main(int argc, char**argv)\n{\n    string s1=  \"aabcc\", s2 = \"dbbca\";\n    TEST(s1,s2, \"aadbbcbcac\");\n    TEST(s1,s2, \"aadbbbaccc\");\n\n    s1=\"c\"; s2=\"ca\";\n    TEST(s1, s2, \"cca\");\n    TEST(s1, s2, \"cac\");\n\n    s1 = \"bbbbbabbbbabaababaaaabbababbaaabbabbaaabaaaaababbbababbbbbabbbbababbabaabababbbaabababababbbaaababaa\";\n    s2 = \"babaaaabbababbbabbbbaabaabbaabbbbaabaaabaababaaaabaaabbaaabaaaabaabaabbbbbbbbbbbabaaabbababbabbabaab\";\n    string s3 = \"babbbabbbaaabbababbbbababaabbabaabaaabbbbabbbaaabbbaaaaabbbbaabbaaabababbaaaaaabababbababaababbababbbababbbbaaaabaabbabbaaaaabbabbaaaabbbaabaaabaababaababbaaabbbbbabbbbaabbabaabbbbabaaabbababbabbabbab\";\n    TEST(s1, s2, s3);\n    \n    return 0;\n}\n"
  },
  {
    "question_theme": "longestAbsoluteFilePath",
    "question": "/*************************************************************************************** \n *\n * Suppose we abstract our file system by a string in the following manner:\n * \n * The string \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\" represents:\n * \n * dir\n *     subdir1\n *     subdir2\n *         file.ext\n * \n * The directory dir contains an empty sub-directory subdir1 and a sub-directory \n * subdir2 containing a file file.ext.\n * \n * The string \n * \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile\n * 2.ext\" represents:\n * \n * dir\n *     subdir1\n *         file1.ext\n *         subsubdir1\n *     subdir2\n *         subsubdir2\n *             file2.ext\n * \n * The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains \n * a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 \n * contains a second-level sub-directory subsubdir2 containing a file file2.ext.\n * \n * We are interested in finding the longest (number of characters) absolute path to a \n * file within our file system. For example, in the second example above, the longest \n * absolute path is \"dir/subdir2/subsubdir2/file2.ext\", and its length is 32 (not \n * including the double quotes).\n * \n * Given a string representing the file system in the above format, return the length \n * of the longest absolute path to file in the abstracted file system. If there is no \n * file in the system, return 0.\n * \n * Note:\n * \n * The name of a file contains at least a . and an extension.\n * The name of a directory or sub-directory will not contain a ..\n * \n * Time complexity required: O(n) where n is the size of the input string.\n * \n * Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another \n * path aaaaaaaaaaaaaaaaaaaaa/sth.png.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/longest-absolute-file-path/\n// Author : Hao Chen\n// Date   : 2016-08-23\n\n\n\nclass Solution {\npublic:\n    // Solution\n    // --------\n    // We can see the input formation has the order\n    // so, we can maintain an array which states the current level's path length\n    //\n    // For example:\n    //    dir\n    //        subdir1            <- length[ level1 = len(\"dir\")+len(\"/\"), \n    //                                      level2 = len(\"dir\")+len(\"/\")+len(\"subdir1\")+len(\"/\") ] \n    //           file.ext\n    //        subdir2\n    //           file.ext\n    //           subsubdir1     <- length[ level1 = len(\"dir\")+len(\"/\"), \n    //                                     level2 = len(\"dir\")+len(\"/\")+len(\"subdir2\")+len(\"/\"), \n    //                                     level3 = len(\"dir\")+len(\"/\")+len(\"subdir2\")+len(\"/\")+len(\"subsubdir1\")+len(\"/\") ] \n    //               file.ext  \n    //\n    int lengthLongestPath(string input) {\n        \n         stringstream ss(input); \n         string line;\n         int result = 0;\n         \n         vector<int> length;\n         length.push_back(0); //initialize top dummy level's length is zero\n        \n         while (getline(ss, line, '\\n')) {\n             //get current level, start from 1\n             int level = 0;\n             while ( line[level++] == '\\t'); // get the level\n             int len = line.size() - level + 1;\n\n             //if is a file, then cacualte the total length.\n             if (line.find('.') != string::npos) { \n                 if ( length[level-1] + len > result ) {\n                    result = length[level-1] + len;\n                 }\n             } else {\n                \n                 if (length.size() <= level) {\n                     length.push_back(0); \n                 }\n                 \n                 // if it a folder, then update the current level's length\n                 length[level] = length[level-1] + len + 1; // 1 for \"/\" path delimiter\n             }\n             \n         }\n         return result;\n    }\n};\n"
  },
  {
    "question_theme": "validSudoku",
    "question": "/********************************************************************************** \n* \n* Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.\n* \n* The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n* \n* A partially filled sudoku which is valid.\n* \n* Note:\n* > A valid Sudoku board (partially filled) is not necessarily solvable. \n*   Only the filled cells need to be validated.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/valid-sudoku/\n// Author : Hao Chen\n// Date   : 2014-07-17\n\n\n\nclass Solution {\npublic:\n    bool isValidSudoku(vector<vector<char> > &board) {\n        const int cnt = 9;\n        bool row_mask[cnt][cnt] = {false};\n        bool col_mask[cnt][cnt] = {false};\n        bool area_mask[cnt][cnt] = {false};\n        //check each rows and cols\n        for(int r=0; r<board.size(); r++){\n            for (int c=0; c<board[r].size(); c++){\n                if (!isdigit(board[r][c])) continue;\n                int idx =  board[r][c] - '0' - 1;\n                \n                //check the rows\n                if (row_mask[r][idx] == true){\n                    return false;\n                }\n                row_mask[r][idx] = true;\n                \n                //check the cols\n                if (col_mask[c][idx] == true) {\n                    return false;\n                }\n                col_mask[c][idx] = true;\n                \n                //check the areas\n                int area = (r/3) * 3 + (c/3);\n                if (area_mask[area][idx] == true) {\n                    return false;\n                }\n                area_mask[area][idx] = true;\n            }\n        }\n        \n        return true;\n    }\n};\n"
  },
  {
    "question_theme": "jumpGame",
    "question": "/********************************************************************************** \n* \n* Given an array of non-negative integers, you are initially positioned at the first index of the array.\n* \n* Each element in the array represents your maximum jump length at that position. \n* \n* Determine if you are able to reach the last index.\n* \n* For example:\n* A = [2,3,1,1,4], return true.\n* \n* A = [3,2,1,0,4], return false.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/jump-game/\n// Author : Hao Chen\n// Date   : 2014-06-27\n\n\n\nclass Solution {\npublic:\n    bool canJump(int A[], int n) {\n        if (n<=0) return false;\n        \n        // the basic idea is traverse array, maintain the most far can go\n        int coverPos=0;\n        // the condition i<=coverPos means traverse all of covered position \n        for(int i=0; i<=coverPos && i<n; i++){\n            \n            if (coverPos < A[i] + i){\n                coverPos = A[i] + i;\n            }\n            \n            if (coverPos>=n-1){\n                return true;\n            }\n        }\n        return false;\n    }\n};\n"
  },
  {
    "question_theme": "binaryTreeInorderTraversal",
    "question": "/********************************************************************************** \n* \n* Given a binary tree, return the inorder traversal of its nodes' values.\n* \n* For example:\n* Given binary tree {1,#,2,3},\n* \n*    1\n*     \\\n*      2\n*     /\n*    3\n* \n* return [1,3,2].\n* \n* Note: Recursive solution is trivial, could you do it iteratively?\n* \n* confused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ.\n* \n* OJ's Binary Tree Serialization:\n* \n* The serialization of a binary tree follows a level order traversal, where '#' signifies \n* a path terminator where no node exists below.\n* \n* Here's an example:\n* \n*    1\n*   / \\\n*  2   3\n*     /\n*    4\n*     \\\n*      5\n* \n* The above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\". \n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/binary-tree-inorder-traversal/\n// Author : Hao Chen\n// Date   : 2014-06-27\n\n\n\n\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode *root) {\n        vector<TreeNode*> stack;\n        vector<int> v;\n        \n        while(stack.size()>0 || root!=NULL){\n            if (root!=NULL){\n                stack.push_back(root);\n                root = root->left;\n            }else{\n                if (stack.size()>0) {\n                    root = stack.back();\n                    stack.pop_back();\n                    v.push_back(root->val);\n                    root = root->right;\n                }\n            }\n        }\n        return v;\n    }\n};\n"
  },
  {
    "question_theme": "ransomNote",
    "question": "/*************************************************************************************** \n *\n * \u2029Given\u2029 an \u2029arbitrary\u2029 ransom\u2029 note\u2029 string \u2029and \u2029another \u2029string \u2029containing \n * \u2029letters from\u2029 all \u2029the \u2029magazines,\u2029 write \u2029a \u2029function \u2029that \u2029will \u2029return \u2029true \n * \u2029if \u2029the \u2029ransom \u2029\n * note \u2029can \u2029be \u2029constructed \u2029from \u2029the \u2029magazines ; \u2029otherwise, \u2029it \u2029will \u2029return \n * \u2029false. \u2029\u2029\n * \n * Each \u2029letter\u2029 in\u2029 the\u2029 magazine \u2029string \u2029can\u2029 only \u2029be\u2029 used \u2029once\u2029 in\u2029 your \n * \u2029ransom\u2029 note.\n * \n * Note:\n * You may assume that both strings contain only lowercase letters.\n * \n * canConstruct(\"a\", \"b\") -> false\n * canConstruct(\"aa\", \"ab\") -> false\n * canConstruct(\"aa\", \"aab\") -> true\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/ransom-note/\n// Author : Hao Chen\n// Date   : 2016-08-24\n\n\n\nclass Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n        unordered_map<char, int> m;\n        for(int i=0; i<magazine.size(); i++) {\n            m[magazine[i]]++;\n        }\n        for (int i=0; i<ransomNote.size(); i++) {\n            char c = ransomNote[i];\n            if (m[c] <=0 ) return false;\n            m[c]--;\n        }\n        return true;\n    }\n};\n"
  },
  {
    "question_theme": "validNumber",
    "question": "/********************************************************************************** \n* \n* Validate if a given string is numeric.\n* \n* Some examples:\n* \"0\" => true\n* \"   0.1  \" => true\n* \"abc\" => false\n* \"1 a\" => false\n* \"2e10\" => true\n* \n* Note: It is intended for the problem statement to be ambiguous. \n*       You should gather all requirements up front before implementing one.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/valid-number/\n// Author : Hao Chen\n// Date   : 2014-08-26\n\n\n\n#include <iostream>\nusing namespace std;\n\n\nbool isdigit(const char c){\n    return (c>='0' && c<='9');\n}\nbool isspace(const char c) {\n    return (c==' ' || c =='\\t' || c=='\\n' || c=='\\r' || c=='\\f' || c=='\\v');\n}\n\nbool isNumber(const char *s) {\n    bool point = false;\n    bool hasE = false;\n    \n    //trim the space\n    while(isspace(*s)) s++;\n    //check empty \n    if (*s == '\\0' ) return false;\n    //check sign\n    if (*s=='+' || *s=='-') s++;\n\n    const char *head  = s;\n    for(; *s!='\\0'; s++){\n        // if meet point\n        if ( *s == '.' ){\n            if ( hasE == true || point == true){\n                return false;\n            }\n            if ( s == head && !isdigit(*(s+1))  ){\n                return false;\n            }\n            point = true; \n            continue; \n        }\n        //if meet \"e\"\n        if ( *s == 'e' ){\n            if ( hasE == true || s == head) {\n                return false;\n            }\n            s++;\n            if ( *s=='+' || *s=='-' )  s++;\n            if ( !isdigit(*s) ) return false;\n      \n            hasE = true; \n            continue; \n        }\n        //if meet space, check the rest chars are space or not\n        if (isspace(*s)){\n            for (; *s != '\\0'; s++){\n                if (!isspace(*s)) return false;\n            }\n            return true;\n        }\n        if ( !isdigit(*s) ) {\n            return false;\n        }\n       \n    }\n    \n    return true; \n}\n\n\n#define TEST(s) cout << \"\\\"\" << s << \"\\\"\" << \" : \" << isNumber(s) << endl\nint main(int argc, char** argv)\n{\n    const char* s=\"123\";\n    if(argc>1){\n        s = argv[1];\n    }\n    TEST(s);\n\n    TEST(\"1.044\");\n    TEST(\" 1.044 \");\n    TEST(\"1.a\");\n    TEST(\"abc\");\n    TEST(\"e\");\n    TEST(\"1e\");\n    TEST(\"1e2\");\n    TEST(\"\");\n    TEST(\" \");\n    TEST(\"1.\");\n    TEST(\".2\");\n    TEST(\" . \");\n    TEST(\".\");\n    TEST(\"1.2.3\");\n    TEST(\"1e2e3\");\n    TEST(\"1..\");\n    TEST(\"+1.\");\n    TEST(\" -1.\");\n    TEST(\"6e6.5\");\n    TEST(\"005047e+6\");\n    \n\n    return 0;\n}\n"
  },
  {
    "question_theme": "countOfRangeSum",
    "question": "/*************************************************************************************** \n *\n * Given an integer array nums, return the number of range sums that lie in [lower, \n * upper] inclusive.\n * \n *     Range sum S(i, j) is defined as the sum of the elements in nums between indices \n * i and \n *     j (i \u2264 j), inclusive.\n * \n *     Note:\n *     A naive algorithm of O(n2) is trivial. You MUST do better than that.\n * \n *     Example:\n *     Given nums = [-2, 5, -1], lower = -2, upper = 2,\n *     Return 3.\n *     The three ranges are : [0, 0], [2, 2], [0, 2] and their respective sums are: -2, -1, 2.\n * \n * Credits:Special thanks to @dietpepsi for adding this problem and creating all test \n * cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/count-of-range-sum/\n// Author : Hao Chen\n// Date   : 2016-01-15\n\n\n\n\n\n\nclass Node{\n    public:\n        long long val;\n        int cnt; //amount of the nodes\n        Node *left, *right;\n        Node(long long v):val(v), cnt(1), left(NULL), right(NULL) {}\n};\n\n// a tree stores all of prefix sums\nclass Tree{\n    public:\n        Tree():root(NULL){ }\n        ~Tree() { freeTree(root); }\n        \n        void Insert(long long val) {\n            Insert(root, val);\n        }\n        int LessThan(long long sum, int val) {\n            return LessThan(root, sum, val, 0);\n        }\n        \n    private:\n        Node* root;\n        \n        //general binary search tree insert algorithm\n        void Insert(Node* &root, long long val) {\n            if (!root) {\n                root = new Node(val);\n                return;\n            }\n            \n            root->cnt++;\n            \n            if (val < root->val ) {\n                Insert(root->left, val);\n            }else if (val > root->val) {\n                Insert(root->right, val);\n            }\n        }\n        //return how many of the sums less than `val`\n        //  -  `sum` is the new sums which hasn't been inserted\n        //  -  `val` is the `lower` or `upper+1`\n        int LessThan(Node* root, long long sum, int val, int res) {\n            \n            if (!root) return res;\n\n            if ( sum - root->val < val) {\n                //if (sum[j, i] < val), which means all of the right branch must be less than `val` \n                //so we add the amounts of sums in right branch, and keep going the left branch.\n                res += (root->cnt - (root->left ? root->left->cnt : 0) );\n                return LessThan(root->left, sum, val, res);\n            }else if ( sum - root->val > val) {\n                //if (sum[j, i] > val), which means all of left brach must be greater than `val`\n                //so we just keep going the right branch.\n                return LessThan(root->right, sum, val, res);\n            }else {\n                //if (sum[j,i] == val), which means we find the correct place, \n                //so we just return the the amounts of right branch.]\n                return res + (root->right ? root->right->cnt : 0);\n            }\n        }\n        void freeTree(Node* root){\n            if (!root) return;\n            if (root->left) freeTree(root->left);\n            if (root->right) freeTree(root->right);\n            delete root;\n        }\n        \n};\n\n\n\nclass Solution {\npublic:\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        Tree tree;\n        tree.Insert(0);\n        long long sum = 0;\n        int res = 0;\n        \n        for (int n : nums) {\n            sum += n;\n            int lcnt = tree.LessThan(sum, lower);\n            int hcnt = tree.LessThan(sum, upper + 1);\n            res += (hcnt - lcnt);\n            tree.Insert(sum);\n        }\n\n        return res;\n    }\n};\n"
  },
  {
    "question_theme": "perfectRectangle",
    "question": "/*************************************************************************************** \n *\n * Given N axis-aligned rectangles where N > 0, determine if they all together form an \n * exact cover of a rectangular region.\n * \n * Each rectangle is represented as a bottom-left point and a top-right point. For \n * example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point \n * is (1, 1) and top-right point is (2, 2)).\n * \n * Example 1:\n * \n * rectangles = [\n *   [1,1,3,3],\n *   [3,1,4,2],\n *   [3,2,4,4],\n *   [1,3,2,4],\n *   [2,3,3,4]\n * ]\n * \n * Return true. All 5 rectangles together form an exact cover of a rectangular region.\n * \n * Example 2:\n * \n * rectangles = [\n *   [1,1,2,3],\n *   [1,3,2,4],\n *   [3,1,4,2],\n *   [3,2,4,4]\n * ]\n * \n * Return false. Because there is a gap between the two rectangular regions.\n * \n * Example 3:\n * \n * rectangles = [\n *   [1,1,3,3],\n *   [3,1,4,2],\n *   [1,3,2,4],\n *   [3,2,4,4]\n * ]\n * \n * Return false. Because there is a gap in the top center.\n * \n * Example 4:\n * \n * rectangles = [\n *   [1,1,3,3],\n *   [3,1,4,2],\n *   [1,3,2,4],\n *   [2,2,4,4]\n * ]\n * \n * Return false. Because two of the rectangles overlap with each other.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/perfect-rectangle/\n// Author : Hao Chen\n// Date   : 2016-09-08\n\n\n\n\nclass Solution {\npublic:\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\n        unordered_map<string,int> mp;\n        string corners[4];\n        for(auto v: rectangles)\n            for(int i = 0; i<4; ++i){\n                corners[i] = to_string(v[i/2*2]) + \",\" + to_string(v[(i%2)*2+1]);\n                if(mp[corners[i]] & int(pow(2,i))) return false;\n                else mp[corners[i]] |= int(pow(2,i));\n            }\n        int corner = 0;\n        for(auto i=mp.begin(); i!=mp.end(); ++i){\n            int val = i->second;\n            if(!(val & (val-1)) && (++corner >4)) return false;\n            if((val & (val-1)) && !(val == 3 || val==12 || val==10 || val==5 || val==15)) return false;\n        }\n        return true;        \n    }\n};\n"
  },
  {
    "question_theme": "uniqueMorseCodeWords",
    "question": "/*************************************************************************************** \n *\n * International orse Code defines a standard encoding where each letter is mapped to \n * a series of dots and dashes, as follows: \"a\" maps to \".-\", \"b\" maps to \"-...\", \"c\" \n * maps to \"-.-.\", and so on.\n * \n * For convenience, the full table for the 26 letters of the English alphabet is given \n * below:\n * \n * \n * [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\n * \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n * \n * Now, given a list of words, each word can be written as a concatenation of the orse \n * code of each letter. For example, \"cab\" can be written as \"-.-.-....-\", (which is \n * the concatenation \"-.-.\" + \"-...\" + \".-\"). We'll call such a concatenation, the \n * transformation of a word.\n * \n * Return the number of different transformations among all words we have.\n * \n * \n * Example:\n * Input: words = [\"gin\", \"zen\", \"gig\", \"msg\"]\n * Output: 2\n * Explanation: \n * The transformation of each word is:\n * \"gin\" -> \"--...-.\"\n * \"zen\" -> \"--...-.\"\n * \"gig\" -> \"--...--.\"\n * \"msg\" -> \"--...--.\"\n * \n * There are 2 different transformations, \"--...-.\" and \"--...--.\".\n * \n * \n *  \n * \n * Note:\n * \n * \n * \tThe length of words will be at most 100.\n * \tEach words[i] will have length in range [1, 12].\n *     words[i] will only consist of lowercase letters.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/unique-morse-code-words/description/\n// Author : Hao Chen\n// Date   : 2018-06-29\n\n\n\nclass Solution {\npublic:\n    int uniqueMorseRepresentations(vector<string>& words) {\n        \n        string MorseTable[26] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\n                                 \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\n                                 \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\n                                 \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\n        unordered_map<string, bool> transformations;\n        for (auto word : words) {\n            string morse;\n            for (auto ch : word) {\n                morse += MorseTable[ ch - 'a' ];\n            }\n            transformations[morse]=true;\n        }\n        return transformations.size();\n    }\n};\n"
  },
  {
    "question_theme": "evaluateReversePolishNotation",
    "question": "/********************************************************************************** \n* \n* Evaluate the value of an arithmetic expression in Reverse Polish Notation.\n* \n* Valid operators are +, -, *, /. Each operand may be an integer or another expression.\n* \n* Some examples:\n* \n*   [\"2\", \"1\", \"+\", \"3\", \"*\"] -> ((2 + 1) * 3) -> 9\n*   [\"4\", \"13\", \"5\", \"/\", \"+\"] -> (4 + (13 / 5)) -> 6\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/evaluate-reverse-polish-notation/\n// Author : Hao Chen\n// Date   : 2014-06-16\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\n\nclass Solution {\npublic:\n    int evalRPN(vector<string> &tokens) {\n        int i =0;\n        bool err = false;\n        vector<int> exp;\n        for (int i=0; i<tokens.size() && !err; i++ ){\n            if (isNum(tokens[i])) {\n                exp.push_back(value);\n            } else if( isOp(tokens[i])==true ) {\n                if (exp.size() < 2) {\n                    return 0; //ERROR\n                }\n                int lhs, rhs;\n                rhs = exp.back();\n                exp.pop_back();\n                lhs = exp.back();\n                exp.pop_back();\n\n                int evlValue;\n                if (tokens[i]==\"+\"){\n                    evlValue = lhs + rhs;    \n                }else if (tokens[i]==\"-\"){\n                    evlValue = lhs - rhs;\n                }else if (tokens[i]==\"*\"){\n                    evlValue = lhs * rhs;\n                }else if (tokens[i]==\"/\"){\n                    evlValue = lhs / rhs;\n                }\n\n                exp.push_back(evlValue);\n\n            }else {\n                return 0; //ERROR \n            }\n        }\n\n        if (exp.size()==1){\n            return exp.back();\n        }\n        return 0;        \n\n    }\n\nprivate:\n    long value;\n\n    bool isOp(string &op) {\n        return (op==\"+\" || op==\"-\" || op==\"*\" || op==\"/\");\n    }\n\n    bool isNum(string &num) {\n        char *end;\n        value = strtol(num.c_str(), &end, 10); \n        if (end == num.c_str() || *end != '\\0' || errno == ERANGE){\n            return false;\n        }\n        return true;\n    }\n};\n\n\nint main()\n{\n    Solution s;\n    char exps[5][3] = {\"42\", \"9\", \"6\", \"-\", \"+\"};\n    vector<string> expression;\n\n    cout << \"Expression: \\n    \";\n    for (int i=0; i<5; i++){\n        expression.push_back(exps[i]);\n        cout << exps[i] << \" \";\n    }\n    cout << endl;\n    cout << s.evalRPN(expression)<<endl;;\n\n    char exps2[5][3] =  {\"2\", \"1\", \"+\", \"3\", \"*\"};\n    expression.clear();\n\n    cout << \"Expression: \\n    \";\n    for (int i=0; i<5; i++){\n        expression.push_back(exps2[i]);\n        cout << exps2[i] << \" \";\n    }\n    cout << endl;\n    cout << s.evalRPN(expression)<<endl;\n\n\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "gasStation",
    "question": "/********************************************************************************** \n* \n* There are N gas stations along a circular route, where the amount of gas at station i is gas[i].\n* \n* You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to \n* its next station (i+1). You begin the journey with an empty tank at one of the gas stations.\n* \n* Return the starting gas station's index if you can travel around the circuit once, otherwise return -1.\n* \n* Note:\n* The solution is guaranteed to be unique.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/gas-station/\n// Author : Hao Chen\n// Date   : 2014-10-11\n\n\n\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\n        int current = 0;\n        int start = gas.size(); //start from the end to beginning\n        int total = 0;\n        \n        do {\n            if (total + gas[current] - cost[current] >= 0) {\n                total += (gas[current] - cost[current]);\n                current++; // can go from current to current+1\n            }else{\n                start--; //not enough gas, try to start the one before origin start point.\n                total += (gas[start] - cost[start]);\n            }\n        } while(current != start);\n        \n        return total>=0 ? start % gas.size() : -1;\n    }\n};\n"
  },
  {
    "question_theme": "numberOfIslands",
    "question": "/********************************************************************************** \n * \n * Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. \n * An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. \n * You may assume all four edges of the grid are all surrounded by water.\n * \n * Example 1:\n *   11110\n *   11010\n *   11000\n *   00000\n * Answer: 1\n * \n * Example 2:\n *   11000\n *   11000\n *   00100\n *   00011\n * Answer: 3\n * \n * Credits:Special thanks to @mithmatt for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/number-of-islands/\n// Author : Hao Chen\n// Date   : 2015-06-08\n\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid mark(vector<vector<char> >& grid, int r, int c){\n    if ( r<0 || r>=grid.size() ||\n            c<0 || c>=grid[0].size() ||\n            grid[r][c] != '1' ) {\n        return;\n    }\n\n    grid[r][c] = 'M';\n\n    //left\n    mark(grid, r, c+1);\n    //right\n    mark(grid, r, c-1);\n    //up\n    mark(grid, r-1, c);\n    //down\n    mark(grid, r+1, c);\n}\n\nint numIslands(vector<vector<char> >& grid) {\n    int result = 0;\n    for (int r=0; r<grid.size(); r++) {\n        for (int c=0; c<grid[r].size(); c++) {\n            if (grid[r][c] == '1') {\n                result++;\n                mark(grid, r, c);\n            }\n        }\n    }\n    return result;\n}\n\nvoid initGrid( string g[], int len, vector<vector<char> >& grid )\n{\n    for (int i=0; i<len; i++){\n       grid.push_back(vector<char>(g[i].begin(), g[i].end())); \n    }\n}\n\nint main(void)\n{\n    vector< vector<char> > grid;\n    grid.push_back( vector<char>(1, '1') );\n\n    cout << numIslands(grid) << endl;\n\n\n    grid.clear();\n\n    string g1[] = { \"11110\",\n                    \"11010\", \n                    \"11000\", \n                    \"00000\" };\n\n    initGrid(g1, 4, grid);\n    cout << numIslands(grid) << endl;\n\n\n\n    grid.clear();\n\n    string g2[] = { \"11000\",\n                    \"11000\",\n                    \"00100\",\n                    \"00011\" };\n\n    initGrid(g2, 4, grid);\n    cout << numIslands(grid) << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "binaryTreeUpsideDown",
    "question": "/********************************************************************************** \n* Given a binary tree where all the right nodes are either leaf nodes with \n* a sibling (a left node that shares the same parent node) or empty, \n* \n* Flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. \n* Return the new root.\n* \n* For example:\n* Given a binary tree {1,2,3,4,5},\n*     1\n*    / \\\n*   2   3\n*  / \\\n* 4   5\n* return the root of the binary tree [4,5,2,#,#,3,1].\n*    4\n*   / \\\n*  5   2\n*     / \\\n*    3   1  \n* confused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ. \n* \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/binary-tree-upside-down/\n// Author : Hao Chen\n// Date   : 2014-11-17\n\n\n\n\n\nclass Solution {\npublic:\n    TreeNode *upsideDownBinaryTree(TreeNode *root) {\n        //using a dummy node to help to store the new tree      \n        TreeNode dummy(0);\n        TreeNode *head =  &dummy, *left=NULL, *right=NULL;\n\n        while ( root!=NULL ) {\n            //find the right & left\n            left = root->right;\n            right = root;\n            \n            //move root the next\n            root = root->left;\n            \n            //replace the right with current root\n            right->left = head->left;\n            right->right = head->right;\n            \n            //move the dummy to the root\n            dummy.right = right;\n            dummy.left = left;\n            \n            //reset the head to the root\n            head = &dummy;\n    \n        }\n        \n        return head->right;\n    }\n};\n"
  },
  {
    "question_theme": "jewelsAndStones",
    "question": "/*************************************************************************************** \n *\n * You're given strings J representing the types of stones that are jewels, and S \n * representing the stones you have.  Each character in S is a type of stone you have.  \n * You want to know how many of the stones you have are also jewels.\n * \n * The letters in J are guaranteed distinct, and all characters in J and S are letters. \n * Letters are case sensitive, so \"a\" is considered a different type of stone from \"A\".\n * \n * Example 1:\n * \n * \n * Input: J = \"aA\", S = \"aAAbbbb\"\n * Output: 3\n * \n * \n * Example 2:\n * \n * \n * Input: J = \"z\", S = \"ZZ\"\n * Output: 0\n * \n * \n * Note:\n * \n * \n * \tS and J will consist of letters and have length at most 50.\n * \tThe characters in J are distinct.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/jewels-and-stones/description\n// Author : Hao Chen\n// Date   : 2018-06-23\n\n\n\n\nclass Solution {\npublic:\n    int numJewelsInStones(string J, string S) {\n        bool map[256] = {false};\n        for (auto c : J) {\n            map[c]=true;\n        }\n        int cnt=0;\n        for (auto c : S) {\n            if (map[c])  cnt++;\n        }\n        return cnt;\n    }\n};\n"
  },
  {
    "question_theme": "minimumSizeSubarraySum",
    "question": "/********************************************************************************** \n * \n * Given an array of n positive integers and a positive integer s, find the minimal length of a subarray \n * of which the sum \u2265 s. If there isn't one, return 0 instead.\n * \n * For example, given the array [2,3,1,2,4,3] and s = 7,\n * the subarray [4,3] has the minimal length under the problem constraint.\n * \n * click to show more practice.\n * \n * More practice:\n * \n * If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).\n * \n * Credits:Special thanks to @Freezen for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/minimum-size-subarray-sum/\n// Author : Hao Chen\n// Date   : 2015-06-09\n\n\n\n\nclass Solution {\npublic:\n    int minSubArrayLen(int s, vector<int>& nums) {\n        int min = nums.size();\n        int begin=0, end=0;\n        int sum = 0;\n        bool has = false;\n        \n        for (int i=0; i<nums.size(); i++, end++){\n            \n            sum += nums[i];\n            \n            while (sum >= s && begin <= end) {\n                //the 1 is minial length, just return\n                if (begin == end) return 1;\n                \n                if (end-begin+1 < min) {\n                    min = end - begin + 1;\n                    has = true;\n                }\n                //move the begin\n                sum -= nums[begin++];\n            }\n \n        }\n        \n        return has ? min : 0; \n    }\n};\n"
  },
  {
    "question_theme": "findMedianFromDataStream",
    "question": "/*************************************************************************************** \n *\n * Median is the middle value in an ordered integer list. If the size of the list is \n * even, there is no middle value. So the median is the mean of the two middle value.\n * Examples: \n * [2,3,4] , the median is 3\n * [2,3], the median is (2 + 3) / 2 = 2.5 \n * \n * Design a data structure that supports the following two operations:\n * \n * void addNum(int num) - Add a integer number from the data stream to the data \n * structure.\n * double findMedian() - Return the median of all elements so far.\n * \n * For example:\n * \n * add(1)\n * add(2)\n * findMedian() -> 1.5\n * add(3) \n * findMedian() -> 2\n * \n * Credits:Special thanks to @Louis1992 for adding this problem and creating all test \n * cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/find-median-from-data-stream/\n// Author : Hao Chen\n// Date   : 2015-11-14\n\n\n\n\nclass MedianFinder {\n    \nprivate:\n    //we seprate the sorted array to two parts\n    multiset<int> first, second;\n    \npublic:\n\n    // Adds a number into the data structure.\n    void addNum(int num) {\n        if (first.empty() || num <= *(first.rbegin()) ) {\n            first.insert(num);\n        } else {\n            second.insert(num);\n        }\n        \n        if (first.size() > second.size() + 1) {\n            auto it = first.end();\n            it--;\n            second.insert(*(it));\n            first.erase(it);\n        }\n        \n        if ( first.size() < second.size() ) {\n            first.insert(*(second.begin()));\n            second.erase(second.begin());\n        }\n    }\n\n    // Returns the median of current data stream\n    double findMedian() {\n        if (first.size()> second.size()) {\n            return *(first.rbegin());\n        }\n        double x = *first.rbegin();\n        double y = *second.begin();\n        return (x+y)/2;\n    }\n};\n\n// Your MedianFinder object will be instantiated and called as such:\n// MedianFinder mf;\n// mf.addNum(1);\n// mf.findMedian();\n"
  },
  {
    "question_theme": "distinctSubsequences",
    "question": "/********************************************************************************** \n* \n* Given a string S and a string T, count the number of distinct subsequences of T in S.\n* \n* A subsequence of a string is a new string which is formed from the original string \n* by deleting some (can be none) of the characters without disturbing the relative positions \n* of the remaining characters. (ie, \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not).\n* \n* Here is an example:\n* S = \"rabbbit\", T = \"rabbit\"\n* \n* Return 3.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/distinct-subsequences/\n// Author : Hao Chen\n// Date   : 2014-07-06\n\n\n#include <stdlib.h>\n#include <time.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\n//=====================\n// Dynamic Programming\n//=====================\n//\n//  The idea as below:\n//\n//     Considering m[i][j] means the distance from T[i] to S[j], and add the empty \"\" case, then,\n//\n//     A) Initialization for empty case:  m[0][j] = 1;\n//\n//     B) Calculation \n//\n//        a) Target-len > Source-len cannot found any substring\n//           i > j : m[i][j] = 0;   \n//\n//        b) if not equal, take the value of T[i] => S[j-1] (e.g. [\"ra\" => \"rabb\"] =[\"ra\" => \"rab\"] )\n//           S[j] != T[i] :  m[i][j] = m[i][j-1]\n//\n//        c) if equal. (e.g.  [\"rab\" => \"rabb\"] = [\"rab\" =>\"rab\"] + [\"ra\" => \"rab\"] ) \n//           S[j] == T[i] :  m[i][j] = m[i][j-1] + m[i-1][j-1]\n//\n//  1) Initialize a table as below   \n//       \"\"  r  a  b  b  b  i  t\n//    \"\"  1  1  1  1  1  1  1  1\n//    r     \n//    b   \n//    t  \n//\n//  2) Calculation\n//       \"\"  r  a  b  b  b  i  t\n//    \"\"  1  1  1  1  1  1  1  1\n//    r   0  1  1  1  1  1  1  1 \n//    b   0  0  0  1  2  3  3  3\n//    t   0  0  0  0  0  0  0  3\n//\nint numDistinct1(string S, string T) {\n    vector< vector<int> > m(T.size()+1, vector<int>(S.size()+1));\n    \n    for (int i=0; i<m.size(); i++){\n        for (int j=0; j<m[i].size(); j++){\n\n            if (i==0){\n                m[i][j] = 1;\n                continue;\n            }\n            if ( i>j ) {\n                m[i][j] = 0;\n                continue;\n            }\n            if (S[j-1] == T[i-1]){\n                m[i][j] = m[i][j-1] + m[i-1][j-1];\n            } else {\n                m[i][j] = m[i][j-1] ;\n            }\n        }\n    }\n    return m[T.size()][S.size()];\n}\n\n\n//=====================\n// Dynamic Programming\n//=====================\n//\n//  The idea here is an optimization of above idea \n//  (It might be difficult to understand if you don't understand the above idea)\n//\n//    For example:\n//\n//      S = \"abbbc\"  T=\"abb\"\n//      posMap = { [a]={0}, [b]={2,1} } <- the map of T's every char.\n//      numOfSubSeq = {1, 0, 0, 0 }\n//\n//      S[0] is 'a', pos is 0,  numOfSubSeq = {1, 0+1, 0, 0};\n//\n//      S[1] is 'b', pos is 2,  numOfSubSeq = {1, 1, 0, 0+0};\n//                   pos is 1,  numOfSubSeq = {1, 1, 0+1, 0};\n//\n//      S[2] is 'b', pos is 2,  numOfSubSeq = {1, 1, 1, 0+1};\n//                   pos is 1,  numOfSubSeq = {1, 1, 1+1, 1};\n//\n//      S[3] is 'b', pos is 2,  numOfSubSeq = {1, 1, 2, 2+1};\n//                   pos is 1,  numOfSubSeq = {1, 1, 1+2, 3};\n//\n//      S[4] is 'c', not found, numOfSubSeq = {1, 1, 3, 3};\n// \n//\nint numDistinct2(string S, string T) {\n\n    map< char, vector<int> > pos_map;\n    int len = T.size();\n    vector<int> numOfSubSeq(len+1);\n    numOfSubSeq[0] = 1;\n\n    for (int i=len-1; i>=0; i--){\n        pos_map[T[i]].push_back(i);\n    }\n    \n    for (int i=0; i<S.size(); i++){\n        char ch = S[i];\n        if ( pos_map.find(ch) != pos_map.end() ) {\n            for (int j=0; j<pos_map[ch].size(); j++) {\n                int pos = pos_map[ch][j];\n                numOfSubSeq[pos+1] += numOfSubSeq[pos];\n            } \n        }\n    }\n\n    return numOfSubSeq[len];\n}\n\n\n//random invoker\nint numDistinct(string S, string T) {\n    srand(time(0));\n    if (rand()%2){\n        cout << \"-----Dynamic Programming Method One-----\" << endl;\n        return numDistinct1(S,T);\n    }\n    cout << \"-----Dynamic Programming Method Two-----\" << endl;\n    return numDistinct2(S,T);\n}\n\n\nint main(int argc, char** argv)\n{\n    string s = \"rabbbit\";\n    string t = \"rabbit\";\n    if (argc>2){\n        s = argv[1];\n        t = argv[2];\n    }\n    cout << \"S=\\\"\" << s << \"\\\"  T=\\\"\" << t << \"\\\"\" << endl;\n    cout << \"numDistinct = \" << numDistinct(s, t) << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "reorderList",
    "question": "/********************************************************************************** \n* \n* Given a singly linked list L: L0\u2192L1\u2192\u2026\u2192Ln-1\u2192Ln,\n* reorder it to: L0\u2192Ln\u2192L1\u2192Ln-1\u2192L2\u2192Ln-2\u2192\u2026\n* \n* You must do this in-place without altering the nodes' values.\n* \n* For example,\n* Given {1,2,3,4}, reorder it to {1,4,2,3}.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/reorder-list/\n// Author : Hao Chen\n// Date   : 2014-06-17\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nclass ListNode {\npublic:\n    int val;\n    ListNode *next;\n    ListNode():val(0), next(NULL) {}\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    void reorderList(ListNode *head) {\n        ListNode *pMid = findMidPos(head);\n        pMid = reverseList(pMid);\n        head = Merge(head, pMid);\n    }\n    \nprivate:\n    ListNode* findMidPos(ListNode *head){\n\n        ListNode *p1, *p2, *p=NULL;\n        p1 = p2 = head;\n        \n        while(p1!=NULL && p2!=NULL && p2->next!=NULL){\n            p = p1;\n            p1 = p1->next;\n            p2 = p2->next->next;\n        }\n\n        if(p!=NULL){\n            p->next = NULL;\n        }\n        \n        return p1;\n    }\n    \n    ListNode* reverseList(ListNode *head){\n        ListNode* h = NULL;\n        ListNode *p;\n        while (head!=NULL){\n            p = head;\n            head = head->next;\n            p->next = h;\n            h = p;\n        }\n        return h;\n    }\n    \n    ListNode* Merge(ListNode *h1, ListNode* h2) {\n        ListNode *p1=h1, *p2=h2, *p1nxt, *p2nxt;\n        while(p1!=NULL && p2!=NULL){\n            p1nxt = p1->next;\n            p2nxt = p2->next;\n            \n            p1->next = p2;\n            p2->next = p1nxt;\n            \n            if (p1nxt==NULL){\n                p2->next = p2nxt;\n                break;\n            }\n            p1=p1nxt;\n            p2=p2nxt;\n        }\n    }\n};\n\nvoid printList(ListNode *h){\n    while(h!=NULL){\n        printf(\"%d->\", h->val);\n        h = h->next;\n    }\n    printf(\"nil\\n\");\n}\n\nint main(int argc, char** argv)\n{\n    int size = atoi(argv[1]);\n    ListNode* n = new ListNode[size] ;\n\n    for(int i=0; i<size; i++){\n        n[i].val = i;\n        if( i+1 < size) {\n            n[i].next = &n[i+1];\n        }\n    }\n\n\n    Solution s;\n    s.reorderList(&n[0]);\n    printList(&n[0]);\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "question_theme": "bulbSwitcher",
    "question": "/*************************************************************************************** \n *\n * There are n bulbs that are initially off. You first turn on all the bulbs. Then, you\n * turn off every second bulb. On the third round, you toggle every third bulb (turning\n * on if it's off or turning off if it's on). For the nth round, you only toggle the\n * last bulb. Find how many bulbs are on after n rounds.\n * \n * Example:\n * \n * Given n = 3. \n * \n * At first, the three bulbs are [off, off, off].\n * After first round, the three bulbs are [on, on, on].\n * After second round, the three bulbs are [on, off, on].\n * After third round, the three bulbs are [on, off, off]. \n * \n * So you should return 1, because there is only one bulb is on.\n * \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/bulb-switcher/\n// Author : Calinescu Valentin, Hao Chen\n// Date   : 2015-12-28\n\n\n\n \n\nclass Solution {\npublic:\n    int bulbSwitch(int n) {\n        int cnt = 0;\n        for (int i=1; i*i<=n; i++) { \n            cnt++;\n        }\n        return cnt;\n    }\n};\n\n\n\n \nclass Solution {\npublic:\n    int bulbSwitch(int n) {\n        return (int)sqrt(n);\n    }\n};\n"
  },
  {
    "question_theme": "regularExpressionMatching",
    "question": "/********************************************************************************** \n* \n* Implement regular expression matching with support for '.' and '*'.\n* \n* '.' Matches any single character.\n* '*' Matches zero or more of the preceding element.\n* \n* The matching should cover the entire input string (not partial).\n* \n* The function prototype should be:\n* bool isMatch(const char *s, const char *p)\n* \n* Some examples:\n* isMatch(\"aa\",\"a\") \u2192 false\n* isMatch(\"aa\",\"aa\") \u2192 true\n* isMatch(\"aaa\",\"aa\") \u2192 false\n* isMatch(\"aa\", \"a*\") \u2192 true\n* isMatch(\"aa\", \".*\") \u2192 true\n* isMatch(\"ab\", \".*\") \u2192 true\n* isMatch(\"aab\", \"c*a*b\") \u2192 true\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/regular-expression-matching/\n// Author : Hao Chen\n// Date   : 2014-08-24\n\n\n\n#include <stdio.h>\n#include <string.h>\n#include <iostream>\n\nusing namespace std;\n\n\nbool isMatch(const char *s, const char *p) {\n\n    if (*p=='\\0') {\n        return *s == '\\0';\n    }\n    //p's length 1 is special case \n    if (*(p+1) == '\\0' || *(p+1) !='*' ) {\n        if (*s=='\\0' || ( *p !='.' && *s != *p )) {\n            return false;\n        }\n        return isMatch(s+1, p+1);\n    }\n    int len = strlen(s);\n    int i = -1;\n    while (i < len && (i <0 || *p=='.' || *p==*(s+i)) ){\n        if (isMatch(s+i+1, p+2)) {\n            return true;\n        }\n        i++;\n    }\n    return false;\n}\n\n\nint main(int argc, char** argv)\n{\n    const char* s = \"aaa\";\n    const char* p = \"a.*\";\n\n    if (argc>2) {\n        s = argv[1];\n        p = argv[2];\n    }\n\n    cout << s << \", \" << p << \" : \" << isMatch(s,p) << endl;\n}\n"
  },
  {
    "question_theme": "missingRanges",
    "question": "/********************************************************************************** \n * \n * Given a sorted integer array where the range of elements are [lower, upper] inclusive, \n * return its missing ranges.\n *\n * For example, given [0, 1, 3, 50, 75], lower = 0 and upper = 99, \n * return [\"2\", \"4->49\", \"51->74\", \"76->99\"]. \n * \n **********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/missing-ranges/\n// Author : Hao Chen\n// Date   : 2014-12-11\n\n\n\n#include <stdlib.h>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iterator>\nusing namespace std;\n\n\nstring& makeRange(int lo, int hi){\n    static string result;\n    result=\"\";\n    stringstream ss;\n    if (lo != hi){\n        ss << lo << \"->\" << hi;\n    }else{\n        ss << lo;\n    }\n    ss >> result;\n    return result;\n}\n\n\nvector<string> findMissingRanges(int A[], int n, int lower, int upper) {\n\n    vector<string> result;\n\n    if ( n<=0 ) {\n        result.push_back(makeRange(lower, upper));\n        return result;\n    }\n\n    if (lower < A[0]){\n        result.push_back(makeRange(lower, A[0]-1 < upper ? A[0]-1 : upper));\n    }\n\n    for(int i=0; i<n-1; i++){\n        if ( A[i] + 1 == A[i+1] ) {\n            continue;\n        }\n        result.push_back(makeRange(A[i]+1, A[i+1]-1));\n    }\n\n    if (upper > A[n-1]){\n        result.push_back(makeRange(A[n-1]+1, upper));\n    }\n\n    return result;\n}\n\n\nvoid printVector(vector<string> v){\n    cout << \"[\";\n    int i=0;\n    for(; i<v.size(); i++){\n        cout << \"\\\"\" << v[i] << \"\\\"\" << (i==v.size()-1 ? \"\":\", \" );\n    }\n    cout << \"]\" <<endl;\n}\n\n\nvector<int> string2Array(string s){\n\n\n    vector<string> strarr;\n    istringstream iss(s);\n    copy(istream_iterator<string>(iss),\n            istream_iterator<string>(),\n            back_inserter(strarr));\n\n    vector<int> result;\n    for (int i=0; i<strarr.size(); i++){\n        result.push_back(atoi(strarr[i].c_str()));\n    }\n\n    return result;\n}\n\nint main(int argc, char**argv)\n{\n    int A[] = {0, 1, 3, 50, 75};\n    int lo = 0;\n    int hi = 99;\n\n    vector<string> result = findMissingRanges(A, sizeof(A)/sizeof(A[0]), lo ,hi);\n\n    printVector(result);    \n\n\n    //usage: ./missingRanges 0 9 \"3 5 7\"\n    if (argc>3){\n        lo = atoi(argv[1]);\n        hi = atoi(argv[2]);\n        vector<int> a;\n        a = string2Array(argv[3]);\n\n        int *pA = &a[0];\n        result = findMissingRanges(pA, a.size(), lo, hi);\n        printVector(result);    \n    }\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "combinationSumIV",
    "question": "/*************************************************************************************** \n *\n * Given an integer array with all positive numbers and no duplicates, find the number\n * of possible combinations that add up to a positive integer target.\n * \n * Example:\n * \n * nums = [1, 2, 3]\n * target = 4\n * \n * The possible combination ways are:\n * (1, 1, 1, 1)\n * (1, 1, 2)\n * (1, 2, 1)\n * (1, 3)\n * (2, 1, 1)\n * (2, 2)\n * (3, 1)\n * \n * Note that different sequences are counted as different combinations.\n * \n * Therefore the output is 7.\n * Follow up:\n * What if negative numbers are allowed in the given array?\n * How does it change the problem?\n * What limitation we need to add to the question to allow negative numbers?\n * \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/combination-sum-iv/\n// Author : Calinescu Valentin\n// Date   : 2016-08-07\n\n\n \n \nclass Solution {\npublic:\n    int combinationSum4(vector<int>& nums, int target) {\n        int sol[target + 1];\n        sol[0] = 1;//starting point, only 1 way to obtain 0, that is to have 0 elements\n        for(int i = 1; i <= target; i++)\n        {\n            sol[i] = 0;\n            for(int j = 0; j < nums.size(); j++)\n            {\n                if(i >= nums[j])//if there is a previously calculated sum to add nums[j] to\n                    sol[i] += sol[i - nums[j]];\n            }\n        }\n        return sol[target];\n    }\n};\n"
  },
  {
    "question_theme": "invertBinaryTree",
    "question": "/********************************************************************************** \n * \n * Invert a binary tree.\n *      4\n *    /   \\\n *   2     7\n *  / \\   / \\\n * 1   3 6   9\n * \n * to\n *      4\n *    /   \\\n *   7     2\n *  / \\   / \\\n * 9   6 3   1\n * \n * Trivia:\n * This problem was inspired by this original tweet by Max Howell:\n * (https://twitter.com/mxcl/status/608682016205344768)\n *\n *  | Google: 90% of our engineers use the software you wrote (Homebrew), \n *  | but you can\u2019t invert a binary tree on a whiteboard so fuck off.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/invert-binary-tree/\n// Author : Hao Chen\n// Date   : 2015-06-12\n\n\n\n\nclass Solution {\npublic:\n\n    TreeNode* invertTree_recursive(TreeNode* root) {\n        if (root==NULL) return root;\n        TreeNode* node = invertTree_recursive(root->left);\n        root->left = invertTree_recursive(root->right);\n        root->right = node;\n        return root;\n    }\n    \n    TreeNode* invertTree_non_recursive(TreeNode* root) {\n        if (root==NULL) return root;\n        vector<TreeNode*> stack;\n        stack.push_back(root);\n        while (!stack.empty()) {\n            TreeNode* node = stack.back();\n            stack.pop_back();\n            swap(node->left, node->right);\n            if (node->left) stack.push_back(node->left);\n            if (node->right) stack.push_back(node->right);\n        }\n        return root;\n    }\n    \n    TreeNode* invertTree(TreeNode* root) {\n        if (rand()%2){\n            return invertTree_non_recursive(root);\n        }\n        return invertTree_recursive(root);    \n    }\n};\n\n"
  },
  {
    "question_theme": "linkedListCycle",
    "question": "/********************************************************************************** \n* \n* Given a linked list, return the node where the cycle begins. If there is no cycle, return null.\n* \n* Follow up:\n* Can you solve it without using extra space?\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/linked-list-cycle-ii/\n// Author : Hao Chen\n// Date   : 2014-07-03\n\n\n\n\nclass Solution {\n    \nprivate:\n    ListNode *p1, *p2;\npublic:\n    bool hasCycle(ListNode *head) {\n        \n        if (head==NULL) return false;\n        p1=head;\n        p2=head;\n        \n        while (p1!=NULL && p2!=NULL){\n            \n            p1=p1->next;\n            \n            if (p2->next == NULL) return false;\n            \n            p2=p2->next->next;\n            \n            if (p1==p2) return true;\n        }\n        \n        return false;\n        \n    }  \n    \n    \n    ListNode *detectCycle(ListNode *head) {\n        \n        if (hasCycle(head)==false){\n            return NULL;\n        }\n        \n        p1 = head;\n        \n        while (p1!=p2) {\n            p1 = p1->next;\n            p2 = p2->next;\n        }\n        \n        return p1;\n    }\n};\n"
  },
  {
    "question_theme": "validateBinarySearchTree",
    "question": "/********************************************************************************** \n* \n* Given a binary tree, determine if it is a valid binary search tree (BST).\n* \n* Assume a BST is defined as follows:\n* \n* The left subtree of a node contains only nodes with keys less than the node's key.\n* The right subtree of a node contains only nodes with keys greater than the node's key.\n* Both the left and right subtrees must also be binary search trees.\n* \n* confused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ.\n* \n* OJ's Binary Tree Serialization:\n* \n* The serialization of a binary tree follows a level order traversal, where '#' signifies \n* a path terminator where no node exists below.\n* \n* Here's an example:\n* \n*    1\n*   / \\\n*  2   3\n*     /\n*    4\n*     \\\n*      5\n* \n* The above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\". \n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/validate-binary-search-tree/\n// Author : Hao Chen\n// Date   : 2014-07-05\n\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nbool isValidBST(TreeNode *root) {\n\n    //travel the tree by inner-order\n    vector<TreeNode*> stack;\n    TreeNode* node = root;\n    vector<int> v;\n    while (stack.size()>0 || node!=NULL) {\n        if (node!=NULL){\n            stack.push_back(node);\n            node = node->left;\n        }else{\n            node = stack.back();\n            stack.pop_back();\n            v.push_back(node->val);\n            node = node->right;\n        }\n    }\n\n    //check the vector wehther sorted or not\n    for(int i=0; v.size()>0 && i<v.size()-1; i++){\n        if (v[i] >= v[i+1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\nTreeNode* createTree(int a[], int n)\n{\n    if (n<=0) return NULL;\n\n    TreeNode **tree = new TreeNode*[n];\n\n    for(int i=0; i<n; i++) {\n        if (a[i]==0 ){\n            tree[i] = NULL;\n            continue;\n        }\n        tree[i] = new TreeNode(a[i]);\n    }\n    int pos=1;\n    for(int i=0; i<n && pos<n; i++) {\n        if (tree[i]){\n            tree[i]->left = tree[pos++];\n            if (pos<n){\n                tree[i]->right = tree[pos++];\n            }\n        }\n    }\n    return tree[0];\n}\n\n\nint main()\n{\n    cout << isValidBST(NULL) << endl;\n\n    int a[]={1,1};\n    cout << isValidBST(createTree(a, sizeof(a)/sizeof(int))) << endl;\n    \n    int b[]={4,2,6,1,7,5,7};\n    cout << isValidBST(createTree(b, sizeof(b)/sizeof(int))) << endl;\n\n    int c[]={4,2,6,1,3,5,7};\n    cout << isValidBST(createTree(c, sizeof(c)/sizeof(int))) << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "zigZagConversion",
    "question": "/********************************************************************************** \n* \n* The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: \n* (you may want to display this pattern in a fixed font for better legibility)\n* \n* P   A   H   N\n* A P L S I I G\n* Y   I   R\n* \n* And then read line by line: \"PAHNAPLSIIGYIR\"\n* \n* Write the code that will take a string and make this conversion given a number of rows:\n* \n* string convert(string text, int nRows);\n* \n* convert(\"PAYPALISHIRING\", 3) should return \"PAHNAPLSIIGYIR\".\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/zigzag-conversion/\n// Author : Hao Chen\n// Date   : 2014-07-17\n\n\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring convert(string s, int nRows) {\n    //The cases no need to do anything\n    if (nRows<=1 || nRows>=s.size()) return s;\n     \n    vector<string> r(nRows);\n    int row = 0;\n    int step = 1;\n    for(int i=0; i<s.size(); i ++) {\n        if (row == nRows-1) step = -1;\n        if (row == 0) step = 1;\n        //cout << row <<endl;\n        r[row] += s[i];\n        row += step;\n    }\n    \n    string result;\n    for (int i=0; i<nRows; i++){\n        result += r[i];\n    }\n    return result;\n}\n\nint main(int argc, char**argv){\n\n    string s;\n    int r;\n\n    s = \"PAYPALISHIRING\";\n    r = 3;\n    cout << s << \" : \" << convert(s, 3) << endl;\n\n}\n"
  },
  {
    "question_theme": "factorialTrailingZeroes",
    "question": "/********************************************************************************** \n * \n * Given an integer n, return the number of trailing zeroes in n!.\n * \n * Note: Your solution should be in polynomial time complexity.\n * \n * Credits:Special thanks to @ts for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/factorial-trailing-zeroes/\n// Author : Hao Chen\n// Date   : 2014-12-30\n\n\n\n\n\n\nclass Solution {\n    public:\n        int trailingZeroes(int n) {\n            int result = 0;\n            //To avoid the integer overflow ( e.g. 'n >=1808548329' )\n            for(long long i=5; n/i>0 && i <= INT_MAX; i*=5){\n                result += (n/i);\n            }\n            return result;\n        }\n\n        // Alternative implementation which naturally avoid integer overflow issue.\n        int trailingZeroes(int n) {\n            int sum=0;\n            int tmp=0;\n            while(n/5>0)\n            {\n                tmp=n/5;\n                sum+=tmp;\n                n=tmp;\n            }\n            return sum;\n        }\n};\n"
  },
  {
    "question_theme": "reverseLinkedList",
    "question": "/********************************************************************************** \n * \n * Reverse a singly linked list.\n * \n * click to show more hints.\n * \n * Hint:\n * A linked list can be reversed either iteratively or recursively. Could you implement both?\n * \n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/reverse-linked-list/\n// Author : Hao Chen\n// Date   : 2015-06-09\n\n\n\n\n\nclass Solution {\npublic:\n    ListNode* reverseList_iteratively(ListNode* head) {\n        ListNode *h=NULL, *p=NULL;\n        while (head){\n            p = head->next;\n            head->next = h;\n            h = head;\n            head = p;\n        }\n        return h;\n    }\n    ListNode* reverseList_recursively(ListNode* head) {\n        if (head==NULL || head->next==NULL) return head;\n        ListNode *h = reverseList_recursively(head->next);\n        head->next->next = head;\n        head->next = NULL;\n        return h;\n        \n    }\n    ListNode* reverseList(ListNode* head) {\n        return reverseList_iteratively(head);\n        return reverseList_recursively(head);\n    }\n};\n"
  },
  {
    "question_theme": "numberOf1Bits",
    "question": "/********************************************************************************** \n* \n* Write a function that takes an unsigned integer and returns the number of \u20191' bits it has \n* (also known as the Hamming weight).\n* \n* For example, the 32-bit integer \u201911' has binary representation 00000000000000000000000000001011, \n* so the function should return 3.\n* \n* Credits:Special thanks to @ts for adding this problem and creating all test cases.\n*               \n**********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/number-of-1-bits/\n// Author : Hao Chen\n// Date   : 2015-03-30\n\n\n\nclass Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int cnt = 0;\n        for(;n>0; n/=2){\n            if (n & 0x1) cnt++;\n        }\n        return cnt;\n    }\n};\n"
  },
  {
    "question_theme": "sumOfLeftLeaves",
    "question": "/*************************************************************************************** \n *\n * Find the sum of all left leaves in a given binary tree.\n * \n * Example:\n * \n *     3\n *    / \\\n *   9  20\n *     /  \\\n *    15   7\n * \n * There are two left leaves in the binary tree, with values 9 and 15 respectively. \n * Return 24.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/sum-of-left-leaves/\n// Author : Hao Chen\n// Date   : 2016-11-12\n\n\n\n\nclass Solution {\npublic:\n\n    \n    void sumOfLeftLeaves_recursion_v1(TreeNode* root, int& result) {\n        if (root == NULL ) {\n            return;\n        }\n        \n        if (root->left && root->left->left == NULL && root->left->right == NULL) {\n            result += root->left->val;\n        }\n        sumOfLeftLeaves_recursion_v1(root->left, result);\n        sumOfLeftLeaves_recursion_v1(root->right, result);\n        \n    }\n    \n    int sumOfLeftLeaves_recursion_v2(TreeNode* root) {\n        if (root == NULL ) {\n            return 0;\n        }\n        int result = 0;\n        if (root->left && root->left->left == NULL && root->left->right == NULL) {\n            result = root->left->val;\n        }\n        result += sumOfLeftLeaves_recursion_v2(root->left) + sumOfLeftLeaves_recursion_v2(root->right);\n        return result;\n    }    \n    \n\n    int sumOfLeftLeaves(TreeNode* root) {\n        srand(time(NULL));\n        if (rand()%2) {\n            int result = 0;\n            sumOfLeftLeaves_recursion_v1(root, result);\n            return result;\n        } else {\n            return sumOfLeftLeaves_recursion_v2(root);\n        }\n        \n    }\n};\n"
  },
  {
    "question_theme": "theSkylineProblem",
    "question": "/********************************************************************************** \n * \n * A city's skyline is the outer contour of the silhouette formed by all the buildings \n * in that city when viewed from a distance. Now suppose you are given the locations and \n * height of all the buildings as shown on a cityscape photo (Figure A), write a program \n * to output the skyline formed by these buildings collectively (Figure B).\n * \n *  ^                                        ^                                                                   \n *  |                                        |                                                                   \n *  |                                        |                                                                   \n *  |    +-----+                             |    O-----+                                                        \n *  |    |     |                             |    |     |                                                        \n *  |    |     |                             |    |     |                                                        \n *  |    |  +--+------+                      |    |     O------+                                                 \n *  |    |  |         |                      |    |            |                                                 \n *  |  +-+--+----+    |   +------+           |  O-+            |   O------+                                      \n *  |  |         |    |   |      |           |  |              |   |      |                                      \n *  |  |         |    |   |    +-+--+        |  |              |   |      O--+                                  \u2009\n *  |  |         |    |   |    |    |        |  |              |   |         |                                   \n *  |  |         |    |   |    |    |        |  |              |   |         |                                   \n *  |  |         |    |   |    |    |        |  |              |   |         |                                   \n *  |  |         |    |   |    |    |        |  |              |   |         |                                   \n *  +--+---------+----+---+----+----+--->    +--+--------------O---+---------O--->                               \n *  \n *   https://leetcode.com/static/images/problemset/skyline1.jpg  \n *   https://leetcode.com/static/images/problemset/skyline2.jpg  \n * \n * The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], \n * where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, \n * and Hi is its height. It is guaranteed that 0 \u2264 Li, Ri \u2264 INT_MAX, 0 , and Ri - Li > 0. \n * You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\n * \n * For instance, the dimensions of all buildings in Figure A are recorded as: \n *  [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .\n * \n * The output is a list of \"key points\" (red dots in Figure B) in the format of \n * [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. \n * A key point is the left endpoint of a horizontal line segment. \n *\n * Note that the last key point, where the rightmost building ends, is merely used to mark \n * the termination of the skyline, and always has zero height. Also, the ground in between \n * any two adjacent buildings should be considered part of the skyline contour.\n * \n * For instance, the skyline in Figure B should be represented as:\n *  [ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].\n * \n * Notes:\n * \n *  - The number of buildings in any input list is guaranteed to be in the range [0, 10000].\n *  - The input list is already sorted in ascending order by the left x position Li. \n *  - The output list must be sorted by the x position. \n *  - There must be no consecutive horizontal lines of equal height in the output skyline. \n *    For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; \n *    the three lines of height 5 should be merged into one in the final output as such: \n *    [...[2 3], [4 5], [12 7], ...]\n * \n * Credits: Special thanks to @stellari for adding this problem, \n *          creating these two awesome images and all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/the-skyline-problem/\n// Author : Hao Chen\n// Date   : 2015-06-11\n\n\n\n\n\n\nclass Solution {\npublic:\n\n    vector<pair<int, int>> getSkyline(vector<vector<int>>& buildings) {\n        vector< pair<int, int> > edges;\n        \n        //put all of edge into a vector\n        //set left edge as negtive, right edge as positive\n        //so, when we sort the edges, \n        //  1) for same left point, the height would be descending order\n        //  2) for same right point, the height would be ascending order\n        int left, right, height;\n        for(int i=0; i<buildings.size(); i++) {\n            left   = buildings[i][0];\n            right  = buildings[i][1];\n            height = buildings[i][2];\n            edges.push_back(make_pair(left, -height));\n            edges.push_back(make_pair(right, height));\n        }\n        sort(edges.begin(), edges.end());\n\n        // 1) if we meet a left edge, then we add its height into a `set`.\n        //    the `set` whould sort the height automatically.\n        // 2) if we meet a right edge, then we remove its height from the `set`\n        //\n        // So, we could get the current highest height from the `set`, if the \n        // current height is different with preivous height, then we need add\n        // it into the result.\n        vector< pair<int, int> > result;\n        multiset<int> m;\n        m.insert(0);\n        int pre = 0, cur = 0;\n        for (int i=0; i<edges.size(); i++){\n            pair<int,int> &e = edges[i];\n            if (e.second < 0) {\n                m.insert(-e.second);\n            }else{\n                m.erase(m.find(e.second));\n            }\n            cur = *m.rbegin();\n            if (cur != pre) {\n                result.push_back(make_pair(e.first, cur));\n                pre = cur;\n            }\n        }\n        return result;\n\n    }\n};\n"
  },
  {
    "question_theme": "search2DMatrix",
    "question": "/********************************************************************************** \n * \n * Write an efficient algorithm that searches for a value in an m x n matrix. This \n * matrix has the following properties:\n * \n * Integers in each row are sorted in ascending from left to right.\n * Integers in each column are sorted in ascending from top to bottom.\n * \n * For example,\n * \n * Consider the following matrix:\n * \n * [\n *   [1,   4,  7, 11, 15],\n *   [2,   5,  8, 12, 19],\n *   [3,   6,  9, 16, 22],\n *   [10, 13, 14, 17, 24],\n *   [18, 21, 23, 26, 30]\n * ]\n * \n * Given target = 5, return true.\n * Given target = 20, return false.\n *               \n *               \n * \n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/search-a-2d-matrix-ii/\n// Author : Hao Chen\n// Date   : 2015-08-15\n\n\n\n\nclass Solution {\npublic:\n    \n    \n    bool binary_search(vector<int> &v, int target) {\n        int low = 0;\n        int high = v.size()-1;\n        while(low <= high) {\n            int mid = low + (high - low)/2;\n            if (target == v[mid]) return true;\n            if (target < v[mid]) {\n                high = mid -1;\n            }else {\n                low = mid + 1;\n            }\n        }\n        \n        return false;\n    }\n    \n    //using binary_search() to search each rows - slow O(n*log(n))\n    //the run time is around 840ms for all test case\n    bool searchMatrix01(vector<vector<int>>& matrix, int target) {\n        for (int i=0; i<matrix.size(); i++){\n            if (target < matrix[i][0] ) return false;\n            if (binary_search(matrix[i], target))  return true;\n\n        }\n        return false;\n    }\n    \n    \n    \n    \n    //start the liner search from top right corner of matrix. - O(m+n)\n    //the run time is around 340ms\n    bool searchMatrix02(vector<vector<int>>& matrix, int target) {\n        if (matrix.size() == 0 || matrix[0].size()==0) return false;\n        int row=0,  col = matrix[0].size() - 1; \n        while (row < matrix.size() && col >=0 ) {\n            if (target == matrix[row][col]) return true;\n            if (target < matrix[row][col]) {\n                col--;\n            }else{\n                row++;\n            }\n            \n        }\n        return false;\n    }\n    \n    //a bit optimization for methed 2 - the run time is 300ms\n    bool searchMatrix021(vector<vector<int>>& matrix, int target) {\n        if (matrix.size() == 0 || matrix[0].size()==0) return false;\n        int row=0,  col = matrix[0].size() - 1; \n        while (row < matrix.size() && col >=0 ) {\n            if (target == matrix[row][col]) return true;\n            while ( col>=0 && target < matrix[row][col]) {\n                col--;\n            }\n            while(row < matrix.size() && target > matrix[row][col]){\n                row++;\n            }\n            \n        }\n        return false;\n    }\n\n    //Optimization: using binary search methed to move `low` and `row` \n    //however, the run time is around 830ms\n    bool searchMatrix022(vector<vector<int>>& matrix, int target) {\n        if (matrix.size() == 0 || matrix[0].size()==0) return false;\n        \n        int row=0,  col = matrix[0].size() - 1; \n        \n        while (row < matrix.size() && col >=0 ) {\n            \n            if (target == matrix[row][col]) return true;\n            \n            if (target < matrix[row][col]) {\n                int start=0, end=col;\n                while(start <= end){\n                    int mid = start + (end - start)/2;\n                    if (target == matrix[row][mid]) return true;\n                    if (target > matrix[row][mid]) {\n                        col = start = mid + 1;\n                    }else {\n                        col = end = mid - 1;\n                    }\n                }\n                \n            }else{\n                int start=0, end=row;\n                while(start<=end){\n                    int mid = start + (end - start)/2;\n                    if (target == matrix[mid][col]) return true;\n                    if (target > matrix[mid][col]) {\n                        row = start = mid + 1;\n                    }else{\n                        row = end = mid -1;\n                    }\n                }\n            }\n            \n        }\n        return false;\n    }\n    \n    \n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        \n        return searchMatrix022(matrix, target); //840ms ??\n        return searchMatrix021(matrix, target); //320ms\n        return searchMatrix02(matrix, target); //340ms\n        \n        return searchMatrix01(matrix, target); // 840ms\n    }\n};\n"
  },
  {
    "question_theme": "miniParser",
    "question": "/*************************************************************************************** \n *\n * Given a nested list of integers represented as a string, implement a parser to \n * deserialize it.\n * \n * Each element is either an integer, or a list -- whose elements may also be integers \n * or other lists.\n * \n * Note:\n * You may assume that the string is well-formed:\n * \n * String is non-empty.\n * String does not contain white spaces.\n * String contains only digits 0-9, [, - ,, ].\n * \n * Example 1:\n * \n * Given s = \"324\",\n * \n * You should return a NestedInteger object which contains a single integer 324.\n * \n * Example 2:\n * \n * Given s = \"[123,[456,[789]]]\",\n * \n * Return a NestedInteger object containing a nested list with 2 elements:\n * \n * 1. An integer containing value 123.\n * 2. A nested list containing two elements:\n *     i.  An integer containing value 456.\n *     ii. A nested list with one element:\n *          a. An integer containing value 789.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/mini-parser/\n// Author : Hao Chen\n// Date   : 2016-08-24\n\n\n\n\n\nclass Solution {\npublic:\n    NestedInteger deserialize(string s) {\n        if (s.size()==0) return NestedInteger();\n        int pos = 0;\n        if (s[pos]!='[') return atoni(s, pos);\n        \n        return helper(s, ++pos);\n    }\nprivate:\n    NestedInteger helper(string& s, int& pos) {\n       \n        NestedInteger ni;\n        \n        while ( s[pos] != ']' && pos < s.size() ) {\n\n            if (s[pos]=='-' || isnum(s[pos])){\n                ni.add(atoni(s, pos));\n            }else if (s[pos] == '[') {\n                pos++;\n                ni.add(helper(s, pos));\n            }else {\n                pos++;\n            }\n        }\n        pos++;\n        return ni;\n    }\n    NestedInteger atoni(string& s, int& pos) {\n        int sign = 1;\n        int num = 0;\n        if (s[pos]=='-') {\n            sign = -1;\n            pos++;\n        }\n        for (; pos < s.size(); pos++) {\n            if (isnum(s[pos])) {\n                num = num * 10 + s[pos] - '0';\n            }else{\n                break;\n            }\n        }\n        return NestedInteger(sign * num);\n    }\n    bool isnum(char& c) {\n        return (c >='0' && c <='9');\n    }\n};\n"
  },
  {
    "question_theme": "convertSortedArrayToBinarySearchTree",
    "question": "/********************************************************************************** \n* \n* Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\n// Author : Hao Chen\n// Date   : 2014-06-23\n\n\n\n\nclass Solution {\npublic:\n    TreeNode *sortedArrayToBST(vector<int> &num) {\n        if(num.size()==0){\n            return NULL;\n        }\n        if(num.size()==1){\n            return new TreeNode(num[0]);\n        }\n        int mid = num.size()/2;\n        \n        TreeNode *node = new TreeNode(num[mid]);\n        \n        vector<int>::const_iterator first;\n        vector<int>::const_iterator last;\n\n        first = num.begin();\n        last = num.begin()+mid;\n        vector<int> v(first, last);\n        node->left = sortedArrayToBST(v);\n        \n        if (mid==num.size()-1){\n            node->right = NULL;\n        }else{\n            first = num.begin()+mid+1;\n            last = num.end();\n            vector<int> v(first, last);\n            node->right = sortedArrayToBST(v);\n        }\n        return node;\n    }\n};\n"
  },
  {
    "question_theme": "topKFrequentElements",
    "question": "/*************************************************************************************** \n *\n * Given a non-empty array of integers, return the k most frequent elements.\n * \n * For example,\n * Given [1,1,1,2,2,3] and k = 2, return [1,2].\n * \n * Note: \n * You may assume k is always valid, 1 \u2264 k \u2264 number of unique elements.\n * Your algorithm's time complexity must be better than O(n log n), where n is the \n * array's size.\n * \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/top-k-frequent-elements/\n// Author : Calinescu Valentin\n// Date   : 2016-05-02\n\n\n\nclass Solution {\npublic:\n    struct element//structure consisting of every distinct number in the vector,\n    //along with its frequency\n    {\n        int number, frequency;\n        bool operator < (const element arg) const\n        {\n            return frequency < arg.frequency;\n        }\n    };\n    priority_queue <element> sol;//we use a heap so we have all of the elements sorted\n    //by their frequency\n    vector <int> solution;\n    \n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int i = 1;\n        for(; i < nums.size(); i++)\n        {\n            int freq = 1;\n            while(i < nums.size() && nums[i] == nums[i - 1])\n            {\n                i++;\n                freq++;\n            }\n            element el;\n            el.number = nums[i - 1];\n            el.frequency = freq;\n            sol.push(el);\n        }\n        if(i == nums.size())//if we have 1 distinct element as the last\n        {\n            element el;\n            el.number = nums[nums.size() - 1];\n            el.frequency = 1;\n            sol.push(el);\n        }\n        while(k)//we extract the first k elements from the heap\n        {\n            solution.push_back(sol.top().number);\n            sol.pop();\n            k--;\n        }\n        return solution;\n    }\n};\n"
  },
  {
    "question_theme": "sortList",
    "question": "/********************************************************************************** \n* \n* Sort a linked list in O(n log n) time using constant space complexity.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/sort-list/\n// Author : Hao Chen\n// Date   : 2014-07-06\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode *mergeTwoLists(ListNode* head1, ListNode* head2);\n\nListNode *sortList(ListNode *head) {\n    if (head==NULL || head->next == NULL){\n        return head;\n    }\n    //find the middle place\n    ListNode *p1=head, *p2=head->next; \n\n    while(p2 && p2->next){\n        p1 = p1->next;\n        p2 = p2->next->next;\n    }\n    p2 = p1->next;\n    p1->next = NULL;\n    return mergeTwoLists(sortList(head), sortList(p2));\n}\n\n\nListNode *mergeTwoLists(ListNode* head1, ListNode* head2){\n    ListNode *p1 = head1,  *p2=head2;\n    static ListNode dummy(0);\n\n    ListNode *tail = &dummy;\n\n    while(p1 && p2){\n        if(p1->val < p2->val){\n            tail->next = p1;\n            p1 = p1->next;\n        }else{\n            tail->next = p2;\n            p2 = p2->next;\n        }\n        tail = tail->next;\n    }\n    if (p1) tail->next = p1;\n    if (p2) tail->next = p2;\n\n    return dummy.next;\n}\n\nvoid printList(ListNode* h)\n{\n    while(h!=NULL){\n        printf(\"%d \", h->val);\n        h = h->next;\n    }\n    printf(\"\\n\");\n}\n\nListNode* createList(int a[], int n)\n{\n    ListNode *head=NULL, *p=NULL;\n    for(int i=0; i<n; i++){\n        if (head == NULL){\n            head = p = new ListNode(a[i]);\n        }else{\n            p->next = new ListNode(a[i]);\n            p = p->next;\n        }\n    }\n    return head;\n}\n\n\nint main(int argc, char** argv)\n{\n    int n = 10;\n    if (argc>1){\n        n = atoi(argv[1]);\n    }\n    srand(time(NULL));\n\n    int *a = new int[n];\n    for(int i=0; i<n; i++){\n        a[i] = random()%n + 1;\n    }\n\n    ListNode *p = createList(a, n);\n    printList(p);\n    printList(sortList(p));\n\n    delete[] a;\n    return 0;\n}\n"
  },
  {
    "question_theme": "convertANumberToHexadecimal",
    "question": "/*************************************************************************************** \n *\n * Given an integer, write an algorithm to convert it to hexadecimal. For negative \n * integer, two\u2019s complement method is used.\n * \n * Note:\n * \n * All letters in hexadecimal (a-f) must be in lowercase.\n * The hexadecimal string must not contain extra leading 0s. If the number is zero, it \n * is represented by a single zero character '0'; otherwise, the first character in the \n * hexadecimal string will not be the zero character.\n * The given number is guaranteed to fit within the range of a 32-bit signed integer.\n * You must not use any method provided by the library which converts/formats the \n * number to hex directly.\n * \n * Example 1:\n * \n * Input:\n * 26\n * \n * Output:\n * \"1a\"\n * \n * Example 2:\n * \n * Input:\n * -1\n * \n * Output:\n * \"ffffffff\"\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/convert-a-number-to-hexadecimal/\n// Author : Hao Chen\n// Date   : 2016-11-12\n\n\n\nclass Solution {\npublic:\n\n    string toHex(int num) {\n        \n        if (num == 0) return \"0\";\n        \n        unsigned int x = num;\n\n        string result;\n        for(;x > 0; x/=16) {\n            int n = x % 16;\n            char c;\n            if (n < 10) c = n + '0';\n            else c = 'a' + n - 10 ;\n            result = c + result;\n        }\n        return result;\n    }\n};\n"
  },
  {
    "question_theme": "arithmeticSlices",
    "question": "/*************************************************************************************** \n *\n * A sequence of number is called arithmetic if it consists of at least three elements \n * and if the difference between any two consecutive elements is the same.\n * \n * For example, these are arithmetic sequence:\n * 1, 3, 5, 7, 9\n * 7, 7, 7, 7\n * 3, -1, -5, -9\n * \n * The following sequence is not arithmetic. 1, 1, 2, 5, 7 \n * \n * A zero-indexed array A consisting of N numbers is given. A slice of that array is \n * any pair of integers (P, Q) such that 0 \n * \n * A slice (P, Q) of array A is called arithmetic if the sequence:\n *     A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means \n * that P + 1 \n * \n * The function should return the number of arithmetic slices in the array A. \n * \n * Example:\n * \n * A = [1, 2, 3, 4]\n * \n * return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] \n * itself.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/arithmetic-slices/\n// Author : Hao Chen\n// Date   : 2016-11-13\n\n\n\nclass Solution {\npublic:\n    //\n    // It's easy to find out how many 3-length slices in an arithmetic array with N length.\n    //\n    //   len = 3, then  1 slices, sum(1)\n    //   len = 4, then  3 slices, sum(1,2) - TWO 3-length slices + ONE 4-length slice\n    //   len = 5, then  6 slices, sum(1,2,3) - THREE 3-length slices + TWO 4-length slices + ONE 5-length slice\n    //   len = 6, then 10 slices, sum(1,2,3,4) - ...\n    //   len = 7, then 15 slices, sum(1,2,3,4,5) - ..\n    //\n    // So, with N length arithmetic array, there are Sum[1, N-3+1] 3-length slices\n    //\n    // And, we know the formula sum from 1 to n is:\n    //\n    //                  n * ( n + 1 )\n    //    sum [1, n] = ---------------\n    //                       2\n    // Then, we could have the solution - O(n) Time with O(1) Space\n    //\n    \n    int sum1toN(int n) {\n        return n * (n+1) / 2;\n    }\n\n    int numberOfArithmeticSlices(vector<int>& A) {\n        int result = 0;\n        int len = 0; // the current length of arithmetic\n        for (int i=2; i<A.size(); i++) {\n            if (A[i] - A[i-1] == A[i-1] - A[i-2]) {\n                len++;\n            }else{\n                result += sum1toN(len);\n                len=0;\n            }\n        }\n        return len==0 ? result : result + sum1toN(len);\n    }\n};\n"
  },
  {
    "question_theme": "moveZeroes",
    "question": "/*************************************************************************************** \n *\n * Given an array nums, write a function to move all 0's to the end of it while \n * maintaining the relative order of the non-zero elements.\n *\n * For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should\n * be [1, 3, 12, 0, 0].\n * \n * Note:\n * You must do this in-place without making a copy of the array.\n * Minimize the total number of operations.\n * \n * Credits:\n * Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/move-zeroes/\n// Author : Calinescu Valentin, Hao Chen\n// Date   : 2015-10-21\n\n\n\n\n\nclass Solution {\npublic:\n    \n    void moveZeroes(vector<int>& nums) {\n        int i = 0, poz = 0;\n        for(i = 0; i < nums.size() && poz < nums.size(); i++)\n        {\n                while(poz < nums.size() && nums[poz] == 0)\n                    poz++;\n                if(poz < nums.size())\n                    nums[i] = nums[poz];\n                else\n                    i--; // we need 0 on position i, but i is increasing one last time\n                poz++;\n        }\n        for(; i < nums.size(); i++)\n            nums[i] = 0;\n    }\n\n\n\n    \n    void moveZeroes(vector<int>& nums) {\n        int p1=0, p2=0;\n\n        // Find the first ZERO, where is the tail of the array.\n        // (Notes: we can simply remove this!)\n        for (; p1<nums.size() && nums[p1]!=0; p1++);\n        \n        // copy the item from p2 to p1, and skip the ZERO\n        for (p2=p1; p2<nums.size(); p2++) {\n            if ( nums[p2] == 0 ) continue;\n            nums[p1++] = nums[p2]; \n        }    \n        \n        //set ZERO for rest items \n        while ( p1<nums.size() ) nums[p1++] = 0;\n    }\n\n};\n"
  },
  {
    "question_theme": "findPeakElement",
    "question": "/********************************************************************************** \n* \n* A peak element is an element that is greater than its neighbors.\n* \n* Given an input array where num[i] \u2260 num[i+1], find a peak element and return its index.\n* \n* You may imagine that num[-1] = num[n] = -\u221e.\n* \n* For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.\n* \n* click to show spoilers.\n* \n* Note:\n* Your solution should be in logarithmic complexity.\n* \n* Credits:Special thanks to @ts for adding this problem and creating all test cases.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/find-peak-element/\n// Author : Hao Chen\n// Date   : 2014-12-05\n\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\n\n\n\nint findPeakElement(const vector<int> &num) {\n\n    int n = num.size();\n    int low = 0;\n    int high = n - 1;\n\n    int mid = 0, v1, v2;\n\n    while ( low < high ) {\n\n        // Find the index of middle element\n        mid = low + ( high - low ) / 2;\n\n        // Compare middle element with its neighbours (if neighbours exist)\n        if ( ( mid == 0 || num[mid] > num[mid-1] ) && \n                ( mid == n-1 ||  num[mid] > num[mid+1] )  ){\n            return mid;\n        }\n\n        // If middle element is not peak and its left neighbor is greater than it\n        // then left half must have a peak element\n        if (mid >0 && num[mid-1] > num[mid]){\n            high = mid - 1;\n        // If middle element is not peak and its right neighbor is greater than it\n        // then right half must have a peak element\n        }else{\n            low = mid + 1;\n        }\n\n    }\n\n    return low;\n}\n\n\nvoid printVector(vector<int> &n) {\n    cout << \"[ \";\n    int i;\n    for(i=0; i<n.size(); i++){\n        cout << n[i] << (i==n.size()-1 ? \" ]\" : \", \");\n    }\n    cout << endl;\n}\n\nvoid test(int a[], int n) {\n    vector<int> v(a, a+n);\n    cout << \"Peak Index = \" << findPeakElement(v) << \"\\t\";\n    printVector(v);\n}\n\n\n#define TEST(a) test(a, sizeof(a)/sizeof(a[0]))\n\nint main(int argc, char**argv)\n{\n    int n0[] = {1};\n    TEST(n0);\n\n    int n1[] = {1,2};\n    TEST(n1);\n\n    int n2[] = {2,1};\n    TEST(n2);\n\n    int n3[] = {1,2,3};\n    TEST(n3);\n\n    int n4[] = {3,2,1};\n    TEST(n4);\n\n    int n5[] = {1,2,3,2};\n    TEST(n5);\n\n    int n6[] = {0,1,2,9,7,5,4,2,1};\n    TEST(n6);\n\n    int n7[] = {1,2,1,2,1};\n    TEST(n7);\n\n    int n8[] = {1,2,1,2,3,1};\n    TEST(n8);\n\n    int n9[] = {1,2,3,2,4,2,1};\n    TEST(n9);\n\n    int n10[] = {1,3,1,2,1,3,1};\n    TEST(n10);\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "bullsAndCows",
    "question": "/*************************************************************************************** \n *\n * You are playing the following Bulls and Cows game with your friend: You write a \n * 4-digit secret number and ask your friend to guess it. Each time your friend guesses\n * a number, you give a hint. The hint tells your friend how many digits are in the\n * correct positions (called \"bulls\") and how many digits are in the wrong positions\n * (called \"cows\"). Your friend will use those hints to find out the secret number.\n * \n * For example:\n * \n * Secret number:  \"1807\"\n * Friend's guess: \"7810\"\n * Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)\n * Write a function to return a hint according to the secret number and friend's guess,\n * use A to indicate the bulls and B to indicate the cows. In the above example, your\n * function should return \"1A3B\".\n * \n * Please note that both secret number and friend's guess may contain duplicate digits,\n * for example:\n * \n * Secret number:  \"1123\"\n * Friend's guess: \"0111\"\n * In this case, the 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow, and\n * your function should return \"1A1B\".\n * You may assume that the secret number and your friend's guess only contain digits,\n * and their lengths are always equal.\n * \n * Credits:\n * Special thanks to @jeantimex for adding this problem and creating all test cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/bulls-and-cows/\n// Author : Calinescu Valentin, Hao Chen\n// Date   : 2015-11-04\n\n\n \nclass Solution {\npublic:\n    string getHint(string secret, string guess) {\n        return getHint02(secret, guess);\n        return getHint01(secret, guess);\n    }\n\n    string getHint01(string secret, string guess) {\n        int appears_in_secret[10] = {0}, appears_in_guess[10] = {0}, bulls[10] = {0};\n        int total_bulls = 0, total_cows = 0;\n        for(int i = 0; i < secret.size(); i++)\n            appears_in_secret[secret[i] - '0']++;\n        for(int i = 0; i < guess.size(); i++)\n        {\n             if(secret[i] == guess[i])\n                 bulls[secret[i] - '0']++;\n             appears_in_guess[guess[i] - '0']++;\n        }\n        for(int i = 0; i <= 9; i++)\n        {\n            total_bulls += bulls[i];\n            total_cows += min(appears_in_secret[i], appears_in_guess[i]) - bulls[i];\n        }\n        return to_string(total_bulls) + \"A\" + to_string(total_cows) + \"B\";\n    }\n\n    // Another implemntation - to save more space\n    string getHint02(string secret, string guess) {\n        \n        const int digital_num = 10;\n        int secret_stat[digital_num]={0};\n        \n        int bull = 0;\n        for(int i=0; i<secret.size(); i++) {\n            //both number & location are matched, count bull\n            if ( secret[i] == guess[i] ) {\n                bull++;\n                continue;\n            }\n            //otherwise, count the unmatched digits.\n            secret_stat[secret[i]-'0']++;\n        }\n        \n        int cow = 0;\n        for(int i=0; i<guess.size(); i++) {\n            //deal with duplication - decrease the digits count if cow is found.\n            if ( secret[i] != guess[i] && secret_stat[guess[i]-'0']-- > 0 ) {\n                cow++;\n            }\n        }\n        \n        return to_string(bull) + \"A\" + to_string(cow) + \"B\";\n    }\n};\n"
  },
  {
    "question_theme": "minStack",
    "question": "/********************************************************************************** \n* \n* Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n* \n* push(x) -- Push element x onto stack.\n* \n* pop() -- Removes the element on top of the stack.\n* \n* top() -- Get the top element.\n* \n* getMin() -- Retrieve the minimum element in the stack.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/min-stack/\n// Author : Hao Chen\n// Date   : 2014-11-16\n\n\n\n#include <stdlib.h>\n#include <iostream>\nusing namespace std;\n\n//It seems C++ vector cause the Memory Limit Error, So, implement a simple one\ntemplate <typename T>\nclass Stack {\n    private:\n        T* _stack;\n        int _capacity;\n        int _top;\n    public:\n        Stack():_capacity(1),_top(-1){\n            _stack = (T*)malloc(_capacity*sizeof(T));\n        }\n\n        ~Stack(){\n            free(_stack);\n        }\n\n        void push(T x){\n            _top++;\n            if ( _top >= _capacity ){\n                //if capacity is not enough, enlarge it 5 times.\n                //Notes: why 5 times? because if you change to other(e.g. 2 times), \n                //       LeetCode system will report Run-time Error! it sucks!\n                _capacity*=5;\n                _stack = (T*)realloc(_stack, _capacity*sizeof(T));\n            }\n            _stack[_top] = x;\n        }\n\n        T pop() {\n            return top(true);\n        }\n\n        T& top(bool pop=false) {\n            if (_top>=0){\n                if (pop){\n                    return _stack[_top--];\n                }\n                return _stack[_top];\n            }\n            static T null;\n            return null;\n        }\n\n        bool empty(){\n            return (_top<0);\n        }\n        int size() {\n            return _top+1;\n        }\n        void clear(){\n            _top = -1;\n        }\n};\n\n\n\nclass MinStack {\n    private:\n        //Using a minData struct to remove the duplication in minimal stack\n        //which can save the memory.\n        struct minData{\n            int min;\n            int cnt;\n            minData():min(0), cnt(0) {}\n            minData(int m, int c):min(m),cnt(c){}\n        };\n        Stack<int> stack; //real stack store the data\n        Stack<minData> minStack; //minimal number stack store the number \n        int min; //current minial number\n\n    public:\n\n        void push(int x) {\n            if(stack.empty()){\n                min = x;\n                minStack.push(minData(x,1));\n            }else{\n                if (min >= x ){\n                    min = x;\n                    //if current minial number already pushed, then just add the reference coount.\n                    if (minStack.top().min == x){\n                        minStack.top().cnt++;\n                    }else{\n                        minStack.push(minData(x,1));\n                    }\n                }\n            }\n            stack.push(x);\n\n        }\n\n        void pop() {\n            if (stack.empty()){\n                return;\n            }\n            int x = stack.pop();\n            if (x == minStack.top().min){\n                //de-reference the count at first.\n                if (minStack.top().cnt > 1){\n                    minStack.top().cnt--;\n                }else{\n                    minStack.pop();\n                    min = minStack.top().min;\n                }\n            }\n        }\n\n        int top() {\n            return stack.top();\n        }\n\n        int getMin() {\n            return min;\n        }\n        void clear() {\n            stack.clear();\n            minStack.clear();\n        }\n\n};\n\nint main()\n{\n    cout << \"--- expected output [0, 0, 0, 2]\" << endl;\n    MinStack ms;\n    ms.push(2);\n    ms.push(0);\n    ms.push(3);\n    ms.push(0);\n\n    cout << ms.getMin() << endl;\n    ms.pop();\n    cout << ms.getMin() << endl;\n    ms.pop();\n    cout << ms.getMin() << endl;\n    ms.pop();\n    cout << ms.getMin() << endl;\n\n\n    ms.clear();\n\n    cout << \"--- expected output [2147483647 2147483646 2147483646 2147483647 2147483647 -2147483648 -2147483648 2147483647 \" << endl;\n\n    ms.push(2147483646);\n    ms.push(2147483646);\n    ms.push(2147483647);\n\n    cout << ms.top() << endl;\n    ms.pop();\n    cout << ms.getMin() << endl;\n    ms.pop();\n    cout << ms.getMin() << endl;\n    ms.pop();\n\n    ms.push(2147483647);\n    cout << ms.top() << endl;\n    cout << ms.getMin() << endl;\n    ms.push(-2147483648);\n    cout << ms.top() << endl;\n    cout << ms.getMin() << endl;\n    ms.pop();\n    cout << ms.getMin() << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "flattenBinaryTreeToLinkedList",
    "question": "/********************************************************************************** \n* \n* Given a binary tree, flatten it to a linked list in-place.\n* \n* For example,\n* Given\n* \n*          1\n*         / \\\n*        2   5\n*       / \\   \\\n*      3   4   6\n* \n* The flattened tree should look like:\n* \n*    1\n*     \\\n*      2\n*       \\\n*        3\n*         \\\n*          4\n*           \\\n*            5\n*             \\\n*              6\n* \n* \n* Hints:\n* If you notice carefully in the flattened tree, each node's right child points to \n* the next node of a pre-order traversal.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/\n// Author : Hao Chen\n// Date   : 2014-07-03\n\n\n\n\nclass Solution {\npublic:\n    void flatten(TreeNode *root) {\n        \n        vector<TreeNode*> v, stack;\n        stack.push_back(root);\n        while(stack.size()>0){\n            TreeNode* node = stack.back();\n            stack.pop_back();\n            v.push_back(node);\n            \n            if (node && node->right){\n                stack.push_back(node->right);\n            }\n            if (node && node->left){\n                stack.push_back(node->left);\n            }\n        }\n        \n        v.push_back(NULL);\n        for(int i=0; i<v.size(); i++){\n            if (v[i]){\n                v[i]->left = NULL;\n                v[i]->right = v[i+1];\n            }\n        }\n        \n    }\n};\n"
  },
  {
    "question_theme": "nextPermutation",
    "question": "/********************************************************************************** \n* \n* Implement next permutation, which rearranges numbers into the lexicographically next \n* greater permutation of numbers.\n* \n* If such arrangement is not possible, it must rearrange it as the lowest possible order \n* (ie, sorted in ascending order).\n* \n* The replacement must be in-place, do not allocate extra memory.\n* \n* Here are some examples. Inputs are in the left-hand column and its corresponding outputs \n* are in the right-hand column.\n*\n*   1,2,3 \u2192 1,3,2\n*   3,2,1 \u2192 1,2,3\n*   1,1,5 \u2192 1,5,1\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/next-permutation/\n// Author : Hao Chen\n// Date   : 2014-08-21\n\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nvoid nextPermutation(vector<int> &num) {\n\n    if(num.size()<=1) return;\n\n    for(int i=num.size()-1; i>0; i--) {\n        if (num[i-1] < num[i]){\n            int j = num.size()-1;\n            while( num[i-1] >= num[j]) {\n                //pass;\n                j--;\n            }\n            int tmp = num[j];\n            num[j] = num[i-1];\n            num[i-1] = tmp;\n            //sort works as well\n            //sort(num.begin()+i, num.end()); \n            reverse(num.begin()+i, num.end()); \n            return; \n        }\n        //edge case: 4 3 2 1\n        if (i == 1 ){\n            //sort works as well\n            //sort(num.begin(), num.end());\n            reverse(num.begin(), num.end());\n            return;\n        }\n    }\n\n}\n\nvoid printVector(vector<int> &num) {\n    for(int i=0; i<num.size(); i++) {\n        cout << num[i] << \" \";\n    } \n    cout <<endl;\n}\nbool isBeginVector(vector<int> &num) {\n    for(int i=0; i<num.size(); i++) {\n        if(num[i] != i+1) {\n            return false;\n        }\n    } \n    return true;\n}\n\nint main(int argc, char** argv)\n{\n    int n = 4;\n    if (argc>1){\n        n = atoi(argv[1]);\n    }\n    vector<int> num;\n    for(int i=1; i<=n; i++){\n        num.push_back(i);\n    }\n    \n    while(true){\n        printVector(num);\n        nextPermutation(num);\n        if(isBeginVector(num)){\n            break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "question_theme": "rangeSumQuery-Immutable",
    "question": "/*************************************************************************************** \n *\n * Given an integer array nums, find the sum of the elements between indices i and j\n * (i \u2264 j), inclusive.\n * \n * Example:\n * Given nums = [-2, 0, 3, -5, 2, -1]\n * \n * sumRange(0, 2) -> 1\n * sumRange(2, 5) -> -1\n * sumRange(0, 5) -> -3\n * Note:\n * You may assume that the array does not change.\n * There are many calls to sumRange function.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/range-sum-query-immutable/\n// Author : Calinescu Valentin, Hao Chen\n// Date   : 2015-11-10\n\n\n\nclass NumArray {\n\nprivate:\n    int size;\n    vector <long long> sums;\npublic:\n    NumArray(vector<int> &nums): size(nums.size()), sums(size+1, 0) {\n        for(int i=0; i<size; i++) {\n            sums[i+1] = sums[i] + nums[i];\n        } \n    }\n    int sumRange(int i, int j) {\n        return sums[j+1] - sums[i];\n    }\n};\n\n\n// Your NumArray object will be instantiated and called as such:\n// NumArray numArray(nums);\n// numArray.sumRange(0, 1);\n// numArray.sumRange(1, 2);\n"
  },
  {
    "question_theme": "rangeSumQuery-Mutable",
    "question": "/*************************************************************************************** \n *\n * Given an integer array nums, find the sum of the elements between indices i and j (i \n * \u2264 j), inclusive.\n * \n * The update(i, val) function modifies nums by updating the element at index i to val.\n * \n * Example:\n * \n * Given nums = [1, 3, 5]\n * \n * sumRange(0, 2) -> 9\n * update(1, 2)\n * sumRange(0, 2) -> 8\n * \n * Note:\n * \n * The array is only modifiable by the update function.\n * You may assume the number of calls to update and sumRange function is distributed \n * evenly.\n *\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/range-sum-query-mutable/\n// Author : Hao Chen\n// Date   : 2015-11-24\n\n\n\n\n// The following idea is using `Binary Index Tree`\n// There are two articles explaine this technique quite well:\n// 1) http://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/\n// 2) http://cs.stackexchange.com/questions/10538/bit-what-is-the-intuition-behind-a-binary-indexed-tree-and-how-was-it-thought-a\n\nclass NumArray {\nprivate:\n    int _sz;\n    vector<int> _nums;\n    vector<int> _sums;    \npublic:\n    NumArray(vector<int> &nums)  {\n        _sz = nums.size();\n        _nums.resize(_sz+1, 0);\n        _sums.resize(_sz+1, 0);\n        for(int i=0; i< _sz; i++) {\n            update(i, nums[i]);          \n        }\n    }\n\n    void update(int i, int val) {\n        int oldv = _nums[i+1];\n        for(int idx = i+1; idx <= _sz; idx += (idx & (-idx))  ) {\n            _sums[idx] = _sums[idx] - oldv + val;\n        }\n        _nums[i+1] = val;\n    }\n\n    int sumRange(int i, int j) {\n        return sumRange(j+1) - sumRange(i);\n    }\n    \n    int sumRange(int i) {\n        int ret = 0;\n        for(int idx=i; idx>0; idx -= (idx & (-idx)) ) {\n            ret += _sums[idx];\n        }\n        return ret;\n    }\n};\n\n\n// Your NumArray object will be instantiated and called as such:\n// NumArray numArray(nums);\n// numArray.sumRange(0, 1);\n// numArray.update(1, 10);\n// numArray.sumRange(1, 2);\n"
  },
  {
    "question_theme": "4Sum",
    "question": "/********************************************************************************** \n* \n* Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? \n* Find all unique quadruplets in the array which gives the sum of target.\n* \n* Note:\n* \n* Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a \u2264 b \u2264 c \u2264 d)\n* The solution set must not contain duplicate quadruplets.\n* \n*     For example, given array S = {1 0 -1 0 -2 2}, and target = 0.\n* \n*     A solution set is:\n*     (-1,  0, 0, 1)\n*     (-2, -1, 1, 2)\n*     (-2,  0, 0, 2)\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/4sum/\n// Author : Hao Chen\n// Date   : 2014-07-03\n\n\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int> > threeSum(vector<int> num, int target); \n\n\n\nvector<vector<int> > fourSum(vector<int> &num, int target) {\n    vector< vector<int> > result;\n    if (num.size()<4) return result;\n    sort( num.begin(), num.end() );\n    \n    for(int i=0; i<num.size()-3; i++) {\n        //skip the duplication\n        if (i>0 && num[i-1]==num[i]) continue;\n        vector<int> n(num.begin()+i+1, num.end());\n        vector<vector<int> > ret = threeSum(n, target-num[i]);\n        for(int j=0; j<ret.size(); j++){\n            ret[j].insert(ret[j].begin(), num[i]);\n            result.push_back(ret[j]);\n        }\n    }\n\n    return result; \n}\n\nvector<vector<int> > threeSum(vector<int> num, int target) {\n\n    vector< vector<int> > result;\n    //sort the array (if the qrray is sorted already, it won't waste any time)\n    sort(num.begin(), num.end());\n\n    int n = num.size();\n\n    for (int i=0; i<n-2; i++) {\n        //skip the duplication\n        if (i>0 && num[i-1]==num[i]) continue;\n        int a = num[i];\n        int low = i+1;\n        int high = n-1;\n        while ( low < high ) {\n            int b = num[low];\n            int c = num[high];\n            if (a+b+c == target) {\n                //got the soultion\n                vector<int> v;\n                v.push_back(a);\n                v.push_back(b);\n                v.push_back(c);\n                result.push_back(v);\n                // Continue search for all triplet combinations summing to zero.\n                //skip the duplication\n                while(low<n && num[low]==num[low+1]) low++;\n                while(high>0 && num[high]==num[high-1]) high--;\n                low++;\n                high--;\n            } else if (a+b+c > target) {\n                //skip the duplication\n                while(high>0 && num[high]==num[high-1]) high--;\n                high--;\n            } else{\n                //skip the duplication\n                while(low<n && num[low]==num[low+1]) low++;\n                low++;\n            }\n        }\n    }\n    return result;\n}\n\n\nint printMatrix(vector< vector<int> > &vv)\n{\n    for(int i=0; i<vv.size(); i++) {\n        cout << \"[\";\n        for(int j=0; j<vv[i].size(); j++) {\n            cout << \" \" << vv[i][j];\n        }\n        cout << \"]\" << endl;;\n    }\n}\n\n\nint main()\n{\n    int a[] = {1,0,-1,0,-2,2};\n    vector<int> n(a, a+6);\n    int t = 0;\n    vector< vector<int> > v = fourSum(n, t);\n    printMatrix(v);\n\n    n.clear();\n    int b[] = {-1,-5,-5,-3,2,5,0,4};\n    n.insert(n.begin(), b, b+8);\n    t = -7;\n    v = fourSum(n, t);\n    printMatrix(v);\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "pascalTriangle",
    "question": "/********************************************************************************** \n* \n* Given numRows, generate the first numRows of Pascal's triangle.\n* \n* For example, given numRows = 5,\n* Return\n* \n* [\n*      [1],\n*     [1,1],\n*    [1,2,1],\n*   [1,3,3,1],\n*  [1,4,6,4,1]\n* ]\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/pascals-triangle/\n// Author : Hao Chen\n// Date   : 2014-06-18\n\n\n\n#include <stdlib.h>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nvector<vector<int> > generate(int numRows) \n{\n    vector<vector<int> > pascalTriangle;\n    for (int i=0; i<numRows; i++){\n        vector<int> v;\n        if (i==0){\n            v.push_back(1);\n        } else {\n            v.push_back(1);\n            for(int j=0; j<pascalTriangle[i-1].size()-1; j++){\n                v.push_back(pascalTriangle[i-1][j] + pascalTriangle[i-1][j+1]);\n            }\n            v.push_back(1);\n        }\n        pascalTriangle.push_back(v); \n    }\n    return pascalTriangle;\n}\n\nvoid printTriangle(vector< vector<int> > pt)\n{\n\tcout << \"[\" << endl;\n    for(int i=0; i<pt.size(); i++){\n    \tfor(int space=(pt.size()-i-1); space>=0; space--){\n    \t\tcout << \" \";\n    \t}\n        cout << \"[\";\n        for(int j=0; j<pt[i].size(); j++){\n            cout << pt[i][j];\n            if(j<pt[i].size()-1){\n            \tcout << \",\";\n            }\n        }\n        cout << \"]\";\n        if(i<pt.size()-1){\n        \tcout << \",\";\n        }\n        cout << endl;\n    }\n    cout << \"]\" << endl;\n}\n\nint main(int argc, char** argv)\n{\n    int n = 3;\n    if (argc>1) {\n        n = atoi(argv[1]);\n    }\n    printTriangle(generate(n)); \n}\n"
  },
  {
    "question_theme": "eliminationGame",
    "question": "/********************************************************************************** \n * \n * There is a list of sorted integers from 1 to n. Starting from left to right, remove the first number and every other \n * number afterward until you reach the end of the list.\n * \n * Repeat the previous step again, but this time from right to left, remove the right most number and every other number \n * from the remaining numbers.\n * \n * We keep repeating the steps again, alternating left to right and right to left, until a single number remains.\n * \n * Find the last number that remains starting with a list of length n.\n * \n * Example:\n * \n * Input:\n * n = 9,\n * 1 2 3 4 5 6 7 8 9\n * 2 4 6 8\n * 2 6\n * 6\n * \n * Output:\n * 6\n**********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/elimination-game\n// Author : Hao Chen\n// Date   : 2016-09-07-\n\n\n\nclass Solution {\npublic:\n    int lastRemaining(int n) {\n        int start = 1, step = 1;\n        while (n > 1) {\n            start += step + (n-2)/2 * 2*step;\n            n /= 2;\n            step *= -2;\n        }\n        return start;\n    }\n};\n"
  },
  {
    "question_theme": "isSubsequence",
    "question": "/*************************************************************************************** \n *\n * Given a string s and a string t, check if s is subsequence of t.\n * \n * You may assume that there is only lower case English letters in both s and t. t is \n * potentially a very long (length ~= 500,000) string, and s is a short string (\n * \n * A subsequence of a string is a new string which is formed from the original string \n * by deleting some (can be none) of the characters without disturbing the relative \n * positions of the remaining characters. (ie, \"ace\" is a subsequence of \"abcde\" while \n * \"aec\" is not).\n * \n * Example 1:\n * s = \"abc\", t = \"ahbgdc\"\n * \n * Return true.\n * \n * Example 2:\n * s = \"axc\", t = \"ahbgdc\"\n * \n * Return false.\n * \n * Follow up:\n * If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to \n * check one by one to see if T has its subsequence. In this scenario, how would you \n * change your code?\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/is-subsequence/\n// Author : Hao Chen\n// Date   : 2016-09-08\n\n\n\nclass Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        if (s.size() <= 0) return true;\n        \n        int ps=0, pt=0;\n        while (pt < t.size()) {\n            if (s[ps] == t[pt]) {\n                ps++; pt++;\n                if (ps >= s.size()) return true;\n            }else {\n                pt++;\n            }\n        }\n        \n        return false;\n    }\n};\n"
  },
  {
    "question_theme": "powerOfThree",
    "question": "/*************************************************************************************** \n *\n * Given an integer, write a function to determine if it is a power of three.\n * \n *     Follow up:\n *     Could you do it without using any loop / recursion?\n * \n * Credits:Special thanks to @dietpepsi for adding this problem and creating all test \n * cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/power-of-three/\n// Author : Hao Chen\n// Date   : 2016-01-14\n\n\n\nclass Solution {\n\npublic:\n    \n    bool isPowerOfThree(int n) {\n        return isPowerOfThree03(n); //140ms\n        return isPowerOfThree02(n);//130ms\n        return isPowerOfThree01(n); //140ms\n        return isPowerOfThree_loop(n);  //136ms\n        return isPowerOfThree_recursive(n); //168ms\n    }\n    \n    bool isPowerOfThree03(int n) {\n        double logRes = log10(n)/log10(3); \n        return (logRes - int(logRes) == 0);\n    }\n    bool isPowerOfThree02(int n) {\n        return n>0 ? (1162261467%n==0) : false;\n    }\n    \n    void init(unordered_map<int, bool>& power ){\n        int p = 1;\n        power[1]=true;\n        while(1){\n            p *= 3;\n            power[p] = true;\n            if (p > INT_MAX/3) break;\n            \n        }\n    }\n    bool isPowerOfThree01(int n) {\n        static unordered_map<int, bool> power; \n        if (power.size()==0) init(power);\n        return power.find(n) != power.end();\n    }\n    \n    bool isPowerOfThree_loop(int n) {\n        for(;n>0;n /= 3){\n            if (n==1 || n==3) return true;\n            if (n%3 != 0) return false;\n        }\n        return false;\n    }\n    \n    bool isPowerOfThree_recursive(int n) {\n        if ( n == 1 || n == 3) return true;\n        if ( n==0 || n%3 != 0 ) return false;\n        return isPowerOfThree_recursive(n/3);\n    } \n};\n"
  },
  {
    "question_theme": "uniqueBinarySearchTrees",
    "question": "/********************************************************************************** \n* \n* Given n, generate all structurally unique BST's (binary search trees) that store values 1...n.\n* \n* For example,\n* Given n = 3, your program should return all 5 unique BST's shown below.\n* \n*    1         3     3      2      1\n*     \\       /     /      / \\      \\\n*      3     2     1      1   3      2\n* \n* confused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ.\n* \n* OJ's Binary Tree Serialization:\n* \n* The serialization of a binary tree follows a level order traversal, where '#' signifies \n* a path terminator where no node exists below.\n* \n* Here's an example:\n* \n*    1\n*   / \\\n*  2   3\n*     /\n*    4\n*     \\\n*      5\n* \n* The above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\". \n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/unique-binary-search-trees-ii/\n// Author : Hao Chen\n// Date   : 2014-06-25\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvector<TreeNode*> generateTrees(int low, int high);\n\nvector<TreeNode*> generateTrees(int n) {\n\n    vector<TreeNode*> v;\n    v = generateTrees(1, n);\n    return v;\n}\n\nvector<TreeNode*> generateTrees(int low, int high){\n    vector<TreeNode*> v;\n    if (low > high || low<=0 || high<=0){\n        v.push_back(NULL);\n        return v;\n    }\n    if (low==high){\n        TreeNode* node = new TreeNode(low);\n        v.push_back(node); \n        return v;\n    }\n    for (int i=low; i <= high; i++){\n        vector<TreeNode*> vleft = generateTrees(low, i-1);\n        vector<TreeNode*> vright = generateTrees(i+1, high);\n        for (int l=0; l<vleft.size(); l++){\n            for (int r=0; r<vright.size(); r++){\n                TreeNode *root = new TreeNode(i);\n                root->left = vleft[l];\n                root->right = vright[r];\n                v.push_back(root);\n            }\n        }\n    }\n    return v;\n}\n\nvoid printTree(TreeNode *root){\n    if (root == NULL){\n        printf(\"# \");\n        return;\n    }\n    printf(\"%d \", root->val );\n\n    printTree(root->left);\n    printTree(root->right);\n}\n\n\nint main(int argc, char** argv) \n{\n    int n=2;\n    if (argc>1){\n        n = atoi(argv[1]);\n    }\n    vector<TreeNode*> v = generateTrees(n);\n    for(int i=0; i<v.size(); i++){\n        printTree(v[i]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "question_theme": "deleteNodeInALinkedList",
    "question": "/********************************************************************************** \n * \n * Write a function to delete a node (except the tail) in a singly linked list, given \n * only access to that node.\n * \n * Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with \n * value 3, the linked list should become 1 -> 2 -> 4 after calling your function.\n * \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/delete-node-in-a-linked-list/\n// Author : Hao Chen\n// Date   : 2015-07-17\n\n\n\n\nclass Solution {\npublic:\n    //becasue the deleted is not the tail.\n    //So, we can move the content of next node to this one, and delete the next one \n    void deleteNode(ListNode* node) {\n        node->val = node->next->val;\n        node->next = node->next->next;\n    }\n};\n\n\n"
  },
  {
    "question_theme": "triangle",
    "question": "/********************************************************************************** \n* \n* Given a triangle, find the minimum path sum from top to bottom. \n* Each step you may move to adjacent numbers on the row below.\n* \n* For example, given the following triangle\n* \n* [\n*      [2],\n*     [3,4],\n*    [6,5,7],\n*   [4,1,8,3]\n* ]\n* \n* The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).\n* \n* Note:\n* Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/triangle/\n// Author : Hao Chen\n// Date   : 2014-06-18\n\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\n    \npublic:\n    int minimumTotal(vector<vector<int> > &triangle) {\n        vector< vector<int> > v;\n        \n        for (int i=0; i<triangle.size(); i++){\n            \n            if(i==0){\n                v.push_back(triangle[i]);\n                continue;\n            }\n            \n            vector<int> tmp;\n            \n            \n            for(int j=0; j<triangle[i].size(); j++){\n                int x, y, z;\n                x = y = z = 0x7fff;\n                if ( (j-1) >= 0){\n                    x = v[i-1][j-1];\n                }\n                if (j<v[i-1].size()) {\n                    y = v[i-1][j];\n                }\n                \n                //if ( (j+1)<v[i-1].size()) {\n                //    z = v[i-1][j+1];\n                //}\n                tmp.push_back( min(x,y,z) + triangle[i][j] );\n            }\n            \n            v.push_back(tmp);\n            \n        }\n        int min=0x7fff;\n        if (v.size() > 0){\n            vector<int> &vb = v[v.size()-1];\n            for(int i=0; i<vb.size(); i++){\n                if (vb[i] < min ){\n                    min = vb[i];\n                }\n            }\n        }\n           \n        return min;\n    }\nprivate:\n    inline int min(int x, int y, int z){\n        int n = x<y?x:y;\n        return (n<z?n:z);\n    }\n};\n\n\nint main()\n{\n    vector< vector<int> > v;\n    vector<int> i;\n    i.push_back(-1);\n    v.push_back(i);\n    \n    i.clear();\n    i.push_back(2);\n    i.push_back(3);\n    v.push_back(i);\n\n    i.clear();\n    i.push_back(1);\n    i.push_back(-1);\n    i.push_back(-3);\n    v.push_back(i);\n\n    Solution s;\n    cout << s.minimumTotal(v) << endl;;\n    \n    v.clear();\n    i.clear();\n    i.push_back(-1);\n    v.push_back(i);\n    \n    i.clear();\n    i.push_back(3);\n    i.push_back(2);\n    v.push_back(i);\n\n    i.clear();\n    i.push_back(-3);\n    i.push_back(1);\n    i.push_back(-1);\n    v.push_back(i);\n    cout << s.minimumTotal(v) << endl;;\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "longestConsecutiveSequence",
    "question": "/********************************************************************************** \n* \n* Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\n* \n* For example,\n* Given [100, 4, 200, 1, 3, 2],\n* The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.\n* \n* Your algorithm should run in O(n) complexity.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/longest-consecutive-sequence/\n// Author : Hao Chen\n// Date   : 2014-06-22\n\n\n\n//\n//  Obviously, the easist way is sort the array, however the run-time complexity is O(nlogn)\n//  \n//  If we cannot use the sort algorithm, then it seems we have to use O(n^2) solution.\n//\n//  That's fine, let's take a look the O(n^2) soultion\n//\n//      1) for each item num[i] in the array\n//      2) for loop to seach ...... num[i-2], num[i-1],  num[i]+1, num[i]+2 ......\n//  \n//  We can see, the search is really heavy, and the best data structure for seaching is HashMap.\n//  hash map is O(1) run-time complexity for seaching.\n//\n//  So, we can have the following solution by using Hash Map.\n//   \n\nclass Solution {\npublic:\n    int longestConsecutive(vector<int> &num) {\n        \n        map<int, int> m;\n        for (int i=0; i<num.size(); i++){\n            m[num[i]]=i;\n        }\n        \n        int max_seq=0; \n        for (int i=0; i<num.size(); i++){\n            int cnt=1;\n            \n            for(int n = num[i]+1;m.find(n)!=m.end();n++){\n                m.erase(m.find(n));\n                cnt++;\n                \n            }\n            for(int n = num[i]-1;m.find(n)!=m.end();n--){\n                m.erase(m.find(n));\n                cnt++;\n            }\n            if (max_seq < cnt){\n                max_seq = cnt;\n            }\n            if (m.size()==0){\n                break;\n            }\n        }\n        return max_seq;\n    }\n};\n"
  },
  {
    "question_theme": "expressionAddOperators",
    "question": "/*************************************************************************************** \n *\n * Given a string that contains only digits 0-9 and a target value, return all \n * possibilities to add binary operators (not unary) +, -, or * between the digits so \n * they evaluate to the target value.\n * \n * Examples: \n * \"123\", 6 -> [\"1+2+3\", \"1*2*3\"] \n * \"232\", 8 -> [\"2*3+2\", \"2+3*2\"]\n * \"105\", 5 -> [\"1*0+5\",\"10-5\"]\n * \"00\", 0 -> [\"0+0\", \"0-0\", \"0*0\"]\n * \"3456237490\", 9191 -> []\n * \n * Credits:Special thanks to @davidtan1890 for adding this problem and creating all \n * test cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/expression-add-operators/\n// Author : Hao Chen\n// Date   : 2016-01-16\n\n\n\n\nclass Solution {\npublic:\n    vector<string> addOperators(string num, int target) {\n        vector<string> result;\n        if (num.size() == 0) return result;\n        helper(num, target, result, \"\", 0, 0, 0, ' ');\n        return result;        \n    }\n    \n    //DFS algorithm\n    void helper(const string &num, const int target, //`num` and `target` never change\n                vector<string>& result, // the array store all of the answers\n                string solution, //the current potential answer.\n                int idx, // the current index of `num` array\n                long long val, // the current value we calculated so far\n                long long prev, // the lastest value we used for calculation, which used for operation prioirty adjustment\n                char preop ) // the latest \"+\" or \"-\" operation, which used for operation prioirty adjustment \n    {\n        \n        if (target == val && idx == num.size()){\n            result.push_back(solution);\n            return;\n        }\n        if (idx == num.size()) return;\n        \n        string n;\n        long long v=0;\n        for(int i=idx; i<num.size(); i++) {\n            //get rid of the number which start by \"0\"\n            //e.g.  \"05\" is not the case.\n            if (n==\"0\") return;\n            \n            n = n + num[i];\n            v = v*10 + num[i]-'0';\n            \n            if (solution.size()==0){ \n                // the first time for initialization\n                helper(num, target, result, n, i+1, v, 0, ' ');\n            }else{\n                // '+' or '-' needn't to adjust the priority\n                helper(num, target, result, solution + '+' + n, i+1, val+v, v, '+');\n                helper(num, target, result, solution + '-' + n, i+1, val-v, v, '-');\n                \n                //if we meet multiply operation, we need adjust the calcualtion priority\n                // e.g. if the previous value is calculated by 2+3=5, \n                //      then if we need to multipy 4, it is not 5*4, it is 2+3*4=2+12=24\n                //      we need be careful about multiply again, such as: 2+3*4*5\n                if (preop=='+') {\n                    helper(num, target, result, solution + '*' + n, i+1, (val-prev)+prev*v, prev*v, preop);\n                }else if (preop=='-'){\n                    helper(num, target, result, solution + '*' + n, i+1, (val+prev)-prev*v, prev*v, preop);\n                }else {\n                    helper(num, target, result, solution + '*' + n, i+1, val*v, v, '*');\n                }\n            }\n        }\n        \n    }\n};\n"
  },
  {
    "question_theme": "basicCalculator",
    "question": "/********************************************************************************** \n * \n * Implement a basic calculator to evaluate a simple expression string.\n * \n * The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, \n * non-negative integers and empty spaces  .\n * \n * You may assume that the given expression is always valid.\n * \n * Some examples:\n * \n * \"1 + 1\" = 2\n * \" 2-1 + 2 \" = 3\n * \"(1+(4+5+2)-3)+(6+8)\" = 23\n * \n * Note: Do not use the eval built-in library function.\n * \n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/basic-calculator/\n// Author : Hao Chen\n// Date   : 2015-06-12\n\n\n#include <stdlib.h>\n#include <ctype.h>\n#include <iostream>\n#include <string>\n#include <stack>\n#include <vector>\nusing namespace std;\n\n\n\nclass Expression \n{\n    public:\n        virtual int interpret() = 0;\n        virtual ~Expression() {};\n};\n\nclass Number: public Expression \n{\n\n    public:\n        Number(string num) { this->number = atoi(num.c_str()); }\n        ~Number() { }\n        int interpret() { return number; }\n    private:\n        int number;\n};\n\nclass Plus : public Expression \n{\n    public:\n        Plus(Expression* left, Expression* right) :leftOperand(left), rightOperand(right) { } \n        ~Plus() { delete leftOperand; delete rightOperand; }\n        int interpret() { return leftOperand->interpret() + rightOperand->interpret(); }\n    private:\n        Expression* leftOperand;\n        Expression* rightOperand;\n};\n\nclass Minus : public Expression \n{\n    public:\n        Minus(Expression* left, Expression* right) :leftOperand(left), rightOperand(right) { } \n        ~Minus() { delete leftOperand; delete rightOperand; }\n        int interpret() { return leftOperand->interpret() - rightOperand->interpret(); }\n    private:\n        Expression* leftOperand;\n        Expression* rightOperand;\n};\n\nclass Multiply : public Expression\n{\n    public:\n        Multiply(Expression* left, Expression* right) :leftOperand(left), rightOperand(right) { }\n        ~Multiply() { delete leftOperand; delete rightOperand; }\n        int interpret() { return leftOperand->interpret() * rightOperand->interpret(); }\n    private:\n        Expression* leftOperand;\n        Expression* rightOperand;\n};\n\nclass Divide : public Expression\n{\n    public:\n        Divide(Expression* left, Expression* right) :leftOperand(left), rightOperand(right) { }\n        ~Divide() { delete leftOperand; delete rightOperand; }\n        int interpret() { return leftOperand->interpret() / rightOperand->interpret(); }\n    private:\n        Expression* leftOperand;\n        Expression* rightOperand;\n};\n\nbool isOperator(const string &c) {\n    return (c == \"+\" || c == \"-\" || c == \"*\" || c == \"/\" );\n}\nbool isOperator(const char &c) {\n    return (c == '+' || c == '-' || c == '*' || c == '/'); \n}\n\nclass Evaluator : public Expression \n{\n    private:\n        Expression* syntaxTree;\n\n    public: \n        Evaluator(vector<string>& s) \n        {\n            vector<Expression*> stack;\n            for (unsigned int i=0; i < s.size(); i++) {\n                if (isOperator(s[i])) {\n                    Expression* left  = stack.back(); stack.pop_back();\n                    Expression* right = stack.back(); stack.pop_back();\n                    switch(s[i][0]) { \n                        case '+' : \n                            stack.push_back(new Plus(right, left)); break;\n                        case '-' :\n                            stack.push_back(new Minus(right, left)); break;\n                        case '*' :\n                            stack.push_back(new Multiply(right, left)); break;\n                        case '/' :\n                            stack.push_back(new Divide(right, left)); break;\n                    }\n\n                }else{                        \n                    stack.push_back(new Number(s[i]));\n                }\n            }\n            syntaxTree = stack.back();\n        }\n        ~Evaluator() {\n            delete syntaxTree; \n        }\n\n        int interpret() {\n            return syntaxTree->interpret();\n        }\n};\n\n\n\n\nvector<string> Parse(string& s){\n    vector<string> exp;\n    for(int i=0; i<s.size(); ){\n        char c = s[i];\n        string token;\n        if (c == '+' || c == '-' || c == '*' || c == '/' || c == '(' || c == ')' ) {\n            exp.push_back(token+c);\n            i++;\n            continue;\n        }\n        if ( isdigit(c) ) {\n            while( isdigit(s[i]) ) {\n                token.push_back(s[i++]);\n            }\n            exp.push_back(token);\n            continue;\n        }\n        i++;\n    }\n    return exp;\n}\n\n\nint Priority(const string &c) {\n    if (c == \"*\" || c == \"/\") {\n        return 2;\n    } else if (c== \"+\" || c == \"-\") {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nvector<string> Infix2RPN(vector<string>& infix) {\n    vector<string> rpn;\n    stack<string> s;\n\n    for(int i = 0; i < infix.size(); i++) {\n        if(isdigit(infix[i][0])) { //number\n            rpn.push_back(infix[i]);\n        } else if (infix[i] == \"(\") {\n            s.push(infix[i]);\n        } else if (infix[i] == \")\") {\n            while(!s.empty() && s.top() != \"(\") {\n                rpn.push_back(s.top());\n                s.pop();\n            }\n            s.pop();\n        }else if(isOperator(infix[i]) ){\n            while(!s.empty() && Priority(s.top()) >= Priority(infix[i])) {\n                rpn.push_back(s.top());\n                s.pop();\n            }\n            s.push(infix[i]);\n        }\n    }\n    while(!s.empty()) {\n        rpn.push_back(s.top());\n        s.pop();\n    }\n\n\n    return rpn;\n}\n\n//Design Pattern for RPN - Memory Limit Exceeded!!\nint calculate_RPN_design_pattern(string& s) {\n    vector<string> exp = Parse(s);\n    //for (int i=0; i<exp.size(); i++){\n    //    cout << exp[i] << \" \";\n    //}\n    //cout << endl;\n    exp = Infix2RPN(exp);\n    for (int i=0; i<exp.size(); i++){\n        cout << exp[i] << \" \";\n    }\n    cout << endl;\n    Evaluator sentence(exp);\n    return sentence.interpret();\n}\n\n\n\n\n//RPN evluation - Memory Limit Exceeded!!\nint calculate_RPN_evluation(string& s) {\n    vector<string> exp = Parse(s);\n    exp = Infix2RPN(exp);\n\n    stack<int> ss;\n    for(int i=0; i<exp.size(); i++) {\n        if (isdigit(exp[i][0])) { \n            ss.push(atoi(exp[i].c_str()));\n        }\n        if (exp[i]==\"+\" || exp[i]==\"-\") {\n            int rhs = ss.top(); ss.pop();\n            int lhs = ss.top(); ss.pop();\n            if (exp[i]==\"-\") rhs = -rhs;\n            ss.push(lhs + rhs);\n        }\n    }\n    return ss.top();\n}\n\n\n\n//Two stack solution - quick & dirty solution\ninline void calculate_two_stacks(stack<int>& num_stack, stack<char>& op_stack) {\n    int lhs = num_stack.top(); num_stack.pop();\n    int rhs = num_stack.top(); num_stack.pop();\n    char op = op_stack.top(); op_stack.pop();\n    if (op=='-') rhs = -rhs;\n    num_stack.push(lhs + rhs);\n}\nint calculate_two_stacks(string& s) {\n    stack<int> num_stack; //put the number\n    stack<char> op_stack; //put the operations\n\n    for(int i = s.size() - 1; i >= 0; i--){\n        if(s[i] == ')' || s[i] == '+' || s[i] == '-') {\n            op_stack.push(s[i]);\n        } else if(isdigit(s[i])){\n            string num;\n            num += s[i];\n            while(isdigit(s[i-1])){\n                num.insert(num.begin(), s[i-1]);\n                i--;\n            }\n            num_stack.push(atoi(num.c_str())); \n        } else if(s[i] == '('){\n            while(op_stack.top() != ')') {\n                calculate_two_stacks(num_stack, op_stack);\n            }\n            op_stack.pop();\n        }\n    }\n    while(!op_stack.empty()){ \n        calculate_two_stacks(num_stack, op_stack);\n    }\n    return num_stack.top();\n}\n\n\nint calculate(string s) {\n    return calculate_two_stacks(s);\n    return calculate_RPN_evluation(s);\n    return calculate_RPN_design_pattern(s);\n}\n\nint main(int argc, char** argv) {\n    string s = \" 15-(1+3)+(2+1) \";\n    if (argc >1){\n        s = argv[1];\n    } \n    cout << s << \" = \" << calculate(s) << endl;\n    cout << \"---------------\" << endl;\n    s = \"(2+4)-(6+(1+5))\";\n    cout << s << \" = \" << calculate(s) << endl;\n}\n"
  },
  {
    "question_theme": "bitwiseANDOfNumbersRange",
    "question": "/********************************************************************************** \n * \n * Given a range [m, n] where 0 \n * \n * For example, given the range [5, 7], you should return 4.\n * \n * Credits:Special thanks to @amrsaqr for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/bitwise-and-of-numbers-range/\n// Author : Hao Chen\n// Date   : 2015-06-08\n\n\n\n#include <stdlib.h>\n#include <iostream>\nusing namespace std;\n\n\nint rangeBitwiseAnd(int m, int n) {\n    int mask = 0xffffffff;\n\n    \n    while (mask != 0) {\n        if ((m & mask) == (n & mask)) {\n            break;\n        }\n        mask <<= 1;\n    }\n\n    return m & mask;\n\n}\n\nint main(int argc, char**argv) {\n    int m=5, n=7;\n    if (argc>2){\n        m = atoi(argv[1]);\n        n = atoi(argv[2]);\n    }\n    cout << \"range( \" << m << \", \" << n << \" ) = \" <<  rangeBitwiseAnd(m, n) << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "UTF8Validation",
    "question": "/*************************************************************************************** \n *\n * A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:\n * \n * For 1-byte character, the first bit is a 0, followed by its unicode code.\n * For n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by \n * n-1 bytes with most significant 2 bits being 10.\n * \n * This is how the UTF-8 encoding would work:\n * \n *    Char. number range  |        UTF-8 octet sequence\n *    --------------------+---------------------------------------------\n *    0000 0000-0000 007F | 0xxxxxxx\n *    0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n *    0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n *    0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n * \n * Given an array of integers representing the data, return whether it is a valid utf-8 \n * encoding.\n * \n * Note:\n * The input is an array of integers. Only the least significant 8 bits of each integer \n * is used to store the data. This means each integer represents only 1 byte of data.\n * \n * Example 1:\n * \n * data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 \n * 00000001.\n * \n * Return true.\n * It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n * \n * Example 2:\n * \n * data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 \n * 00000100.\n * \n * Return false.\n * The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\n * The next byte is a continuation byte which starts with 10 and that's correct.\n * But the second continuation byte does not start with 10, so it is invalid.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/utf-8-validation/\n// Author : Hao Chen\n// Date   : 2016-09-08\n\n\n\n\nclass Solution {\npublic:\n    bool validUtf8(vector<int>& data) {\n        int i = 0;\n        while ( i < data.size() ) {\n            if ( (data[i] & 0x80) == 0 ){\n                i++;\n                continue;\n            }\n            \n            int len = 0;\n            if ( (data[i] & 0xE0) == 0xC0 ) { // checking 110xxxxx\n                len = 2;\n            }else if ( (data[i] & 0xF0) == 0xE0) { // checking 1110xxxx\n                len = 3;\n            }else if ( (data[i] & 0xF8) == 0xF0) { // checking 11110xxx\n                len = 4;\n            }else {\n                return false;\n            }\n            \n            \n            for (int j=i+1; j < i+len; j++) { //checking 10xxxxxx\n                if ( (data[j] & 0xC0) != 0x80 ) {\n                    return false;\n                }\n            }\n            \n            i += len ;\n            \n            if (i > data.size()) {\n                return false;\n            }\n            \n        }\n        return true;\n    }\n};\n"
  },
  {
    "question_theme": "countAndSay",
    "question": "/********************************************************************************** \n* \n* The count-and-say sequence is the sequence of integers beginning as follows:\n* 1, 11, 21, 1211, 111221, ...\n* \n* 1 is read off as \"one 1\" or 11.\n* 11 is read off as \"two 1s\" or 21.\n* 21 is read off as \"one 2, then one 1\" or 1211.\n* \n* Given an integer n, generate the nth sequence.\n* \n* Note: The sequence of integers will be represented as a string.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/count-and-say/\n// Author : Hao Chen\n// Date   : 2014-07-03\n\n\n\n#include <stdlib.h>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstring vecToStr(vector<int> v) {\n    stringstream ss;\n    for (int i=0; i<v.size(); i++) {\n        ss << v[i]; \n    }\n    return ss.str();\n}\n\nvector<int> getNext(vector<int>& v) {\n    int cnt=0;\n    int val=0;\n    vector<int> ret;\n    for(int i=0; i<v.size(); i++){\n        if (i==0){\n            val = v[i];\n            cnt = 1;\n            continue;\n        }\n        if (v[i] == val){\n            cnt++;\n        }else{\n            ret.push_back(cnt); \n            ret.push_back(val); \n            val = v[i];\n            cnt = 1;\n        }\n    }\n    if (cnt>0 && val>0){\n        ret.push_back(cnt); \n        ret.push_back(val); \n    }\n    return ret;\n}\n    \n\nstring countAndSay(int n) {\n    if (n<=0) return \"\";\n    if (n==1) return \"1\";\n\n    string s;\n    vector<int> v;\n    v.push_back(1);\n    for(int i=2; i<=n; i++){\n       v = getNext(v);\n       //s = s + \", \" +vecToStr(v);\n    }\n    s = vecToStr(v);\n    return s;\n}\n\n\nint main(int argc, char** argv)\n{\n    int n = 4;\n    if (argc>1){\n        n = atoi(argv[1]);\n    }\n    cout << countAndSay(n) << endl;\n    \n    return 0;\n}\n"
  },
  {
    "question_theme": "sortColors",
    "question": "/********************************************************************************** \n* \n* Given an array with n objects colored red, white or blue, sort them so that objects of \n* the same color are adjacent, with the colors in the order red, white and blue.\n* \n* Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\n* \n* Note:\n* You are not suppose to use the library's sort function for this problem.\n* \n* Follow up:\n*  > A rather straight forward solution is a two-pass algorithm using counting sort.\n*  > First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array \n*    with total number of 0's, then 1's and followed by 2's.\n*  > Could you come up with an one-pass algorithm using only constant space?\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/sort-colors/\n// Author : Hao Chen\n// Date   : 2014-06-25\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n\nvoid swap(int*a, int*b)\n{\n    int t;\n    t=*a;\n    *a = *b;\n    *b = t;\n}\nvoid sortColors(int a[], int n) {\n    int zero=0, two=n-1;\n    for(int i=0; i<=two; i++ ){\n        if (a[i]==0){\n            swap(&a[zero], &a[i]);\n            zero++;\n        }\n        if (a[i]==2){\n            swap(&a[two], &a[i]);\n            two--; \n            i--;\n        }\n    }\n    \n}\n\nvoid printArray(int a[], int n) {\n    for(int i=0; i<n; i++){\n        printf(\"%d \", a[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main(int argc, char** argv)\n{\n    int n = 7;\n    if (argc>1)\n        n = atoi(argv[1]);\n\n    srand(time(NULL));\n\n    int *a = new int[n];\n    for (int i=0; i<n; i++){\n        a[i] = random()%3;\n    }\n    printArray(a, n);\n    sortColors(a, n);\n    printArray(a, n);\n\n    delete[] a;\n}\n\n"
  },
  {
    "question_theme": "reverseBits",
    "question": "/********************************************************************************** \n* \n* Reverse bits of a given 32 bits unsigned integer.\n* \n* For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), \n* return 964176192 (represented in binary as 00111001011110000010100101000000).\n* \n* Follow up:\n* If this function is called many times, how would you optimize it?\n* \n* Related problem: Reverse Integer\n* \n* Credits:Special thanks to @ts for adding this problem and creating all test cases.\n*               \n**********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/reverse-bits/\n// Author : Hao Chen\n// Date   : 2015-03-30\n\n\n\n\n\nclass Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        uint32_t ret=0;\n        for(int i=0; i<32; i++) {\n            ret = (ret*2) + (n & 0x1);\n            n /=2 ;\n        }\n        return ret;\n    }\n};\n"
  },
  {
    "question_theme": "flattenNestedListIterator",
    "question": "/*************************************************************************************** \n *\n * Given a nested list of integers, implement an iterator to flatten it.\n * \n * Each element is either an integer, or a list -- whose elements may also be integers \n * or other lists.\n * \n * Example 1:\n * Given the list [[1,1],2,[1,1]],\n * \n * By calling next repeatedly until hasNext returns false, the order of elements \n * returned by next should be: [1,1,2,1,1].\n * \n * Example 2:\n * Given the list [1,[4,[6]]],\n * \n * By calling next repeatedly until hasNext returns false, the order of elements \n * returned by next should be: [1,4,6].\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/flatten-nested-list-iterator/\n// Author : Hao Chen\n// Date   : 2016-05-30\n\n\n\n\nclass NestedIterator {\nprivate:\n    vector<int> v;\n    int index;\n    void flatten(vector<NestedInteger> &nestedList) {\n        for (auto item : nestedList){\n            if (item.isInteger()){\n                v.push_back( item.getInteger() );\n            }else{\n                flatten( item.getList() );\n            }\n        }\n    }\npublic:\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        flatten(nestedList);\n        index = 0;\n    }\n\n    int next() {\n        return v[index++];\n    }\n\n    bool hasNext() {\n        return (index < v.size() );\n    }\n};\n\n\n"
  },
  {
    "question_theme": "houseRobber",
    "question": "/********************************************************************************** \n * \n * You are a professional robber planning to rob houses along a street. Each house has \n * a certain amount of money stashed, the only constraint stopping you from robbing \n * each of them is that adjacent houses have security system connected and it will \n * automatically contact the police if two adjacent houses were broken into on the same night.\n * \n * Given a list of non-negative integers representing the amount of money of each house, \n * determine the maximum amount of money you can rob tonight without alerting the police.\n * \n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/house-robber/\n// Author : Hao Chen\n// Date   : 2015-04-07\n\n\n\n#include <time.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\nusing namespace std;    \n\nint rob1(vector<int> &money) {\n\n    int n = money.size();\n    if (n==0) return 0;\n\n    vector<int> dp(n, 0);\n    if (n>=1) dp[0] = money[0];\n    if (n>=2) dp[1] = max(money[0], money[1]);\n\n    for (int i=2; i<n; i++){\n        dp[i] = max(dp[i-1], dp[i-2] + money[i]);\n    }\n    return dp[n-1];\n}\n\n\nint rob2(vector<int> &money) {\n    int n2=0; // dp[i-2];\n    int n1=0; // dp[i-1];\n\n    for (int i=0; i<money.size(); i++){\n        int current = max(n1, n2 + money[i]);\n        n2 = n1;\n        n1 = current;\n    }\n    return n1;\n}\n\nint rob(vector<int> &num) {\n    if (rand()%2)\n        return rob1(num);\n    return rob2(num);\n}\n\nvoid printVector( vector<int> &v ){\n    cout << '[' ;\n    for(int i=0; i<v.size(); i++){\n        cout << v[i] << (i==v.size()-1 ? \" \" :\", \");\n    }\n    cout << ']' << endl;\n}\n\nint main(int argc, char** argv) {\n    srand(time(0));\n    vector<int> money;\n    if (argc>1){\n        for (int i=1; i<argc; i++) {\n            money.push_back(atoi(argv[i]));\n        }\n    }else{\n        money.push_back(2);\n        money.push_back(1);\n        money.push_back(3);\n        money.push_back(4);\n    }\n\n    printVector(money);\n    cout << rob(money) << endl;\n}\n"
  },
  {
    "question_theme": "reverseInteger",
    "question": "/********************************************************************************** \n* \n* Reverse digits of an integer.\n* \n* Example1: x =  123, return  321\n* Example2: x = -123, return -321\n* \n* \n* Have you thought about this?\n* \n* Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!\n* \n* > If the integer's last digit is 0, what should the output be? ie, cases such as 10, 100.\n* \n* > Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, \n*   then the reverse of 1000000003 overflows. How should you handle such cases?\n* \n* > Throw an exception? Good, but what if throwing an exception is not an option? \n*   You would then have to re-design the function (ie, add an extra parameter).\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/reverse-integer/\n// Author : Hao Chen\n// Date   : 2014-06-18\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n//Why need the INT_MIN be defined like that?\n//Please take a look: \n//  http://stackoverflow.com/questions/14695118/2147483648-0-returns-true-in-c\n#define INT_MAX     2147483647\n#define INT_MIN     (-INT_MAX - 1)\nint reverse(int x) {\n    int y=0;\n    int n;\n    while( x != 0){\n        n = x%10;\n        //Checking the over/underflow.\n        //Actually, it should be y>(INT_MAX-n)/10, but n/10 is 0, so omit it.\n        if (y > INT_MAX/10 || y < INT_MIN/10){\n             return 0;\n        }\n        y = y*10 + n;\n        x /= 10;\n    }\n    return y;\n}\n\n#define TEST(n, e)  printf(\"%12d  =>  %-12d    %s!\\n\",  n, reverse(n),  e == reverse(n)?\"passed\":\"failed\")\n\nint main(int argc, char**argv)\n{\n    //basic cases\n    TEST(  123,  321);\n    TEST( -123, -321);\n    TEST( -100,   -1);\n    TEST( 1002, 2001);\n    //big integer\n    TEST( 1463847412,  2147483641);\n    TEST(-2147447412, -2147447412);\n    TEST( 2147447412,  2147447412);\n    //overflow\n    TEST( 1000000003, 0);\n    TEST( 2147483647, 0);\n    TEST(-2147483648, 0);\n    //customized cases\n    if (argc<2){\n        return 0;\n    }\n    printf(\"\\n\");\n    for (int i=1; i<argc; i++) {\n        int n = atoi(argv[i]); \n        printf(\"%12d  =>  %-12d    %s!\\n\",  n, reverse(n), reverse(reverse(n))==n ? \"passed\":\"failed\");\n    }\n    return 0;\n}\n"
  },
  {
    "question_theme": "binaryTreeMaximumPathSum",
    "question": "/********************************************************************************** \n* \n* Given a binary tree, find the maximum path sum.\n* \n* The path may start and end at any node in the tree.\n* \n* For example:\n* Given the below binary tree,\n* \n*        1\n*       / \\\n*      2   3\n* \n* Return 6.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/binary-tree-maximum-path-sum/\n// Author : Hao Chen\n// Date   : 2014-10-10\n\n\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\n//The solution is quite simple can be explained by itself\nint maxPathSum(TreeNode *root, int& maxSum ) {\n\n    if (NULL == root) return 0;\n\n    //get the maxPathSum for both left and right branch\n    int left  = maxPathSum(root->left,  maxSum);\n    int right = maxPathSum(root->right, maxSum);\n\n    // The max sum could be one of the following situations:\n    //    1) root + left\n    //    2) root + right\n    //    3) root\n    //    4) root + left + right   \n    //\n    // And the whole function need to return the the max of 1) 2) 3) \n    int val = root->val;\n    int maxBranch = left > right ? max(left + val, val) : max(right + val, val);\n    int m = max(left + right + val, maxBranch);\n\n    maxSum = max(maxSum, m);\n\n    return maxBranch;\n}\n\nint maxPathSum(TreeNode *root) {\n    #define INT_MIN     (-2147483647 - 1)\n    int maxSum = INT_MIN;\n    maxPathSum(root, maxSum);\n    return maxSum;\n}\n\nint main()\n{\n    TreeNode root(1);\n    TreeNode left(2);\n    TreeNode right(3);\n    root.left = &left;\n    root.right = &right;\n    cout << maxPathSum(&root) << endl; \n    return 0;\n}\n"
  },
  {
    "question_theme": "editDistance",
    "question": "/********************************************************************************** \n* \n* Given two words word1 and word2, find the minimum number of steps required to \n* convert word1 to word2. (each operation is counted as 1 step.)\n* \n* You have the following 3 operations permitted on a word:\n* \n* a) Insert a character\n* b) Delete a character\n* c) Replace a character\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/edit-distance/\n// Author : Hao Chen\n// Date   : 2014-08-22\n\n\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\n\nint min(int x, int y, int z) {\n    return std::min(x, std::min(y,z));\n}\n\nint minDistance(string word1, string word2) {\n    int n1 = word1.size();     \n    int n2 = word2.size();     \n    if (n1==0) return n2;\n    if (n2==0) return n1;\n    vector< vector<int> > m(n1+1, vector<int>(n2+1));\n    for(int i=0; i<m.size(); i++){\n        m[i][0] = i;\n    }\n    for (int i=0; i<m[0].size(); i++) {\n        m[0][i]=i;\n    }\n\n    //Dynamic Programming\n    int row, col;\n    for (row=1; row<m.size(); row++) {\n        for(col=1; col<m[row].size(); col++){\n            if (word1[row-1] == word2[col-1] ){\n                m[row][col] = m[row-1][col-1];\n            }else{\n                int minValue = min(m[row-1][col-1], m[row-1][col],  m[row][col-1]);\n                m[row][col] = minValue + 1;\n            }\n        }\n    }\n\n    return m[row-1][col-1];\n}\n\n\nint main(int argc, char**argv)\n{\n    string word1=\"abb\", word2=\"abccb\";\n    if (argc>2){\n        word1 = argv[1];\n        word2 = argv[2];\n    }\n\n    int steps = minDistance(word1, word2);\n\n    cout << word1 << \", \" << word2 << \" : \" << steps << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "sameTree",
    "question": "/********************************************************************************** \n* \n* Given two binary trees, write a function to check if they are equal or not.\n* \n* Two binary trees are considered equal if they are structurally identical and the nodes have the same value.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/same-tree/\n// Author : Hao Chen\n// Date   : 2014-06-27\n\n\n\n\nclass Solution {\npublic:\n    Solution(){\n        srand(time(NULL));\n    }\n    bool isSameTree(TreeNode *p, TreeNode *q) {\n        if (random()%2){\n            return isSameTree1(p, q);\n        }\n        return isSameTree2(p, q);\n    }\n    \n    bool isSameTree1(TreeNode *p, TreeNode *q) {\n        if(!p && !q) return true;  \n        if(!p || !q) return false;  \n        return (p->val == q->val) &&  \n                isSameTree(p->left, q->left) &&   \n                isSameTree(p->right, q->right);\n    }\n    \n    bool isSameTree2(TreeNode *p, TreeNode *q) {\n        \n        queue<TreeNode*> q1, q2;\n        q1.push(p);\n        q2.push(q);\n        while (q1.size()>0 && q2.size()>0 ){\n            TreeNode* p1 = q1.front();\n            q1.pop();\n            TreeNode* p2 = q2.front();\n            q2.pop();\n            if (!p1 && !p2) continue;\n            if (!p1 || !p2)  return false;\n\n            if ( p1->val != p2->val) {\n                return false;\n            }\n\n            q1.push(p1->left);\n            q2.push(p2->left);\n\n            q1.push(p1->right);\n            q2.push(p2->right);\n\n        }\n        return true;\n    }\n};\n"
  },
  {
    "question_theme": "nimGame",
    "question": "/*************************************************************************************** \n *\n * You are playing the following Nim Game with your friend: There is a heap of stones \n * on the table, each time one of you take turns to remove 1 to 3 stones. The one who \n * removes the last stone will be the winner. You will take the first turn to remove \n * the stones.\n * \n * Both of you are very clever and have optimal strategies for the game. Write a \n * function to determine whether you can win the game given the number of stones in the \n * heap.\n * \n * For example, if there are 4 stones in the heap, then you will never win the game: no \n * matter 1, 2, or 3 stones you remove, the last stone will always be removed by your \n * friend.\n * \n *   If there are 5 stones in the heap, could you figure out a way to remove the stones \n * such that you will always be the winner? \n * \n * Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating \n * all test cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/nim-game/\n// Author : Calinescu Valentin\n// Date   : 2015-10-19\n\n\n\n\n\n\n\nclass Solution {\npublic:\n    bool canWinNim(int n) {\n        return !(n % 4 == 0);\n    }\n};\n"
  },
  {
    "question_theme": "maximumDepthOfBinaryTree",
    "question": "/********************************************************************************** \n* \n* Given a binary tree, find its maximum depth.\n* \n* The maximum depth is the number of nodes along the longest path from the root node \n* down to the farthest leaf node.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/maximum-depth-of-binary-tree/\n// Author : Hao Chen\n// Date   : 2014-06-21\n\n\n\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode *root) {\n        if (root==NULL){\n            return 0;\n        }\n        if (!root->left && !root->right){\n            return 1;\n        }\n        int left=1, right=1;\n        if (root->left){\n            left += maxDepth(root->left);\n        }\n        if (root->right){\n            right += maxDepth(root->right);\n        }\n        return left>right?left:right;\n    }\n    \n};\n\nclass Solution2 {\npublic:\n    int maxDepth(TreeNode *root) {\n        if (root==NULL) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};\n"
  },
  {
    "question_theme": "countCompleteTreeNodes",
    "tree_node": "// Source : https://leetcode.com/problems/count-complete-tree-nodes/\n// Author : Hao Chen\n// Date   : 2015-06-12\n\n\n\n\n\nclass Solution {\npublic:\n    //return -1 if it is not.\n    int isCompleteTree(TreeNode* root) {\n        if (!root) return 0;\n\n        int cnt = 1;\n        TreeNode *left = root, *right = root;\n        for(; left && right; left=left->left, right=right->right) {\n            cnt *= 2;\n        }\n      \n        if (left!=NULL || right!=NULL) {\n            return -1;\n        }\n        return cnt-1;\n    }\n\n    int countNodes(TreeNode* root) {\n        int cnt = isCompleteTree(root);\n        if (cnt != -1) return cnt;\n        int leftCnt = countNodes(root->left);\n        int rightCnt = countNodes(root->right);\n        return leftCnt + rightCnt + 1;\n    }\n};\n"
  },
  {
    "question_theme": "backspaceStringCompare",
    "question": "/*************************************************************************************** \n *\n * Given two strings S and T, return if they are equal when both are typed into empty \n * text editors. # means a backspace character.\n * \n * \n * Example 1:\n * \n * \n * Input: S = \"ab#c\", T = \"ad#c\"\n * Output: true\n * Explanation: Both S and T become \"ac\".\n * \n * \n * \n * Example 2:\n * \n * \n * Input: S = \"ab##\", T = \"c#d#\"\n * Output: true\n * Explanation: Both S and T become \"\".\n * \n * \n * \n * Example 3:\n * \n * \n * Input: S = \"a##c\", T = \"#a#c\"\n * Output: true\n * Explanation: Both S and T become \"c\".\n * \n * \n * \n * Example 4:\n * \n * \n * Input: S = \"a#c\", T = \"b\"\n * Output: false\n * Explanation: S becomes \"c\" while T becomes \"b\".\n * \n * \n * Note:\n * \n * \n * \t1 <= S.length <= 200\n * \t1 <= T.length <= 200\n * \tS and T only contain lowercase letters and '#' characters.\n * \n * \n * Follow up:\n * \n * \n * \tCan you solve it in O(N) time and O(1) space?\n * \n * \n * \n * \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/backspace-string-compare/description/\n// Author : Hao Chen\n// Date   : 2018-06-29\n\n\n\nclass Solution {\nprivate:    \n    void removeBackspaces(string &s) {\n        int i = 0;\n        for(int i=0; i<s.size(); i++) {\n            if (s[i] == '#') {\n                int backSteps = i>0 ? 2 : 1;\n                s.erase(i-backSteps + 1, backSteps);\n                i -= backSteps;\n            } \n        }\n    }\n    \npublic:\n    bool backspaceCompare(string S, string T) {\n        removeBackspaces(S);\n        removeBackspaces(T);\n        return S == T;\n    }\n};\n"
  },
  {
    "question_theme": "maximumAverageSubarray",
    "question": "/*************************************************************************************** \n *\n * \n * Given an array consisting of n integers, find the contiguous subarray of given \n * length k that has the maximum average value. And you need to output the maximum \n * average value.\n * \n * \n * Example 1:\n * \n * Input: [1,12,-5,-6,50,3], k = 4\n * Output: 12.75\n * Explanation: aximum average is (12-5-6+50)/4 = 51/4 = 12.75\n * \n * \n * \n * Note:\n * \n * 1 k n \n * Elements of the given array will be in the range [-10,000, 10,000].\n * \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/maximum-average-subarray-i/description/\n// Author : Hao Chen\n// Date   : 2018-04-19\n\n\n\nclass Solution {\npublic:\n    double findMaxAverage(vector<int>& nums, int k) {\n        int sum=0;\n        for(int i=0; i<k; i++ ) {\n            sum += nums[i];\n        }\n        \n        int s = sum;\n        for (int i=k; i< nums.size(); i++) {\n            s += nums[i];\n            s -= nums[i-k];\n            \n            if (s > sum) {\n                sum = s;\n            }\n        }\n        return (double)sum/k;\n    }\n};\n\n"
  },
  {
    "question_theme": "swapNodesInPairs",
    "question": "/********************************************************************************** \n* \n* Given a linked list, swap every two adjacent nodes and return its head.\n* \n* For example,\n* Given 1->2->3->4, you should return the list as 2->1->4->3.\n* \n* Your algorithm should use only constant space. You may not modify the values in the list, \n* only nodes itself can be changed.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/swap-nodes-in-pairs/\n// Author : Hao Chen\n// Date   : 2014-06-22\n\n\n\n\nclass Solution {\npublic:\n    Solution(){\n        srand(time(NULL));\n    }\n    \n    ListNode *swapPairs(ListNode *head) {\n        if(random()%2){\n            return swapPairs1(head);\n        }\n        return swapPairs2(head);\n    }\n    \n    ListNode *swapPairs1(ListNode *head) {\n        for (ListNode *p = head; p && p->next; p = p->next->next) {\n            int n = p->val;\n            p->val = p->next->val;\n            p->next->val = n;\n        }\n        return head;\n    }\n     \n    ListNode *swapPairs2(ListNode *head) {\n        ListNode *h = NULL;\n        //using `*p` to traverse the linked list\n        for (ListNode *p = head; p && p->next; p = p->next) {\n            //`n` is `p`'s next node, and swap `p` and `n` physcially\n            ListNode *n = p->next;\n            p->next = n->next;\n            n->next = p;\n            //using `h` as `p`'s previous node\n            if (h){\n                h->next = n;\n            }\n            h=p;\n            \n            //determin the really 'head' pointer\n            if (head == p){\n                head = n;\n            }\n        }\n        \n        return head;\n    }\n};\n"
  },
  {
    "question_theme": "combinationSum",
    "question": "/********************************************************************************** \n* \n* Given a collection of candidate numbers (C) and a target number (T), find all \n* unique combinations in C where the candidate numbers sums to T.\n* \n* Each number in C may only be used once in the combination.\n* \n* Note:\n* \n* > All numbers (including target) will be positive integers.\n* > Elements in a combination (a1, a2, \u2026 , ak) must be in non-descending order. \n*   (ie, a1 \u2264 a2 \u2264 \u2026 \u2264 ak).\n* > The solution set must not contain duplicate combinations.\n* \n* For example, given candidate set 10,1,2,7,6,1,5 and target 8, \n* A solution set is: \n* [1, 7] \n* [1, 2, 5] \n* [2, 6] \n* [1, 1, 6] \n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/combination-sum-ii/\n// Author : Hao Chen\n// Date   : 2014-07-19\n\n\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nvoid combinationSumHelper(vector<int> &candidates, int start, int target, vector<int> &solution, vector< vector<int> > &result) {\n    if (target<0){\n        return;\n    }\n    if (target==0){\n        result.push_back(solution);\n        return;\n    }\n    for(int i=start; i<candidates.size(); i++){\n        //skip duplicates\n        int n = candidates[i];\n        if (i>start && candidates[i] == candidates[i-1]) {\n            continue;\n        }\n        solution.push_back(n);\n        combinationSumHelper(candidates, i+1, target - n, solution, result);\n        solution.pop_back();\n    }\n}\n\nvector<vector<int> > combinationSum2(vector<int> &candidates, int target) {\n    vector< vector<int> > result;\n    if (candidates.size()<=0){\n        return result;\n    }\n    sort(candidates.begin(), candidates.end());\n    \n    vector<int> solution;\n    combinationSumHelper(candidates, 0, target, solution, result);\n\n    return result;\n}\n\nvoid printMatrix(vector< vector<int> > &vv)\n{\n    for(int i=0; i<vv.size(); i++) {\n        cout << \"[\";\n        for(int j=0; j<vv[i].size(); j++) {\n            cout << \" \" << vv[i][j];\n        }\n        cout << \"]\" << endl;;\n    }\n}\n\nvoid printArray(vector<int> &v)\n{\n    cout << \"{\";\n    for(int i=0; i<v.size(); i++) {\n        cout << \" \" << v[i];\n    }\n    cout << \"}\" << endl;\n}\n\nvoid test(int a[], int len, int target)\n{\n    vector<int> v(a, a+len);\n    cout << \"array  = \";\n    printArray(v);\n    cout << \"target = \" << target << endl;\n\n    vector< vector<int> > vv = combinationSum2(v, target);\n    printMatrix(vv);\n}\n\nint main(int argc, char** argv)\n{\n    #define TEST(a, t) test(a, sizeof(a)/sizeof(int), target)\n    int a[] = {4,2,3,3,5,7};\n    int target = 7;\n    TEST(a, target);\n\n    int b[] = {10,1,2,7,6,1,5};\n    target = 8;\n    TEST(b, target);\n\n    int c[] = {2,2,2};\n    target = 2;\n    TEST(c, target);\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "maximumGap",
    "question": "/********************************************************************************** \n * \n * Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\n * \n * Try to solve it in linear time/space.\n * \n * Return 0 if the array contains less than 2 elements.\n * \n * You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.\n * \n * Credits:Special thanks to @porker2008 for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/maximum-gap/\n// Author : Hao Chen\n// Date   : 2014-12-17\n\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint maximumGap(vector<int> &num) {\n\n    if (num.size() < 2) return 0;\n\n    //find the max & min element\n    int min=num[0], max=num[0];\n    for(int i=1; i<num.size(); i++){\n        min = min > num[i] ? num[i] : min;\n        max = max < num[i] ? num[i] : max;\n    }\n\n    //Divide the interval [min, max] into n \"buckets\" of equal size = (max -min)/n\n    int bucket_size = (max - min)/num.size() + 1;\n\n    //For each of the remaining n-2 numbers, determin in which bucket it falls .\n    //The number num[i] belongs to the kth bucket B[k] if and only if (num[i]-min)/m = k-1\n\n    vector< vector<int> > buckets ( (max-min)/bucket_size + 1);\n    //For each bucket B[k], compute its max & min among the numbers which falls in B[k].\n    //if the bucket is empty, remain it nothing.\n    //if the bucket has one number, make this number as both max & min \n    for(int i=0; i<num.size(); i++){\n        int idx = (num[i] - min) / bucket_size ;\n        if (buckets[idx].empty()){\n            buckets[idx].push_back(num[i]);\n            buckets[idx].push_back(num[i]);\n        }else{\n            buckets[idx][0] = buckets[idx][0] > num[i] ? num[i] : buckets[idx][0];\n            buckets[idx][1] = buckets[idx][1] < num[i] ? num[i] : buckets[idx][1];\n        }\n    }\n\n    //calculate the max gap\n    int maxGap = 0;\n    int prev = 0;\n    for (int i = 1; i < buckets.size(); i++) {\n        if (buckets[i].empty()) continue;\n        int gap = buckets[i][0] - buckets[prev][1];\n        maxGap = maxGap > gap ? maxGap : gap;\n        prev = i;\n    }\n    return maxGap;\n}\n\nint main()\n{\n    //int a[] = {3, 6, 19, 1};\n    int a[] = {1,1,1,1,1,5,5,5,5,5};\n    vector<int> num(a, a+sizeof(a)/sizeof(a[0]));\n    cout << maximumGap(num) << endl;\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "lowestCommonAncestorOfABinarySearchTree",
    "question": "/********************************************************************************** \n * \n * Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given \n * nodes in the BST.\n * \n * According to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is \n * defined between two nodes v and w as the lowest node in T that has both v and w as \n * descendants (where we allow a node to be a descendant of itself).\u201d\n * \n *         _______6______\n *        /              \\\n *     ___2__          ___8__\n *    /      \\        /      \\\n *    0      _4       7       9\n *          /  \\\n *          3   5\n * \n * For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example \n * is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according \n * to the LCA definition.\n *               \n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\n// Author : Hao Chen\n// Date   : 2015-07-17\n\n\n\n\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n\n        while(root) {\n            if (p->val > root->val && q->val > root->val) {\n                root = root->right;\n                continue;\n            }\n            if (p->val < root->val && q->val < root->val) {\n                root = root->left;\n                continue;\n            }\n            return root;\n            \n        }\n        return NULL;\n    }\n};\n"
  },
  {
    "question_theme": "singleNumber",
    "question": "/********************************************************************************** \n* \n* Given an array of integers, every element appears three times except for one. Find that single one.\n* \n* Note:\n* Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/single-number-ii/\n// Author : Hao Chen\n// Date   : 2014-06-17\n\n\n\nclass Solution {\npublic:\n    Solution(){\n        srand(time(0));\n    }\n    \n    //random invoker\n    int singleNumber(int A[], int n) {\n        if (rand()%2){\n            return singleNumber_1(A, n);\n        }\n        return singleNumber_2(A, n);\n    }\n\n    \n    int singleNumber_1(int A[], int n) {\n        int count[32] = {0};\n        int result = 0;\n        for (int i = 0; i < 32; i++) {\n            for (int j = 0; j < n; j++) {\n                if ((A[j] >> i) & 1) {\n                    count[i]++;\n                }\n            }\n            result |= ((count[i] % 3) << i);\n        }\n        return result;\n    }\n\n\n    \n    int singleNumber_2(int A[], int n) {\n        int ones = 0, twos = 0, threes = 0;\n        for (int i = 0; i < n; i++) {\n            // `ones & A[i]` the result is the bitmask which the bits appeared twice\n            twos |= ones & A[i]; \n            // XOR means remove the bit which appeared twice int `ones` \n            ones ^= A[i];\n            // count the `three`\n            threes = ones & twos;\n            // clear the `ones` and `twos` if the i-th bit had appeared three times.\n            ones &= ~threes;\n            twos &= ~threes;\n        }\n        return ones;\n    }\n\n};\n"
  },
  {
    "question_theme": "wiggleSort",
    "question": "/*************************************************************************************** \n *\n * Given an unsorted array nums, reorder it such that\n *     nums[0]  nums[2] .\n * \n *     Example:\n *     (1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6]. \n *     (2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2].\n * \n *     Note:\n *     You may assume all input has valid answer.\n * \n *     Follow Up:\n *     Can you do it in O(n) time and/or in-place with O(1) extra space?\n * \n * Credits:Special thanks to @dietpepsi for adding this problem and creating all test \n * cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/wiggle-sort-ii/\n// Author : Hao Chen\n// Date   : 2017-01-02\n\n\n\nclass Solution {\n\npublic:\n    //\n    // Solution - O(N*logN)\n    // --------------------\n    // 1) Sorting the array with descending order\n    //\n    // 2) Split the sorted array into two parts,\n    //    and insert the 2nd half array into the 1st half array\n    //\n    //    For example: [ 9 8 7 6 5  4 3 2 1 0  ]\n    //\n    //  \n    //        1st Large half:    . 9 . 8 . 7 . 6 . 5\n    //        2nd Small half:    4 . 3 . 2 . 1 . 0 .\n    //        ---------------------------------------\n    //                Result:    4 9 3 8 2 7 1 6 0 5\n    //\n    // Be careful if the length of array is odd number, \n    // Such as: [5 4 3 2 1], \n    // The 2nd half is [3 2 1] instead of [2 1]\n    // \n\n    void wiggleSort01(vector<int>& nums) {\n        sort(nums.begin(), nums.end(), [](int x, int y) { return x > y; });\n        int half = (nums.size() / 2);\n        \n        for (int i=0; i<half; i++) {\n            int v = nums[half+i];\n            nums.erase(nums.begin() + half + i );\n            nums.insert(nums.begin() + (2*i), v);\n        }\n        cout << endl;\n    }\n    \n    //\n    // After checked the discussion of Leetcode, I found there is a really brilliant idea\n    // which used a tricky idea - virtual index.\n    // \n    // Please refer to the following link to see the full details:\n    // https://discuss.leetcode.com/topic/32929/o-n-o-1-after-median-virtual-indexing\n    \n    void wiggleSort02(vector<int>& nums) {\n        int n = nums.size();\n        \n        // Find a median.\n        auto midptr = nums.begin() + n / 2;\n        nth_element(nums.begin(), midptr, nums.end());\n        int mid = *midptr;\n        \n        // Index-rewiring.\n        #define A(i) nums[(1+2*(i)) % (n|1)]\n    \n        // 3-way-partition-to-wiggly in O(n) time with O(1) space.\n        int i = 0, j = 0, k = n - 1;\n        while (j <= k) {\n            if (A(j) > mid)\n                swap(A(i++), A(j++));\n            else if (A(j) < mid)\n                swap(A(j), A(k--));\n            else\n                j++;\n        }\n    }\n    void wiggleSort(vector<int>& nums) {\n        return wiggleSort02(nums); //~140ms\n        return wiggleSort01(nums); //~230ms\n    }\n};\n"
  },
  {
    "question_theme": "peakIndexInAMountainArray",
    "question": "/*************************************************************************************** \n *\n * Let's call an array A a mountain if the following properties hold:\n * \n * \n * \tA.length >= 3\n * \tThere exists some 0 < i < A.length - 1 such that A[0] < A[1] < ... A[i-1] < \n * A[i] > A[i+1] > ... > A[A.length - 1]\n * \n * \n * Given an array that is definitely a mountain, return any i such that A[0] < A[1] < \n * ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1].\n * \n * Example 1:\n * \n * \n * Input: [0,1,0]\n * Output: 1\n * \n * \n * \n * Example 2:\n * \n * \n * Input: [0,2,1,0]\n * Output: 1\n * \n * \n * Note:\n * \n * \n * \t3 <= A.length <= 10000\n * \t0 <= A[i] <= 10^6\n * \tA is a mountain, as defined above.\n * \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/peak-index-in-a-mountain-array/description/\n// Author : Hao Chen\n// Date   : 2018-06-29\n\n\n\nclass Solution {\npublic:\n    int peakIndexInMountainArray(vector<int>& A) {\n        \n        // Put two dummy items at head and tail to avoid Out-of-Bound Error.\n        #define INT_MAX 2147483647\n        #define INT_MIN (-INT_MAX - 1)\n        A.insert ( A.begin() , INT_MIN );\n        A.push_back(INT_MIN);\n        \n        //binary search\n        int len = A.size();\n        int left = 1, right = len - 2;\n        while(left <= right) {\n            int mid = left + (right - left)/2; //avoid integer overflow\n            if ( A[mid-1] < A[mid] && A[mid] > A[mid+1]) return mid-1;\n            if ( A[mid-1] < A[mid] && A[mid] < A[mid+1]) left = mid + 1;\n            if ( A[mid-1] > A[mid] && A[mid] > A[mid+1]) right = mid - 1;\n            \n        }\n        return -1;\n    }\n};\n\n"
  },
  {
    "question_theme": "removeDuplicateLetters",
    "question": "/*************************************************************************************** \n *\n * Given a string which contains only lowercase letters, remove duplicate letters so \n * that every letter appear once and only once. You must make sure your result is the \n * smallest in lexicographical order among all possible results.\n * \n * Example:\n * \n * Given \"bcabc\"\n * Return \"abc\"\n * \n * Given \"cbacdcbc\"\n * Return \"acdb\"\n * \n * Credits:Special thanks to @dietpepsi for adding this problem and creating all test \n * cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/remove-duplicate-letters/\n// Author : Hao Chen\n// Date   : 2017-01-02\n\n\n\n\nclass Solution {\npublic:\n    string removeDuplicateLetters(string s) {\n        const int ASCII_LEN = 256;\n        int counter[ASCII_LEN] = {0};\n        bool visited[ASCII_LEN] = {false};\n        \n        for (char ch : s) {\n            counter[ch]++;\n        }\n        \n        string result;\n        for (char ch : s) {\n            counter[ch]--;\n            // if the current `ch` has already put into the result.\n            if (visited[ch]) continue;\n            \n            // if the current `ch` is smaller than the last one char in result.\n            // and we still have duplicated last-one char behind, so we can remove the current one.\n            while ( !result.empty() && ch < result.back() && counter[result.back()] ) {\n                visited[result.back()] = false;\n                result.pop_back();\n            }\n            result.push_back(ch);\n            visited[ch] = true;\n        }\n        return result;\n    }\n};\n"
  },
  {
    "question_theme": "sqrt",
    "question": "/********************************************************************************** \n* \n* Implement int sqrt(int x).\n* \n* Compute and return the square root of x.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/sqrtx/\n// Author : Hao Chen\n// Date   : 2014-08-26\n\n\n\n#include <stdlib.h>\n#include <iostream>\nusing namespace std;\n\n\nint sqrt(int x) {\n\n    if (x <=0 ) return 0;\n    \n    //the sqrt is not greater than x/2+1\n    int e = x/2+1;\n    int s = 0;\n    // binary search\n    while ( s <= e ) {\n        int mid = s + (e-s)/2;\n        long long sq = (long long)mid*(long long)mid;\n        if (sq == x ) return mid;\n        if (sq < x) {\n            s = mid + 1;\n        }else {\n            e = mid - 1;\n        }\n    }\n    return e; \n        \n}\n\n// http://en.wikipedia.org/wiki/Newton%27s_method\nint sqrt_nt(int x) {\n    if (x == 0) return 0;\n    double last = 0;\n    double res = 1;\n    while (res != last)\n    {\n        last = res;\n        res = (res + x / res) / 2;\n    }\n    return int(res);\n}\n\n\nint main(int argc, char**argv)\n{\n    int n = 2;\n    if( argc > 1 ){\n        n = atoi(argv[1]);\n    }\n    cout << \"sqrt(\" << n << \") = \" << sqrt(n) << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "simplifyPath",
    "question": "/********************************************************************************** \n* \n* Given an absolute path for a file (Unix-style), simplify it.\n* \n* For example,\n* path = \"/home/\", => \"/home\"\n* path = \"/a/./b/../../c/\", => \"/c\"\n* \n* \n* Corner Cases:\n* \n* Did you consider the case where path = \"/../\"?\n* In this case, you should return \"/\".\n* Another corner case is the path might contain multiple slashes '/' together, such as \"/home//foo/\".\n* In this case, you should ignore redundant slashes and return \"/home/foo\".\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/simplify-path/\n// Author : Hao Chen\n// Date   : 2014-10-09\n\n\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\n\nvector<string> &split(const string &s, char delim, vector<string> &elems) {\n    stringstream ss(s);\n    string item;\n    while (getline(ss, item, delim)) {\n        elems.push_back(item);\n    }\n    return elems;\n}\n\n\nvector<string> split(const string &s, char delim) {\n    vector<string> elems;\n    split(s, delim, elems);\n    return elems;\n}\n\n\nstring simplifyPath(string path) {\n\n    string result;\n    vector<string> elems = split(path, '/'); \n   \n    int ignor = 0;\n    for(int i=elems.size()-1; i>=0; i--) {\n         \n        if (elems[i]==\"\" || elems[i]==\".\" ){\n            continue;\n        }\n        if (elems[i]==\"..\"){\n            ignor++;\n            continue;\n        }\n        if (ignor>0){\n            ignor--;\n            continue;\n        }\n        if (result.size()==0){\n            result = \"/\" + elems[i];\n        }else{ \n            result = \"/\" + elems[i] + result;\n        }\n    }\n\n    return  result.size() ? result : \"/\";\n        \n}\n\nint main(int argc, char** argv)\n{\n    string path(\"/a/./b/../../c/\");\n    if (argc > 1 ){\n        path = argv[1];\n    }\n\n    cout << path << \" : \" << simplifyPath(path) << endl;\n}\n"
  },
  {
    "question_theme": "lexicographicalNumbers",
    "question": "/*************************************************************************************** \n *\n * Given an integer n, return 1 - n in lexicographical order.\n * \n * For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].\n * \n * Please optimize your algorithm to use less time and space. The input size may be as \n * large as 5,000,000.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/lexicographical-numbers/\n// Author : Hao Chen\n// Date   : 2016-08-23\n\n\nclass Solution {\n    \n//Solution 1: convert the int to string for sort, Time complexity is high (Time Limited Error)\npublic:\n    vector<int> lexicalOrder01(int n) {\n        vector<int> result;\n        for (int i=1; i<=n; i++) {\n            result.push_back(i);\n        }\n        sort(result.begin(), result.end(), this->myComp);\n        return result;\n    }\nprivate:\n    static bool myComp(int i,int j) { \n        static char si[32]={0}, sj[32]={0};\n        sprintf(si, \"%d\\0\", i);\n        sprintf(sj, \"%d\\0\", j);\n        return (strcmp(si, sj)<0); \n    }\n    \n    \n//Solution 2 : using recursive way to solution the problem, 540ms\npublic:\n    vector<int> lexicalOrder02(int n) {\n        vector<int> result;\n        for (int i=1; i<=n && i<=9; i++) {\n            result.push_back(i);\n            lexicalOrder_helper(i, n, result);\n        }\n        return result;\n    }\n    \nprivate:\n    void lexicalOrder_helper(int num, int& n, vector<int>& result) {\n        for (int i=0; i<=9; i++) {\n            int tmp = num * 10 + i;\n            if (tmp > n) {\n                break;\n            }\n            result.push_back(tmp);\n            lexicalOrder_helper(tmp, n, result);\n        }\n    }\n\n//Solution 3: no recursive way, but the code is not easy to read\npublic :\n    vector<int> lexicalOrder03(int n) {\n        vector<int> result;\n        int curr = 1;\n        while (result.size()<n) {\n            // Step One\n            // ---------\n            //Adding all of the possible number which multiply 10 as much as possible \n            // such as: curr = 1, then 1, 10, 100, 1000 ...\n            //          curr = 12, then 12, 120, 1200, ...\n            for (; curr <= n; curr*=10 ) {\n                result.push_back(curr);\n            }\n            \n            // Step Two\n            // ---------\n            // After find the number which multiply 10 greater than `n`, then go back the previous one,\n            // and keep adding 1 until it carry on to next number\n            // for example:\n            //    curr = 100, then we need evalute:  11,12,13,14,15,16,17,18,19, but stop at 20\n            //    curr = 230, then we need evaluate: 24,25,26,27,28,29, but stop at 30.\n            curr = curr/10 + 1;\n            for (;  curr <= n &&  curr % 10 != 0; curr++) {\n                result.push_back(curr);\n            }\n\n            // Step Three\n            // ----------\n            // Now, we finished all of the number, we need go back for next number\n            // Here is a bit tricky.\n            // \n            // Assuming the n is 234, and Step One evaluted 190, and Step Two, evaluted 191,192,...,199\n            // Now, the `curr` is 200, and we need start from 2 instead of 20, that's why need keep dividing 10\n            for (; curr%10 == 0; curr/=10);\n           \n        }\n        return result;\n    }\n    \n    \n//start point\npublic:\n    vector<int> lexicalOrder(int n) {\n        srand(time(NULL));\n        if (rand()%2) \n            return lexicalOrder02(n); // recursive way  560ms\n        else \n            return lexicalOrder03(n); // non-recursive way, 460ms\n    }\n\n};\n"
  },
  {
    "question_theme": "substringWithConcatenationOfAllWords",
    "question": "/********************************************************************************** \n* \n* You are given a string, S, and a list of words, L, that are all of the same length. \n* Find all starting indices of substring(s) in S that is a concatenation of each word \n* in L exactly once and without any intervening characters.\n* \n* For example, given:\n* S: \"barfoothefoobarman\"\n* L: [\"foo\", \"bar\"]\n* \n* You should return the indices: [0,9].\n* (order does not matter).\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/substring-with-concatenation-of-all-words/\n// Author : Hao Chen\n// Date   : 2014-08-24\n\n\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\nvector<int> findSubstring(string S, vector<string> &L) {\n\n    vector<int> result;\n    if ( S.size()<=0 || L.size() <=0 ){\n        return result;\n    }\n    \n    int n = S.size(), m = L.size(), l = L[0].size();\n\n    //put all of words into a map    \n    map<string, int> expected;\n    for(int i=0; i<m; i++){\n        if (expected.find(L[i])!=expected.end()){\n            expected[L[i]]++;\n        }else{\n            expected[L[i]]=1;\n        }\n    }\n\n    for (int i=0; i<l; i++){\n        map<string, int> actual;\n        int count = 0; //total count\n        int winLeft = i;\n        for (int j=i; j<=n-l; j+=l){\n            string word = S.substr(j, l);\n            //if not found, then restart from j+1;\n            if (expected.find(word) == expected.end() ) {\n                actual.clear();\n                count=0;\n                winLeft = j + l;\n                continue;\n            }\n            count++;\n            //count the number of \"word\"\n            if (actual.find(word) == actual.end() ) {\n                actual[word] = 1;\n            }else{\n                actual[word]++;\n            }\n            // If there is more appearance of \"word\" than expected\n            if (actual[word] > expected[word]){\n                string tmp;\n                do {\n                    tmp = S.substr( winLeft, l );\n                    count--;\n                    actual[tmp]--;\n                    winLeft += l; \n                } while(tmp!=word);\n            }\n\n            // if total count equals L's size, find one result\n            if ( count == m ){\n                result.push_back(winLeft);\n                string tmp = S.substr( winLeft, l );\n                actual[tmp]--;\n                winLeft += l;\n                count--;\n            }\n            \n        }\n    }\n\n    return result;\n}\n\n\nint main(int argc, char**argv)\n{\n    string s = \"barfoobarfoothefoobarman\";\n    vector<string> l;\n    l.push_back(\"foo\");\n    l.push_back(\"bar\");\n    l.push_back(\"foo\");\n    \n    vector<int> indics = findSubstring(s, l);\n    \n    for(int i=0; i<indics.size(); i++){\n        cout << indics[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "findTheDuplicateNumber",
    "question": "/*************************************************************************************** \n *\n * Given an array nums containing n + 1 integers where each integer is between 1 and \n * n (inclusive), prove that at least one duplicate number must exist.\n * Assume that there is only one duplicate number, find the duplicate one.\n *\n * Note:\n * > You must not modify the array (assume the array is read only).\n * > You must use only constant, O(1) extra space.\n * > Your runtime complexity should be less than O(n2).\n * > There is only one duplicate number in the array, but it could be repeated more than\n *   once.\n *\n * Credits:\n * Special thanks to @jianchao.li.fighter for adding this problem and creating all test\n * cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/find-the-duplicate-number/\n// Author : Hao Chen, Calinescu Valentin\n// Date   : 2015-10-19\n\n\n\n\nclass Solution {\npublic:\n    //\n    // This problem can be transfromed to \"Linked List Cycle\" problem.\n    // There are two pointers, one goes one step, another goes two steps.\n    //\n    // Refer to: https://en.wikipedia.org/wiki/Cycle_detection\n    //\n    int findDuplicate(vector<int>& nums) {\n        int n = nums.size();\n        int one = n;\n        int two = n;\n\n       do{\n            one = nums[one-1];\n            two = nums[nums[two-1]-1];\n        } while(one != two); \n        \n        //find the start point of the cycle\n        one = n;\n        while(one != two){\n            one = nums[one-1];\n            two = nums[two-1];\n        }\n        \n        return one;\n    }\n};\n"
  },
  {
    "question_theme": "nthDigit",
    "question": "/*************************************************************************************** \n *\n * Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, \n * 11, ... \n * \n * Note:\n * n is positive and will fit within the range of a 32-bit signed integer (n 31).\n * \n * Example 1:\n * \n * Input:\n * 3\n * \n * Output:\n * 3\n * \n * Example 2:\n * \n * Input:\n * 11\n * \n * Output:\n * 0\n * \n * Explanation:\n * The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which \n * is part of the number 10.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/nth-digit/\n// Author : Hao Chen\n// Date   : 2016-11-05\n\n\n\n\n#include <cmath>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findNthDigit(int n) {\n        \n        // We can see the following pattern:\n        //\n        // 1, 2, .... 9 : there are 9 * 1 digits.\n        // 10, 11, ..., 99: there are 90 * 2 digits. \n        // 101, 102, 103, ..., 999:  there are 900 * 3.\n        // ...\n        \n        \n        //we can count the digits with the above pattern\n        long digits_cnt = 0;\n        long digits_cnt_prev = 0;\n        int base = 0;\n        for ( ; digits_cnt < n; base++) {\n            digits_cnt_prev = digits_cnt;\n            digits_cnt = digits_cnt +  9 * pow(10 , base) * ( base + 1 );\n        }\n        \n        \n        // Now, we got `digits_cnt_prev`, `digits_cnt` and `base`\n        //\n        //   For examples: \n        //      n = 20;    digits_cnt_prev = 9,            digits_cnt = 9+90*2 = 189,         base = 2;\n        //      n = 500;   digits_cnt_prev = 9+90*2 = 189, digits_cnt = 9+90*2+900*3 = 2889,  base = 3;\n        //      n = 2000;  digits_cnt_prev = 9+90*2 = 189, digits_cnt = 9+90*2+900*3 = 2889,  base = 3;\n        //\n        // It means, we found the range where the number it is\n        //     n = 20,  the number located in the range 10 -- 99\n        //     n = 500, the number located in the range 100 - 999\n        //\n        // and we can use `digits_cnt_prev` to know the previous rangs produce how many digits.\n        //     n = 20, the previous ranges produce 9 digits, so there needs 20-9 = 11 digits in [10 - 99]\n        //     n = 500, the previous ranges produce 189 digits, so there needs 500-189 = 311 digits in [100-999]\n        // \n        // the `base` told us in current ranges, each number can have how many digits.\n        // then we can locate the target number.\n        //     n = 20, \n        //       (n - digits_cnt_prev) / base = (20 - 9 ) / 2 = 5, so, [10 - 14] produces 10 digits (ZERO-based),\n        //       now, we have 1 digits left, it is the first digit of the target number 15.\n        //\n        //     n = 500, \n        //       (n - digits_cnt_prev) / base = (500 - 189) / 3 = 103, so, [100 - 202] produces 309 digits(ZERO-based).\n        //       now, we have (500 - 189 - 309) = 2 digits left, it is the second digit of the target number 203.\n        //\n        // We can write the code now... \n        //\n        int target = pow(10, base-1) + (n - digits_cnt_prev) / base - 1;\n        int left = n - digits_cnt_prev - (n - digits_cnt_prev) / base * base;\n        \n        //cout << \"target = \" << target <<  \", left = \" << left << endl;\n        \n        //no digits left\n        if ( left == 0 ) return (target) % 10;\n        \n        //still have some digits left, it should be in next number.\n        target++;\n        return int( target / pow(10, base - left) ) % 10;\n    }\n};\n"
  },
  {
    "question_theme": "minimumPathSum",
    "question": "/********************************************************************************** \n* \n* Given a m x n grid filled with non-negative numbers, find a path from top left to \n* bottom right which minimizes the sum of all numbers along its path.\n* \n* Note: You can only move either down or right at any point in time.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/minimum-path-sum/\n// Author : Hao Chen\n// Date   : 2014-06-21\n\n\n\n#include <limits.h>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint minPathSum(vector<vector<int> > &grid) {\n    if (grid.size()<=0){\n        return 0;\n    }\n    int i, j;\n    for(i=0; i<grid.size(); i++){\n        for(j=0; j<grid[i].size(); j++){\n            int top = i-1<0 ? INT_MAX : grid[i-1][j] ;\n            int left = j-1<0 ? INT_MAX : grid[i][j-1];\n            if (top==INT_MAX && left==INT_MAX){\n                continue;\n            }\n            grid[i][j] += (top < left? top: left);\n\n        }\n    }\n\n    return grid[grid.size()-1][grid[0].size()-1];\n}\n\n\nint main()\n{\n    int a[6][2]={{7,2},{6,6},{8,6},{8,7},{5,0},{6,0}};\n    vector< vector<int> > grid;\n    for(int i=0; i<6; i++){\n        vector<int> v;\n        for(int j=0; j<2; j++){\n            v.push_back(a[i][j]);\n        }\n        grid.push_back(v);\n    }\n    \n    cout << \"minPathSum=\" << minPathSum(grid) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "question_theme": "lengthOfLastWord",
    "question": "/********************************************************************************** \n* \n* Given a string s consists of upper/lower-case alphabets and empty space characters ' ', \n* return the length of last word in the string.\n* \n* If the last word does not exist, return 0.\n* \n* Note: A word is defined as a character sequence consists of non-space characters only.\n* \n* For example, \n* Given s = \"Hello World\",\n* return 5.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/length-of-last-word/\n// Author : Hao Chen\n// Date   : 2014-07-01\n\n\n\n#include <stdio.h>\n#include <ctype.h>\n\nint lengthOfLastWord(const char *s) {\n\n    if ( !s ||!*s ) return 0;\n\n    int wordLen=0;\n    int cnt=0;\n\n    for (;*s!='\\0';s++) {\n        if (isalpha(*s)){\n            cnt++;\n        }\n        if (!isalpha(*s)){\n            if (cnt>0){\n                wordLen = cnt;\n            }\n            cnt=0;\n        }\n    }\n\n    return cnt>0 ? cnt : wordLen;\n}\n\n\nint main(int argc, char** argv)\n{\n    const char* p;\n    p = \"hello world\";\n    printf(\"%s, %d\\n\", p, lengthOfLastWord(p)); \n    p = \"a\";\n    printf(\"%s, %d\\n\", p, lengthOfLastWord(p)); \n    \n    if(argc>1){\n        p = argv[1];\n        printf(\"%s, %d\\n\", p, lengthOfLastWord(p)); \n    }\n}\n"
  },
  {
    "question_theme": "increasingTripletSubsequence",
    "question": "/*************************************************************************************** \n *\n * Given an unsorted array return whether an increasing subsequence of length 3 exists\n * or not in the array.\n * \n * Formally the function should:\n * Return true if there exists i, j, k \n * such that arr[i] < arr[j] < arr[k] given 0 \u2264 i < j < k \u2264 n-1 else return false.\n * Your algorithm should run in O(n) time complexity and O(1) space complexity.\n * \n * Examples:\n * Given [1, 2, 3, 4, 5],\n * return true.\n * \n * Given [5, 4, 3, 2, 1],\n * return false.\n * \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/increasing-triplet-subsequence/\n// Author : Calinescu Valentin\n// Date   : 2016-02-27\n\n\nclass Solution {\npublic:\n    bool increasingTriplet(vector<int>& nums) {\n        bool solution = false;\n        if(nums.size())\n        {\n            int first = nums[0];\n            int second = 0x7fffffff; //MAX_INT so we can always find something smaller than it\n            for(int i = 1; i < nums.size() && !solution; i++)\n            {\n                if(nums[i] > second)\n                    solution = true;\n                else if(nums[i] > first && nums[i] < second)\n                    second = nums[i];\n                else if(nums[i] < first)\n                    first = nums[i];\n            }\n        }\n        return solution;\n    }\n};\n"
  },
  {
    "question_theme": "frogJump",
    "question": "/*************************************************************************************** \n *\n * A frog is crossing a river. The river is divided into x units and at each unit there \n * may or may not exist a stone. The frog can jump on a stone, but it must not jump \n * into the water.\n * \n * Given a list of stones' positions (in units) in sorted ascending order, determine if \n * the frog is able to cross the river by landing on the last stone. Initially, the \n * frog is on the first stone and assume the first jump must be 1 unit.\n * \n * If the frog's last jump was k units, then its next jump must be either k - 1, k, or \n * k + 1 units. Note that the frog can only jump in the forward direction.\n * \n * Note:\n * \n * The number of stones is \u2265 2 and is \n * Each stone's position will be a non-negative integer 31.\n * The first stone's position is always 0.\n * \n * Example 1:\n * \n * [0,1,3,5,6,8,12,17]\n * \n * There are a total of 8 stones.\n * The first stone at the 0th unit, second stone at the 1st unit,\n * third stone at the 3rd unit, and so on...\n * The last stone at the 17th unit.\n * \n * Return true. The frog can jump to the last stone by jumping \n * 1 unit to the 2nd stone, then 2 units to the 3rd stone, then \n * 2 units to the 4th stone, then 3 units to the 6th stone, \n * 4 units to the 7th stone, and 5 units to the 8th stone.\n * \n * Example 2:\n * \n * [0,1,2,3,4,8,9,11]\n * \n * Return false. There is no way to jump to the last stone as \n * the gap between the 5th and 6th stone is too large.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/frog-jump/\n// Author : Hao Chen\n// Date   : 2016-11-12\n\n\n\nclass Solution {\npublic:\n    bool canCross_recursion(vector<int>& stones, int curr, int last_jump) {\n        for(int i=curr+1; i<stones.size(); i++){\n            int next_jump = stones[i] - stones[curr];\n            //the minimal jump is far exceed the current node, go to check next node.\n            if (next_jump < last_jump - 1) continue;\n            //cannot reach this one, then simple reture false;\n            if (next_jump > last_jump + 1) return false;\n            \n            if (i == stones.size() - 1 || canCross_recursion(stones, i, next_jump)) return true;\n        }\n        return false;\n    }\n    \n    bool canCross_recursion_with_cache(vector<int>& stones, int curr, int last_jump, \n                                        unordered_map<int, unordered_map<int, bool>>& cache) \n    {\n        //check the cache is hitted ?\n        if (cache.find(curr) != cache.end() && cache[curr].find(last_jump)!=cache[curr].end()) {\n            return cache[curr][last_jump];\n        }\n        \n        for(int i=curr+1; i<stones.size(); i++){\n            int next_jump = stones[i] - stones[curr];\n            if (next_jump < last_jump - 1) continue;\n            if (next_jump > last_jump + 1) break;\n            if (i == stones.size() - 1 || canCross_recursion_with_cache(stones, i, next_jump, cache)) {\n                cache[curr][last_jump] = true;\n                return true;\n            }\n        }\n        cache[curr][last_jump] = false;\n        return false;\n    }\n    \n    bool canCross_non_recursion(vector<int>& stones) {\n        \n        // the `jumps` map store the all possible `last jumps`\n        unordered_map<int, unordered_set<int>> jumps = {{0, {0}}};\n        \n        for(int i=0; i<stones.size(); i++) {\n            if (jumps.find(i) == jumps.end()){ \n                continue;\n            }\n            //for each possible last jump which reach the current node.\n            for(int last_jump : jumps[i]) {\n                //find the next nodes can be reached.\n                for (int j=i+1; j < stones.size(); j++) {\n                    //ingore the rest node which cannot be reached\n                    if (stones[i] + last_jump + 1 < stones[j]) break;\n                    \n                    // evaluated three possbile jumps for next node \n                    for (int next_jump  = last_jump - 1;   next_jump <= last_jump + 1;  next_jump++)  {\n                        if ( stones[i] + next_jump  == stones[j] ) {\n                            jumps[j].insert(next_jump);\n                        }\n                    }\n                        \n                }\n            }\n        }\n        \n        return jumps.find(stones.size()-1)!=jumps.end();\n    }\n    \n    bool canCross(vector<int>& stones) {\n        \n        //Burst Force solution -- accepted ~500ms\n        return canCross_non_recursion(stones);\n        \n        //DFS with cache solution - accepted ~160ms\n        unordered_map<int, unordered_map<int, bool>> cache;\n        return canCross_recursion_with_cache(stones, 0, 0, cache);\n        \n        // Time Limit Error \n        return canCross_recursion(stones, 0, 0); \n        \n    }\n};\n"
  },
  {
    "question_theme": "searchInRotatedSortedArray",
    "question": "/********************************************************************************** \n* \n* Suppose a sorted array is rotated at some pivot unknown to you beforehand.\n* \n* (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\n* \n* You are given a target value to search. If found in the array return its index, otherwise return -1.\n* \n* You may assume no duplicate exists in the array.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/search-in-rotated-sorted-array/\n// Author : Hao Chen\n// Date   : 2014-06-28\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint binary_search(int A[], int n, int key); \nint binary_search(int A[], int l, int h, int key); \nint rotate_search(int A[], int l, int h, int key);\n\nint search1(int A[], int n, int target);\nint search2(int A[], int n, int target); \n\nint search(int A[], int n, int target) {\n    if (random()%2){\n        return search1(A, n, target);\n    }\n    return search2(A, n, target);\n}\n\nint search1(int A[], int n, int key) {\n    if (n<=0) return -1;\n\n    if (n==1){\n        return (A[0]==key) ? 0 : -1;\n    }\n    int low=0, high=n-1;\n    while( low<=high ){\n\n        if (A[low] <= A[high] && ( key < A[low] || key > A[high]) ) {\n             return -1;\n        }\n\n        int mid = low + (high-low)/2;\n        if ( A[mid] == key ) return mid;\n    \n        //the target in non-rotated array\n        if (A[low] < A[mid] && key >= A[low] && key< A[mid]){\n            high = mid - 1;\n            continue;\n        }\n        //the target in non-rotated array\n        if (A[mid] < A[high] && key > A[mid] && key <= A[high] ){\n            low = mid + 1;\n            continue;\n        }\n        //the target in rotated array\n        if (A[low] > A[mid] ){\n            high = mid - 1;\n            continue;\n        }\n        //the target in rotated array\n        if (A[mid] > A[high] ){\n            low = mid + 1;\n            continue;\n        }\n    }\n    return -1;\n}\n\nint search2(int A[], int n, int target) {\n    if (n<=0) return -1;\n\n    if (n==1){\n        return A[0]==target?0:-1;\n    }        \n\n    if ( A[0] < A[n-1] ){\n        return binary_search(A, n, target);\n    }else{\n        return rotate_search(A, 0, n-1, target);\n    }\n}\n\nint rotate_search(int A[], int low, int high, int key ) {\n    \n    if (low > high){\n        return -1;\n    }\n    if (low==high){\n        return A[low]==key?low:-1;\n    }        \n    \n    int mid = low + (high-low)/2;\n    if ( A[mid] == key ) return mid;\n\n    if (A[low] < A[mid] && key >= A[low] && key< A[mid]){\n        return binary_search(A, low, mid-1, key);\n    }\n    if (A[mid] < A[high] && key > A[mid] && key <= A[high] ){\n        return binary_search(A, mid+1, high, key);\n    }\n    if (A[low] > A[mid] ){\n        return rotate_search(A, low, mid-1, key);\n    }\n    if (A[mid] > A[high] ){\n        return rotate_search(A, mid+1, high, key);\n    }\n    return -1;\n}\n\nint binary_search(int A[], int n, int key) {\n    int low = 0;\n    int high = n-1;\n    while (low <= high){\n        int mid = low +(high-low)/2;\n        if (A[mid] == key){\n            return mid;\n        }\n        if ( key> A[mid] ) {\n            low = mid+1;\n        }else{\n            high = mid-1;\n        }\n    }\n    return -1;\n}\n\nint binary_search(int A[], int low, int high, int key) {\n    //(low+high)/2 could encounter overflow issue\n    int mid = low+(high-low)/2;\n    if (low > high){\n        return -1;\n    }\n    if (A[mid]==key){\n        return mid;\n    }\n    if (key > A[mid]){\n        binary_search(A, mid+1, high, key);\n    }else{\n        binary_search(A, low, mid-1, key);\n    }\n\n}\n\nvoid rotate_array(int a[], int n, int pos){\n    int i, from=0;\n    pos = pos % n;\n    if (n<=0) return;\n\n    int tmp = a[0];\n    \n    for(int i=0, step=0; step<n && i<pos; step++){\n        int to;\n        if (from-pos < 0) {\n            to = n-pos+from; \n        }else{\n            to = from-pos;\n        }\n        int t ;\n        t = a[to];\n        a[to] = tmp; \n        tmp = t;\n        from = to;\n        if ( to == i ){\n            i++;\n            from++;\n            tmp = a[from];\n        }\n    }\n    \n}\n\nvoid printArray(int A[], int n) {\n    printf(\"{\");\n    for(int i=0; i<n; i++) {\n        printf(\"%d, \", A[i]);\n    }\n    printf(\"}\\n\");\n}\n\nint main(int argc, char** argv)\n{\n\n    int cnt=20;\n\n    if (argc>1) {\n        cnt = atoi(argv[1]);\n    }\n\n    srand(time(NULL)); \n\n   for(int n=0; n<=cnt; n++) {\n        printf(\"--------------------------------------\\n\");\n        int *a = new int[cnt];\n        for(int i=0; i<cnt; i++){\n            a[i]=i*2;\n        }\n        //printArray(a, cnt);\n        int rotate = random() % cnt;\n        //rotate=2;\n        //printf(\"rotate=%d\\n\", rotate);\n        rotate_array(a, cnt, rotate);\n        printArray(a, cnt);\n        int target = random() % (2*cnt);\n        //target=6;\n        printf(\"target=%d\\n\", target);\n    \n        int idx = search(a, cnt, target);\n        if ( idx<0 ){\n            printf(\"not found!\\n\");\n        }else{\n            printf(\"a[%d] = %d\\n\", idx, a[idx]); \n        }\n        \n        delete[] a;\n   }\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "implementQueueUsingStacks",
    "question": "/********************************************************************************** \n * \n * Implement the following operations of a queue using stacks.\n * \n * push(x) -- Push element x to the back of queue.\n * \n * pop() -- Removes the element from in front of queue.\n * \n * peek() -- Get the front element.\n * \n * empty() -- Return whether the queue is empty.\n * \n * Notes:\n * \n * You must use only standard operations of a stack -- which means only push to top, \n * peek/pop from top, size, and is empty operations are valid.\n\n * Depending on your language, stack may not be supported natively. You may simulate a \n * stack by using a list or deque (double-ended queue), as long as you use only \n * standard operations of a stack.\n\n * You may assume that all operations are valid (for example, no pop or peek operations \n * will be called on an empty queue).\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/implement-queue-using-stacks/\n// Author : Hao Chen\n// Date   : 2015-07-16\n\n\n\nclass Queue {\npublic:\n    // Push element x to the back of queue.\n    void push(int x) {\n        s1.push(x);\n    }\n\n    // Removes the element from in front of queue.\n    void pop(void) {\n        transfer(s1, s2);\n        s2.pop();\n        transfer(s2, s1);\n    }\n\n    // Get the front element.\n    int peek(void) {\n        transfer(s1, s2);\n        int ret = s2.top();\n        transfer(s2, s1);\n        return ret;\n    }\n\n    // Return whether the queue is empty.\n    bool empty(void) {\n        return s1.empty();\n    }\nprivate:\n    stack<int> s1, s2;\n    void transfer(stack<int>& s1, stack<int>& s2) {\n        while(!s1.empty()){\n            s2.push(s1.top());\n            s1.pop();\n        }\n    }\n};\n\n"
  },
  {
    "question_theme": "binaryWatch",
    "question": "/*************************************************************************************** \n *\n * A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 \n * LEDs on the bottom represent the minutes (0-59).\n * Each LED represents a zero or one, with the least significant bit on the right.\n * \n * For example, the above binary watch reads \"3:25\".\n * \n * Given a non-negative integer n which represents the number of LEDs that are \n * currently on, return all possible times the watch could represent.\n * \n * Example:\n * Input: n = 1Return: [\"1:00\", \"2:00\", \"4:00\", \"8:00\", \"0:01\", \"0:02\", \"0:04\", \"0:08\", \n * \"0:16\", \"0:32\"]\n * \n * Note:\n * \n * The order of output does not matter.\n * The hour must not contain a leading zero, for example \"01:00\" is not valid, it \n * should be \"1:00\".\n * The minute must be consist of two digits and may contain a leading zero, for example \n * \"10:2\" is not valid, it should be \"10:02\".\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/binary-watch/\n// Author : Hao Chen\n// Date   : 2016-11-05\n\n\n\nclass Solution {\nprivate:\n    void combination(int nLED, int nLight, int max, bool zero,\n                     int start, int k, int solution, \n                     vector<vector<string>>& result) {\n        if (solution > max){\n            return;\n        }\n        if (k == 0) {\n            char tmp[5] = \"\";\n            if (zero) {\n                sprintf(tmp, \"%02d\", solution);\n            }else{\n                sprintf(tmp, \"%d\", solution);\n            }\n            result[nLight].push_back(tmp);\n            return;\n        }\n        for (int i=start; i<=nLED-k; i++) {\n            solution += pow(2, i);\n            combination(nLED, nLight, max, zero, i+1, k-1, solution, result);\n            solution -= pow(2, i);\n        }\n    }\n    \n    void generate_combination(int nLED, int max, bool zero, vector<vector<string>>& result) {\n        for (int i=0; i<nLED; i++) {\n            combination(nLED, i, max, zero, 0, i, 0, result);\n        }\n    }\n    \n    void print(vector<vector<string>>&  vv) {\n        for(auto v : vv) {\n            cout << \"[ \";\n            for (auto i : v) {\n                cout << i << \" \";\n            }\n            cout << \"]\" << endl;\n        }\n    }\n    \nprivate:\n    vector<vector<string>> hour;\n    vector<vector<string>> mins;\n\npublic:\n\n    Solution():hour(4, vector<string>()), mins(6, vector<string>()){\n        generate_combination(4, 11, false, hour);\n        //print(hour);\n        //[ 0 ]\n        //[ 1 2 4 8 ]\n        //[ 3 5 9 6 10 ]\n        //[ 7 11 ]\n        \n        \n        generate_combination(6, 59, true, mins);\n        //print(mins);\n        //[ 00 ]\n        //[ 01 02 04 08 16 32 ]\n        //[ 03 05 09 17 33 06 10 18 34 12 20 36 24 40 48 ]\n        //[ 07 11 19 35 13 21 37 25 41 49 14 22 38 26 42 50 28 44 52 56 ]\n        //[ 15 23 39 27 43 51 29 45 53 57 30 46 54 58 ]\n        //[ 31 47 55 59 ]        \n    }\n    \n    vector<string> readBinaryWatch(int num) {\n        \n        vector<string> result;\n        for (int i = 0; i <= 3 && i <= num; i++) {\n            if (num - i > 5) {\n                continue;\n            }\n            for (auto h : hour[i]) {\n                for (auto m : mins[num - i]) {\n                    result.push_back( h + \":\" + m );\n                }\n            }\n            \n        }\n        return result;\n    }\n};\n"
  },
  {
    "question_theme": "removeKDigits",
    "question": "/*************************************************************************************** \n *\n * Given a non-negative integer num represented as a string, remove k digits from the \n * number so that the new number is the smallest possible.\n * \n * Note:\n * \n * The length of num is less than 10002 and will be \u2265 k.\n * The given num does not contain any leading zero.\n * \n * Example 1:\n * \n * Input: num = \"1432219\", k = 3\n * Output: \"1219\"\n * Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which \n * is the smallest.\n * \n * Example 2:\n * \n * Input: num = \"10200\", k = 1\n * Output: \"200\"\n * Explanation: Remove the leading 1 and the number is 200. Note that the output must \n * not contain leading zeroes.\n * \n * Example 3:\n * \n * Input: num = \"10\", k = 2\n * Output: \"0\"\n * Explanation: Remove all the digits from the number and it is left with nothing which \n * is 0.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/remove-k-digits/\n// Author : Hao Chen\n// Date   : 2016-11-11\n\n\n\nclass Solution {\npublic:\n    string removeKdigits_pick(string& num, int k) {\n        \n        int len = num.size();\n        string result;\n        \n        int idx = 0;\n        for (int i=0; i < len - k; i++) {\n            int min_idx = idx;\n            for (int j=min_idx; j<=i+k; j++) {\n                if (num[min_idx] > num[j])  min_idx = j;\n            }\n            \n            //don't put zero at the beginning\n            if ( !(result.empty() && num[min_idx]=='0') ){\n                result.push_back(num[min_idx]);\n            }\n            \n            //select the number started from next one, to make the order correctness.\n            idx = min_idx + 1;\n        }\n        \n        if (result.empty()) result = \"0\";\n        return result;\n    }\n    \n    string removeKdigits_remove(string& num, int k) {\n        if ( num.size() <= k ) return \"0\";\n        int left_len = num.size() - k;\n        int idx = 0;\n        for (int i=0; i<k ;i++){\n            int len = num.size();\n            for (int j=0; j<num.size()-1; j++) {\n                //if the current is bigger than next one, then revmoe the current one.\n                //In other word, we always pick the smaller one number.\n                if ( num[j] > num[j+1] ) {\n                    num.erase(j, 1);\n                    idx = j;\n                    break;\n                }\n            }\n        }\n        \n        //remove all of ZEROs at the beginning.\n        for (int i=0; i<= num.size(); i++) {\n            if (num[i] != '0' || i == num.size()) {\n                num.erase(0, i);\n                break;\n            }\n        }\n        \n        // if the digits in the array are sorted, \n        // then, we need remove the digits at the ends.\n        if (num.size() > left_len ) {\n            num.erase(num.begin() + left_len, num.end());\n        }\n        \n        if (num.empty()) num = \"0\";\n        return num;\n    }\n    \n    string removeKdigits(string num, int k) {\n        srand(time(0));\n        if (rand() % 2 ) {\n            return removeKdigits_pick(num, k);\n        } else {\n            return removeKdigits_remove(num, k);\n        }\n    }\n};\n"
  },
  {
    "question_theme": "reconstructItinerary",
    "question": "/*************************************************************************************** \n *\n * Given a list of airline tickets represented by pairs of departure and arrival \n * airports [from, to], reconstruct the itinerary in order. All of the tickets belong \n * to a man who departs from JFK. Thus, the itinerary must begin with JFK.\n * \n * Note:\n * \n * If there are multiple valid itineraries, you should return the itinerary that has \n * the smallest lexical order when read as a single string. For example, the itinerary \n * [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"].\n * All airports are represented by three capital letters (IATA code).\n * You may assume all tickets form at least one valid itinerary.\n * \n *     Example 1:\n *     tickets = [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\n *     Return [\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"].\n * \n *     Example 2:\n *     tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\n *     Return [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"].\n *     Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"]. But it \n * is larger in lexical order.\n * \n * Credits:Special thanks to @dietpepsi for adding this problem and creating all test \n * cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/reconstruct-itinerary/\n// Author : Hao Chen\n// Date   : 2017-01-06\n\n\n\n\n\n\nclass Solution {\npublic:\n    //DFS\n    void travel(string& start, unordered_map<string, multiset<string>>& map, vector<string>& result) {\n        while (map[start].size() > 0 ) {\n            string next = *(map[start].begin());\n            map[start].erase(map[start].begin());\n            travel(next, map, result);\n        }\n        result.insert(result.begin(), start);\n    }\n    \n    vector<string> findItinerary(vector<pair<string, string>> tickets) {\n        unordered_map<string, multiset<string>> map;\n        for(auto t : tickets) {\n            map[t.first].insert(t.second);\n        }\n        vector<string> result;\n        string start = \"JFK\";\n        travel(start, map, result);\n        return result;\n    }\n};\n"
  },
  {
    "question_theme": "climbStairs",
    "question": "/********************************************************************************** \n* \n* You are climbing a stair case. It takes n steps to reach to the top.\n* \n* Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/climbing-stairs/\n// Author : Hao Chen\n// Date   : 2014-06-27\n\n\n\nclass Solution {\npublic:\n    \n    int climbStairs(int n) {\n       if (n<=3) return n;\n       int a[2]={2,3};\n       for(int i=4; i<=n; i++){\n           int t = a[0] + a[1];\n           a[0] = a[1];\n           a[1] = t;\n       }\n       return a[1];\n    }\n    //Time too long\n    int climbStairs2(int n) {\n        if (n<=3) return n;\n        return climbStairs(n-1) + climbStairs(n-2);\n    }\n};\n"
  },
  {
    "question_theme": "removeDuplicatesFromSortedArray",
    "question": "/********************************************************************************** \n* \n* Follow up for \"Remove Duplicates\":\n* What if duplicates are allowed at most twice?\n* \n* For example,\n* Given sorted array A = [1,1,1,2,2,3],\n* \n* Your function should return length = 5, and A is now [1,1,2,2,3].\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/remove-duplicates-from-sorted-array-ii/\n// Author : Hao Chen\n// Date   : 2014-06-29\n\n\n\n#include <stdio.h>\n\n\nint removeDuplicates(int A[], int n) {\n    if (n<=2) return n;\n    int pos=0;\n    int cnt=1;\n    for (int i=1; i<n; i++){\n        if (A[i] == A[pos]){\n            cnt++;\n            if (cnt==2){\n                A[++pos] = A[i];\n            }\n        }else{\n            cnt=1;\n            A[++pos] = A[i];\n            \n        }\n    } \n    return pos+1;\n}\n\nvoid printfArray(int A[], int n) {\n    printf(\"{ \");\n    for (int i=0; i<n; i++){\n        printf(\"%d \", A[i]);\n    }\n    printf(\"}\\n\");\n}\n\n\nvoid testSuite(int a[], int n){\n    printfArray(a, n);\n    n = removeDuplicates(a, n);\n    printfArray(a, n);\n    printf(\"------------------\\n\");\n}\n\n#define TEST(a) testSuite(a, sizeof(a)/sizeof(int))\nint main()\n{\n    int a0[] = {1, 2, 3, 4, 5};\n    TEST(a0);\n    int a1[] = {1, 1, 1};\n    TEST(a1);\n    int a2[] = {1, 2, 2};\n    TEST(a2);\n    int a3[] = {1, 1, 2};\n    TEST(a3);\n    int a4[] = {1, 1, 1, 1};\n    TEST(a4);\n    int a5[] = {1, 1, 1, 2};\n    TEST(a5);\n    int a6[] = {1, 2, 2, 2};\n    TEST(a6);\n    int a7[] = {1, 2, 2, 2, 3 };\n    TEST(a7);\n    int a8[] = {1, 2, 2, 2, 3, 3};\n    TEST(a8);\n    int a9[] = {1,1,1,2,2,3};\n    TEST(a9);\n    int a10[] = {1,1,1,2,2,2};\n    TEST(a10);\n    int a11[] = {1,1,1,1,3,3};\n    TEST(a11);\n    return 0;\n}\n"
  },
  {
    "question_theme": "mirrorReflection",
    "question": "/*************************************************************************************** \n *\n * There is a special square room with mirrors on each of the four walls.  Except for \n * the southwest corner, there are receptors on each of the remaining corners, numbered \n * 0, 1, and 2.\n * \n * The square room has walls of length p, and a laser ray from the southwest corner \n * first meets the east wall at a distance q from the 0th receptor.\n * \n * Return the number of the receptor that the ray meets first.  (It is guaranteed that \n * the ray will meet a receptor eventually.)\n * \n *  \n * \n * \n * Example 1:\n * \n * \n * Input: p = 2, q = 1\n * Output: 2\n * Explanation: The ray meets receptor 2 the first time it gets reflected back to the \n * left wall.\n * \n * \n * \n * \n * Note:\n * \n * \n * \t1 <= p <= 1000\n * \t0 <= q <= p\n * \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/mirror-reflection/description/\n// Author : Hao Chen\n// Date   : 2018-06-27\n\n\n\n\n\n\nclass Solution {\nprivate:\n    //GCD -  greatest common divisor  \u6700\u5927\u516c\u56e0\u6570\n    int greatestCommonDivisor (int a, int b) {\n        if(b) while((a %= b) && (b %= a));\n        return a + b;\n    }\n    //LCM - least common multiple \u6700\u5c0f\u516c\u500d\u6570\n    int leastCommonMultiple(int a, int b) {\n        return a * b / greatestCommonDivisor(a, b);\n    }\npublic:\n    int mirrorReflection(int p, int q) {\n        int lcm = leastCommonMultiple(p, q);\n        if (lcm % (2*p) == 0 ) return 0;\n        \n        int nq = lcm / q; \n        \n        if (nq % 2 == 0 ) return 2;\n        return 1;\n    }\n};\n\n"
  },
  {
    "question_theme": "3Sum",
    "question": "/********************************************************************************** \n* \n* Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? \n* Find all unique triplets in the array which gives the sum of zero.\n* \n* Note:\n* \n* Elements in a triplet (a,b,c) must be in non-descending order. (ie, a \u2264 b \u2264 c)\n* The solution set must not contain duplicate triplets.\n* \n*     For example, given array S = {-1 0 1 2 -1 -4},\n* \n*     A solution set is:\n*     (-1, 0, 1)\n*     (-1, -1, 2)\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/3sum/\n// Author : Hao Chen\n// Date   : 2014-07-22\n\n\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n\n\nvector<vector<int> > threeSum(vector<int> &num) {\n\n    vector< vector<int> > result;\n    if(num.size()==0 || num.size()==1 || num.size() == 2) return result;\n\n    //sort the array, this is the key\n    sort(num.begin(), num.end());\n\n    int n = num.size();\n\n    for (int i=0; i<n-2; i++) {\n        //skip the duplication\n        if (i>0 && num[i-1]==num[i]) continue;\n        int a = num[i];\n        int low = i+1;\n        int high = n-1;\n        while ( low < high ) {\n            int b = num[low];\n            int c = num[high];\n            if (a+b+c == 0) {\n                //got the soultion\n                vector<int> v;\n                v.push_back(a);\n                v.push_back(b);\n                v.push_back(c);\n                result.push_back(v);\n                // Continue search for all triplet combinations summing to zero.\n                //skip the duplication\n                while(low<n-1 && num[low]==num[low+1]) low++; \n                while(high>0 && num[high]==num[high-1]) high--; \n                low++;\n                high--;\n            } else if (a+b+c > 0) {\n                //skip the duplication\n                while(high>0 && num[high]==num[high-1]) high--;\n                high--;\n            } else{\n                //skip the duplication\n                while(low<n-1 && num[low]==num[low+1]) low++;\n                low++;\n            } \n        }\n    }\n    return result;\n}\n\n//using combination method could meet <<Time Limit Exceeded>> error\nvector<vector<int> > combination(vector<int> &v, int k);\nbool isSumZero(vector<int>& v);\nint sum(vector<int>& v);\n\nvector<vector<int> > threeSum2(vector<int> &num) {\n    vector< vector<int> > result;\n    vector< vector<int> > r = combination(num, 3);\n    for (int i=0; i<r.size(); i++){\n        if (isSumZero(r[i])){\n            result.push_back(r[i]);\n        }\n    }\n    return result;\n}\n\nbool isSumZero(vector<int>& v){\n    return sum(v)==0;\n}\n\nint sum(vector<int>& v){\n    int s=0;\n    for(int i=0; i<v.size(); i++){\n        s += v[i];\n    }\n    return s;\n}\n\nvector<vector<int> > combination(vector<int> &v, int k) {\n\n    vector<vector<int> > result;\n    vector<int> d;\n    int n = v.size();\n    for (int i=0; i<n; i++){\n        d.push_back( (i<k) ? 1 : 0 );\n    }\n\n    //1) from the left, find the [1,0] pattern, change it to [0,1]\n    //2) move all of the 1 before the pattern to the most left side\n    //3) check all of 1 move to the right\n    while(1){\n        vector<int> tmp;\n        for(int x=0; x<n; x++){\n            if (d[x]) tmp.push_back(v[x]);\n        }\n        sort(tmp.begin(), tmp.end());\n        result.push_back(tmp);\n        //step 1), find [1,0] pattern\n        int i;\n        bool found = false;\n        int ones =0;\n        for(i=0; i<n-1; i++){\n\n            if (d[i]==1 && d[i+1]==0){\n                d[i]=0; d[i+1]=1;\n                found = true;\n                //step 2) move all of right 1 to the most left side\n                for (int j=0; j<i; j++){\n                    d[j]=( ones > 0 ) ? 1 : 0;\n                    ones--;\n                }\n                break;\n            }\n            if (d[i]==1) ones++;\n        }\n        if (!found){\n            break;\n        }\n\n    }\n    return result;\n}\n\n\nvoid printMatrix(vector<vector<int> > &matrix)\n{\n    for(int i=0; i<matrix.size(); i++){\n        printf(\"{\");\n        for(int j=0; j< matrix[i].size(); j++) {\n            printf(\"%3d \", matrix[i][j]) ;\n        }\n        printf(\"}\\n\");\n    }\n    cout << endl;\n}\n\n\nint main()\n{\n    //int a[] = {-1, 0, 1, 2, -1, 1, -4};\n    int a[] = {-1, 1, 1, 1, -1, -1, 0,0,0};\n    vector<int> n(a, a+sizeof(a)/sizeof(int));\n    vector< vector<int> > result = threeSum(n);\n    printMatrix(result);    \n    return 0;\n}\n"
  },
  {
    "question_theme": "recoverBinarySearchTree",
    "question": "/********************************************************************************** \n* \n* Two elements of a binary search tree (BST) are swapped by mistake.\n* \n* Recover the tree without changing its structure.\n* \n* Note:\n* A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?\n* \n* confused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ.\n* \n* OJ's Binary Tree Serialization:\n* \n* The serialization of a binary tree follows a level order traversal, where '#' signifies \n* a path terminator where no node exists below.\n* \n* Here's an example:\n* \n*    1\n*   / \\\n*  2   3\n*     /\n*    4\n*     \\\n*      5\n* \n* The above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\". \n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/recover-binary-search-tree/\n// Author : Hao Chen\n// Date   : 2014-10-11\n\n\n\n\n\n//\n// We can convert the BST to a sorted array,  then we can find the two nodes which missed the order.\n//\n// To cover the BST to sorted array, we needn't use an extra array, we just traverse the tree in order.\n//  \n//                   8\n//           _______/ \\_______\n//          /                 \\\n//         4                  12\n//      __/ \\__             __/ \\__\n//     /       \\           /       \\\n//    2         6        10        14\n//   / \\       / \\       / \\       / \\\n//  1   3     5   7     9  11    13  15\n//  \n//  \nclass Solution {\npublic:\n    void recoverTreeHelper(TreeNode *root) {\n        \n        if (root == NULL) return;\n        \n        recoverTreeHelper(root->left);\n        if (prev) {\n            if (prev->val > root->val){\n                if (n1==NULL) {\n                    n1 = prev;\n                }\n                n2 = root;\n            }\n        }\n        prev = root;\n        recoverTreeHelper(root->right);\n    }\n    \n    void recoverTree(TreeNode *root) {\n        n1 = n2 = prev = NULL;\n        recoverTreeHelper(root);\n        if (n1 && n2) {\n            swap(n1->val, n2->val);\n        }\n    }\nprivate:\n    TreeNode *n1, *n2, *prev;\n};\n"
  },
  {
    "question_theme": "multiplyStrings",
    "question": "/********************************************************************************** \n* \n* Given two numbers represented as strings, return multiplication of the numbers as a string.\n* \n* Note: The numbers can be arbitrarily large and are non-negative.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/multiply-strings/\n// Author : Hao Chen\n// Date   : 2014-07-18\n\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstring multiply(string& num, char ch){\n    int n = ch - '0';\n    string s;\n    int carry = 0;\n    int x;\n    for(int i=num.size()-1; i>=0; i--){\n        x = (num[i]-'0') * n + carry;\n        carry = x/10;\n        s.insert(s.begin(), x%10+'0'); \n    }\n    if (carry>0) {\n        s.insert(s.begin(), carry+'0');\n    }\n    return s;\n}\n\nstring strPlus(string& num1, string& num2) {\n    string s;\n    int carry=0;\n    int x;\n    int n1 = num1.size(); \n    int n2 = num2.size(); \n    \n    int i, j;\n    for(i=n1-1, j=n2-1; i>=0 || j>=0; i--, j--){\n        int x1 = i>=0 ?  num1[i]-'0' : 0;\n        int x2 = j>=0 ?  num2[j]-'0' : 0;\n        x = x1 + x2 + carry; \n        carry = x/10;\n        s.insert(s.begin(), x%10+'0');\n    }\n    if (carry>0) {\n        s.insert(s.begin(), carry+'0');\n    }\n    return s;\n}\n\nstring multiply(string num1, string num2) {\n\n    if (num1.size()<=0 || num2.size()<=0) return \"\";\n\n    int shift=0;\n    string result=\"0\";\n    for (int i=num1.size()-1; i>=0; i--) {\n        string s = multiply(num2, num1[i]);        \n        for(int j=0; j<shift; j++){\n            s.insert(s.end(), '0');\n        }\n        result = strPlus(result, s);\n        shift++;\n    }\n    //check if it is zero\n    if (result[0]=='0') return \"0\";\n    return result;\n}\n\n\n\n\nclass Solution {\n    public:\n\n        string strPlus(string& num1, string& num2) {\n            if (num1.size()==0) return num2;\n            if (num2.size()==0) return num1;\n\n            if ( num1.size() < num2.size() ) {\n                swap(num1, num2);\n            }\n\n            string s;\n            int carry=0;\n            int x;\n            for (int i=num1.size()-1, j=num2.size()-1; i>=0; i--, j--) {\n                x = num1[i]-'0' + carry;\n                if(j>=0){\n                    x += num2[j]-'0';\n                }\n                s.insert(s.begin(), x%10+'0');\n                carry = x/10;\n            }\n            if (carry>0) {\n                s.insert(s.begin(), carry+'0');\n            }\n\n            return s;\n        }\n\n\n        string multiply(string num1, string num2) {\n\n            if (num1.size()<=0 || num2.size()<=0) return \"\";\n\n            string result;\n            for ( int i=num1.size()-1; i>=0; i--) {\n                int carry = 0;\n                string val;\n                for( int j=num2.size()-1; j>=0; j--) {\n                    int v = (num2[j]-'0') * (num1[i]-'0') + carry;\n                    val.insert(val.begin(), v%10+'0');\n                    carry = v/10;\n                }\n                if (carry) val.insert(val.begin(), carry+'0');\n                for (unsigned int j=i; j<num1.size()-1; j++) {\n                    val.push_back('0');\n                }\n                result = strPlus(result, val);\n            }\n\n            //check if it is zero\n            if (result[0]=='0') return \"0\";\n            return result;\n\n        }\n};\n\n\n\nint main(int argc, char**argv)\n{\n    string s1=\"20\";\n    string s2=\"25\";\n    if (argc>2){\n        s1 = argv[1];\n        s2 = argv[2];\n    }\n    cout << s1 << \" * \" << s2 << \" = \" << multiply(s1, s2) << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "longestPalindrome",
    "question": "/*************************************************************************************** \n *\n * Given a string which consists of lowercase or uppercase letters, find the length of \n * the longest palindromes that can be built with those letters.\n * \n * This is case sensitive, for example \"Aa\" is not considered a palindrome here.\n * \n * Note:\n * Assume the length of given string will not exceed 1,010.\n * \n * Example: \n * \n * Input:\n * \"abccccdd\"\n * \n * Output:\n * 7\n * \n * Explanation:\n * One longest palindrome that can be built is \"dccaccd\", whose length is 7.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/longest-palindrome/\n// Author : Hao Chen\n// Date   : 2016-11-13\n\n\n\nclass Solution {\npublic:\n    int longestPalindrome(string s) {\n        \n        int hashtable[128];\n        memset(hashtable, 0, sizeof(hashtable));\n        \n        for(char ch : s) {\n            hashtable[ch]++;\n        }\n        int result = 0;\n        bool hasOdd = false;\n        for (int n : hashtable) {\n            if ( n%2 == 0 ) {\n                result += n;\n            } else {\n                result += n -1;\n                hasOdd = true;\n            }\n        }\n        \n        return hasOdd ? result + 1 : result;\n    }\n};\n"
  },
  {
    "question_theme": "longestIncreasingSubsequence",
    "question": "/*************************************************************************************** \n *\n * Given an unsorted array of integers, find the length of longest increasing\n * subsequence.\n *\n * For example,\n * Given [10, 9, 2, 5, 3, 7, 101, 18],\n * The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n * Note that there may be more than one LIS combination, it is only necessary for yo\n * to return the length.\n * \n * Your algorithm should run in O(n2) complexity.\n * \n * Follow up: Could you improve it to O(n log n) time complexity?\n * \n * Credits:\n * Special thanks to @pbrother for adding this problem and creating all test cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/longest-increasing-subsequence/\n// Author : Calinescu Valentin, Hao Chen\n// Date   : 2015-11-06\n\n\n\n\n\n// O(n^2) - dynamic programming\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        \n        int len = nums.size();\n        int maxLen = 0;\n        vector<int> dp(len, 1);\n        \n        for (int i=0; i<len; i++) {\n            for(int j=0; j<i; j++) {\n                if ( nums[j] < nums[i] ) {\n                    dp[i] = max(dp[i], dp[j] + 1);\n                }\n            }\n            maxLen = max(maxLen, dp[i]);\n        }\n        return maxLen;\n    }\n};\n\n\nclass Solution {\npublic:\n    \n\n    vector <int> longest_LIS;\n    int lengthOfLIS(vector<int>& nums) {\n        int answer = 0;\n        if(nums.size())\n        {   \n            longest_LIS.push_back(1);\n            answer = 1;\n            for(int i = 1; i < nums.size(); i++)\n            {\n                int maximum = 1;\n                for(int j = 0; j < longest_LIS.size(); j++)\n                    if(nums[i] > nums[j])\n                        maximum = max(maximum, longest_LIS[j] + 1);\n                longest_LIS.push_back(maximum);\n                answer = max(maximum, answer);\n            }\n        }\n        return answer;\n    }\n\n    vector <int> longest_subsequence; // the LIS\n    vector <int> nums;\n    int binary_search(int number)\n    {\n        int start = 0, end = longest_subsequence.size() - 1;\n        if(start == end)\n        {\n            if(number > longest_subsequence[start])\n                return start + 1;\n            else\n                return start;\n        }\n        while(start < end)\n        {\n            if(start == end - 1)\n            {\n                if(number > longest_subsequence[start] && number <= longest_subsequence[end])\n                    return end;\n                else if(number <= longest_subsequence[start])\n                    return start;\n                else\n                    return end + 1;\n            }\n            int middle = (start + end + 1) / 2;\n            if(longest_subsequence[middle] < number)\n                start = middle;\n            else\n                end = middle;\n        }\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int answer = 0;\n        if(nums.size())\n        {   \n            answer = 1;\n            longest_subsequence.push_back(nums[0]);\n            for(int i = 1; i < nums.size(); i++)\n            {\n                int position = binary_search(nums[i]);\n                if(position == longest_subsequence.size())\n                    longest_subsequence.push_back(nums[i]);\n                else\n                    longest_subsequence[position] = nums[i];\n                answer = max(answer, position + 1);\n            }\n        }\n        return answer;\n    }\n};\n"
  },
  {
    "question_theme": "insertInterval",
    "question": "/********************************************************************************** \n* \n* Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\n* \n* You may assume that the intervals were initially sorted according to their start times.\n* \n* Example 1:\n* Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].\n* \n* Example 2:\n* Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].\n* \n* This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/insert-interval/\n// Author : Hao Chen\n// Date   : 2014-08-26\n\n\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Interval {\n    int start;\n    int end;\n    Interval() : start(0), end(0) {}\n    Interval(int s, int e) : start(s), end(e) {}\n};\n\n//Two factors sorting [start:end]\nbool compare(const Interval& lhs, const Interval& rhs){\n    return (lhs.start==rhs.start) ? lhs.end < rhs.end : lhs.start < rhs.start;\n}\n\nvector<Interval> merge(vector<Interval> &intervals) {\n\n    vector<Interval> result;\n\n    if (intervals.size() <= 0) return result;\n    //sort the inervals. Note: using the customized comparing function.\n    sort(intervals.begin(), intervals.end(), compare);\n    for(int i=0; i<intervals.size(); i++) {\n        int size = result.size();\n        // if the current intervals[i] is overlapped with previous interval.\n        // merge them together\n        if( size>0 && result[size-1].end >= intervals[i].start) {\n            result[size-1].end = max(result[size-1].end, intervals[i].end);\n        }else{\n            result.push_back(intervals[i]);\n        }\n    }\n\n    return result;\n}\n\n//just reuse the solution of \"Merge Intervals\", quite straight forward\nvector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {\n\n    intervals.push_back(newInterval);\n\n    return merge(intervals);\n}\n\nint main(int argc, char**argv)\n{\n    Interval i1(1,2);\n    Interval i2(3,5);\n    Interval i3(6,7);\n    Interval i4(8,10);\n    Interval i5(12,16);\n    vector<Interval> intervals;\n    intervals.push_back(i1);\n    intervals.push_back(i2);\n    intervals.push_back(i3);\n    intervals.push_back(i4);\n    intervals.push_back(i5);\n\n    Interval n(4,9);\n    vector<Interval> r = insert(intervals, n);\n\n    for(int i=0; i<r.size(); i++){\n        cout << \"[ \" << r[i].start << \", \" << r[i].end << \" ] \";\n    }\n    cout <<endl;\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "mergeTwoSortedArray",
    "question": "/********************************************************************************** \n* \n* Given two sorted integer arrays A and B, merge B into A as one sorted array.\n* \n* Note:\n*   You may assume that A has enough space (size that is greater or equal to m + n) \n*   to hold additional elements from B. The number of elements initialized in A and B \n*   are m and n respectively.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/merge-sorted-array/\n// Author : Hao Chen\n// Date   : 2014-06-20\n\n\n\n#include <stdio.h>\n\nvoid merge(int A[], int m, int B[], int n) {\n    int ia = m-1 ;\n    int ib = n-1 ;\n    int i = m + n - 1;\n    for (int i=m+n-1; i>=0; i--){\n        \n        if (ia>=0 && ib<0){\n            break;\n        }\n        if (ia<0 && ib>=0){\n            A[i] = B[ib--];\n            continue;\n        }            \n        if (ia>=0 && ib>=0){\n            if (A[ia] > B[ib]){\n                A[i] = A[ia--];\n            }else{\n                A[i] = B[ib--];\n            }\n        }\n\n    }\n}\n\nvoid printArray(int A[], int n) {\n    printf(\"{\");\n    for(int i=0; i<n; i++) {\n        printf(\"%d, \", A[i]);\n    }\n    printf(\"}\\n\");\n}\n\nint main()\n{\n    int a[]={2,4,6,8,10,0,0,0};\n    int b[]={1,3,5};\n    merge(a, 5, b, 3 );\n    printArray(a,  sizeof(a)/sizeof(int));\n\n    int a1[]={2,4,0,0,0};\n    int b1[]={3,5,7};\n    merge(a1, 2, b1, 3 );\n    printArray(a1, sizeof(a1)/sizeof(int));\n\n    int a2[]={12,14,16,18,20,0,0,0};\n    int b2[]={1,3,5};\n    merge(a2, 5, b2, 3 );\n    printArray(a2,  sizeof(a2)/sizeof(int));\n\n    int a3[]={2,0};\n    int b3[]={3,};\n    merge(a3, 1, b3, 1 );\n    printArray(a3, sizeof(a3)/sizeof(int));\n\n    int a4[]={0,0,0};\n    int b4[]={1,3,5};\n    merge(a4, 0, b4, 3 );\n    printArray(a4, sizeof(a4)/sizeof(int));\n\n    int a5[]={2,4,6,8,10,0,0,0};\n    int b5[]={11,13,15};\n    merge(a5, 5, b5, 3 );\n    printArray(a5,  sizeof(a5)/sizeof(int));\n\n    int a6[]={2,4,0,0,0,0,0,0};\n    int b6[]={1,3,5,7,9,11};\n    merge(a6, 2, b6, 6 );\n    printArray(a6, sizeof(a6)/sizeof(int));\n\n    return 0;\n\n\n}\n"
  },
  {
    "question_theme": "courseSchedule",
    "question": "/********************************************************************************** \n * \n * There are a total of n courses you have to take, labeled from 0 to n - 1.\n * \n * Some courses may have prerequisites, for example to take course 0 you have to first take course 1, \n * which is expressed as a pair: [0,1]\n * \n * Given the total number of courses and a list of prerequisite pairs, is it possible for you to \n * finish all courses?\n * \n * For example:\n *      2, [[1,0]]\n * There are a total of 2 courses to take. To take course 1 you should have finished course 0. \n * So it is possible.\n * \n *      2, [[1,0],[0,1]]\n * There are a total of 2 courses to take. To take course 1 you should have finished course 0, \n * and to take course 0 you should also have finished course 1. So it is impossible.\n * \n * Note:\n * The input prerequisites is a graph represented by a list of edges, not adjacency matrices. \n * Read more about how a graph is represented.\n * \n * click to show more hints.\n * \n * Hints:\n * \n *  - This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, \n *    no topological ordering exists and therefore it will be impossible to take all courses.\n *\n *  - Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic \n *    concepts of Topological Sort. (https://class.coursera.org/algo-003/lecture/52)\n *\n *  - Topological sort could also be done via BFS. (http://en.wikipedia.org/wiki/Topological_sorting#Algorithms)\n * \n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/course-schedule/\n// Author : Hao Chen\n// Date   : 2015-06-09\n\n\n\n\nclass Solution {\npublic:\n\n    bool hasCycle(int n, vector<int>& explored, vector<int>& path, map<int, vector<int>>& graph) {\n        \n        for(int i=0; i<graph[n].size(); i++){\n            \n            //detect the cycle\n            if ( path[graph[n][i]] ) return true;\n            \n            //set the marker\n            path[graph[n][i]] = true;\n            \n            if (hasCycle(graph[n][i], explored, path, graph)) {\n                return true;\n            }\n            //backtrace reset\n            path[graph[n][i]] = false;\n        }\n        //no cycle found, mark this node can finished!\n        explored[n] = true;\n        return false;\n        \n    }\n\n    bool canFinish(int numCourses, vector<pair<int, int>>& prerequisites) {\n        \n        //using map to stroe the graph, it's easy to search the edge for each node\n        //the bool in pair means it is explored or not\n        map<int, vector<int>> graph;\n        for(int i=0; i<prerequisites.size(); i++){\n            graph[prerequisites[i].first].push_back( prerequisites[i].second );\n        }\n        \n        //explored[] is used to record the node already checked!\n        vector<int> explored(numCourses, false);\n        \n        //path[] is used to check the cycle during DFS\n        vector<int> path(numCourses, false);\n        \n        for(int i=0; i<numCourses; i++){\n            \n            if (explored[i]) continue;\n            if (hasCycle(i, explored, path, graph)) return false;\n            \n\n        }\n        return true;\n    }\n};\n"
  },
  {
    "question_theme": "non-recursive"
  },
  {
    "question_theme": "kthLargestElementInAnArray",
    "question": "/********************************************************************************** \n * \n * Find the kth largest element in an unsorted array. \n * Note that it is the kth largest element in the sorted order, not the kth distinct element.\n * \n * For example,\n * Given [3,2,1,5,6,4] and k = 2, return 5.\n * \n * Note: \n * You may assume k is always valid, 1 \u2264 k \u2264 array's length.\n * \n * Credits:Special thanks to @mithmatt for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/kth-largest-element-in-an-array/\n// Author : Hao Chen\n// Date   : 2015-06-11\n\n\n\n\n\n\nclass Solution {\npublic:\n    //STL using qsort to solve this problem\n    int findKthLargest_buildin(vector<int>& nums, int k) {\n        int n=nums.size();\n        std::nth_element(nums.begin(),nums.end()-k,nums.end());\n        return nums[n-k];\n    }\n    \n    //qsort partition\n    int partition(vector<int>& nums, int left, int right) {\n        int pivot = nums[left];\n        int l = left + 1, r = right;\n        while (l <= r) {\n            if (nums[l] < pivot && nums[r] > pivot){\n                swap(nums[l++], nums[r--]);\n            }\n            if (nums[l] >= pivot) l++;\n            if (nums[r] <= pivot) r--;\n        }\n        swap(nums[left], nums[r]);\n        return r;\n    }\n    \n    int findKthLargest_qsort(vector<int>& nums, int k) {\n        int left = 0, right = nums.size() - 1;\n        while (true) {\n            int pos = partition(nums, left, right);\n            if (pos == k - 1){ \n                return nums[pos];\n            }\n            if (pos > k - 1) {\n                right = pos - 1;\n            }else{\n                left = pos + 1;  \n            }  \n        }\n    }\n    \n    \n    int findKthLargest(vector<int>& nums, int k) {\n        return findKthLargest_qsort(nums, k);\n    }\n};\n"
  },
  {
    "question_theme": "uniquePaths",
    "question": "/********************************************************************************** \n * \n * A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n * \n * The robot can only move either down or right at any point in time. The robot is trying to reach \n * the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n *    \n *    \n *    start                                                 \u2009\n *    +---------+----+----+----+----+----+                   \n *    |----|    |    |    |    |    |    |                   \n *    |----|    |    |    |    |    |    |                   \n *    +----------------------------------+                   \n *    |    |    |    |    |    |    |    |                   \n *    |    |    |    |    |    |    |    |                   \n *    +----------------------------------+                   \n *    |    |    |    |    |    |    |----|                   \n *    |    |    |    |    |    |    |----|                   \n *    +----+----+----+----+----+---------+                   \n *                                   finish                  \n *    \n * \n * How many possible unique paths are there?\n * \n * Above is a 3 x 7 grid. How many possible unique paths are there?\n * \n * Note: m and n will be at most 100.\n *               \n **********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/unique-paths/\n// Author : Hao Chen\n// Date   : 2014-06-25\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid printMatrix(int*a, int m, int n);\n\n\nint uniquePaths(int m, int n) {\n    int* matrix = new int[m*n];\n    printMatrix(matrix, m, n);\n    for (int i=0; i<m; i++){\n        for (int j=0; j<n; j++){\n            if(i==0 || j==0){\n                matrix[i*n+j]=1;\n            }else{\n                matrix[i*n+j] = matrix[(i-1)*n+j] + matrix[i*n+j-1];\n            }\n        }\n    } \n    printMatrix(matrix, m, n);\n    int u = matrix[m*n-1];\n    delete[] matrix;\n    return u;\n}\n\nvoid printMatrix(int*a, int m, int n)\n{\n    for (int i=0; i<m; i++){\n        for (int j=0; j<n; j++){\n            printf(\"%4d \", a[i*n+j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint main(int argc, char** argv)\n{\n    int m=3, n=7;\n    if( argc>2){\n        m = atoi(argv[1]);\n        n = atoi(argv[2]);\n    }\n\n    printf(\"uniquePaths=%d\\n\", uniquePaths(m,n));\n    return  0;\n}\n"
  },
  {
    "question_theme": "twoSum",
    "question": "/********************************************************************************** \n* \n* Given an array of integers that is already sorted in ascending order, \n* find two numbers such that they add up to a specific target number.\n* \n* The function twoSum should return indices of the two numbers such that they add up to the target, \n* where index1 must be less than index2. Please note that your returned answers (both index1 and index2) \n* are not zero-based.\n* \n* You may assume that each input would have exactly one solution.\n* \n* Input: numbers={2, 7, 11, 15}, target=9\n* Output: index1=1, index2=2 \n* \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/two-sum-ii-input-array-is-sorted/\n// Author : Hao Chen\n// Date   : 2014-12-25\n\n\n\n\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int> &numbers, int target) {\n        vector<int> result;\n        int low=0, high = numbers.size()-1;\n        while (low < high){\n            if (numbers[low] + numbers[high] == target){\n                result.push_back(low+1);\n                result.push_back(high+1);\n                return result;\n            }else{\n                numbers[low] + numbers[high] > target ? high-- : low++;\n            }\n        }\n        \n        return result;\n    }\n};\n"
  },
  {
    "question_theme": "minimumHeightTrees",
    "question": "/*************************************************************************************** \n *\n * For a undirected graph with tree characteristics, we can choose any node as the \n * root. The result graph is then a rooted tree. Among all possible rooted trees, those \n * with minimum height are called minimum height trees (MHTs).\n *\n * Given such a graph, write a function to find all the MHTs and return a list of \n * their root labels.\n * \n *     *Format*\n *     The graph contains n nodes which are labeled from 0 to n - 1.\n *     You will be given the number n and a list of undirected edges (each edge is a \n *     pair of labels).\n * \n *  \n *     You can assume that no duplicate edges will appear in edges. Since all edges are\n *     undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.\n * \n *     Example 1:\n * \n *     Given n = 4, edges = [[1, 0], [1, 2], [1, 3]]\n * \n *         0\n *         |\n *         1\n *        / \\\n *       2   3\n * \n *     return  [1]\n * \n *     Example 2:\n * \n *     Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]\n * \n *      0  1  2\n *       \\ | /\n *         3\n *         |\n *         4\n *         |\n *         5\n * \n *     return  [3, 4]\n * \n *     How many MHTs can a graph have at most?\n * \n *     Note:\n * \n *     (1) According to the definition of tree on Wikipedia: https://en.wikipedia.org/wiki/Tree_(graph_theory)\n *         \u201ca tree is an undirected graph in which any two vertices are connected by exactly one path. \n *         In other words, any connected graph without simple cycles is a tree.\u201d\n * \n *     (2) The height of a rooted tree is the number of edges on the longest downward path between \n *         the root and a leaf.\n * \n * Credits:Special thanks to @dietpepsi for adding this problem and creating all test \n * cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/minimum-height-trees/\n// Author : Hao Chen\n// Date   : 2016-01-24\n\n\n\nclass Solution {\npublic:\n    vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\n        //corner case\n        if ( n <= 1 ) return {0};\n        \n        //construct a edges search data stucture\n        vector<unordered_set<int>> graph(n);\n        for (auto e : edges) {\n            graph[e.first].insert(e.second);\n            graph[e.second].insert(e.first);\n        }\n        \n        //find all of leaf nodes\n        vector<int> current;\n        for (int i=0; i<graph.size(); i++){\n            if (graph[i].size() == 1)  current.push_back(i);\n        }\n        \n        // BFS the graph\n        while (true) {\n            vector<int> next;\n            for (int node : current) {\n                for (int neighbor : graph[node]) {\n                    graph[neighbor].erase(node);\n                    if (graph[neighbor].size() == 1) next.push_back(neighbor);\n                }\n            }\n            if (next.empty()) break;\n            current = next;\n        }\n        return current;\n    }\n    \n};\n"
  },
  {
    "question_theme": "summaryRanges",
    "question": "/********************************************************************************** \n * \n * Given a sorted integer array without duplicates, return the summary of its ranges.\n * \n * For example, given [0,1,2,4,5,7], return [\"0->2\",\"4->5\",\"7\"].\n * \n * Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/summary-ranges/\n// Author : Hao Chen\n// Date   : 2015-07-03\n\n\n\n\nclass Solution {\npublic:\n    string makeRange(int start, int end) {\n        ostringstream oss;\n        if (start != end) {\n            oss << start << \"->\" << end;\n        } else {\n            oss << start;\n        }\n        return oss.str();\n    }\n    \n    vector<string> summaryRanges(vector<int>& nums) {\n        vector<string> result;\n        int len = nums.size();\n        if (len == 0) return result;\n        \n        // we have two pointer for range-starter and range-ender\n        int start=nums[0], end=nums[0];\n\n        for (int i=1; i<len; i++) {\n            // if it is continous number, move the end pointer;\n            if (nums[i] == end + 1) {\n                end = nums[i];\n                continue;\n            }\n            \n            //if the number is not continous, push the range into result\n            //and reset the start and end pointer\n            result.push_back(makeRange(start, end));\n            start = end = nums[i];\n        \n        }\n        \n        //for the last range\n        result.push_back(makeRange(start, end)); \n        \n        return result;\n    }\n};\n"
  },
  {
    "question_theme": "reverseWordsInAString",
    "question": "/********************************************************************************** \n* \n* Given an input string, reverse the string word by word.\n* \n* For example,\n* Given s = \"the sky is blue\",\n* return \"blue is sky the\".\n* \n* \n* Clarification:\n* \n* What constitutes a word?\n* A sequence of non-space characters constitutes a word.\n* Could the input string contain leading or trailing spaces?\n* Yes. However, your reversed string should not contain leading or trailing spaces.\n* How about multiple spaces between two words?\n* Reduce them to a single space in the reversed string.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/reverse-words-in-a-string/\n// Author : Hao Chen, Siwei Xu\n// Date   : 2014-06-16\n\n\n\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>  // for std::reverse\nusing namespace std;\n\nvoid reverseWords(string &s) {\n    \n    bool wordStart = false;\n    vector<string> v;\n    \n    const char *pHead =s.c_str();\n    const char *pStr, *pBegin, *pEnd;\n   \n    for (pStr=pHead; *pStr!='\\0'; pStr++) {\n        if (!isspace(*pStr) && wordStart == false){\n            wordStart = true;\n            pBegin = pStr;\n            continue;\n        }\n        \n        if(isspace(*pStr) && wordStart==true){\n            wordStart=false;\n            pEnd = pStr;\n            v.insert(v.begin(), s.substr(pBegin-pHead, pEnd-pBegin) );\n        }\n        \n    }\n\n    if (wordStart==true){\n        pEnd = pStr;\n        v.insert(v.begin(), s.substr(pBegin-pHead, pEnd-pBegin) );\n    }\n    \n    if (v.size()>0){\n        s.clear();\n        char space=' ';\n        vector<string>::iterator it;\n        for (it=v.begin(); it!=v.end(); ++it) {\n            s = s + *it;\n            s.push_back(space);\n        }\n        s.erase(s.end()-1);\n    }else{\n            s.clear();\n    }\n    cout << \"[\" << s << \"]\" <<endl;\n}\n\n// inspired from <Programming Pearls> -- Handwaving\nvoid reverseWords2(string &s) {\n    if (s.length() == 0) return;\n\n    string result = \"\";\n    if (s[s.length()-1] == ' ') {\n        int last = s.find_last_not_of(' ') + 1;\n        s.erase(last, s.length() - last);\n    }\n\n    int first = s.find_first_not_of(' ', 0);\n    while (first != string::npos) {\n        int wend = s.find(' ', first);  // word end\n        if (wend == string::npos) wend = s.length();\n\n        string word = s.substr(first, wend - first);\n        reverse(word.begin(), word.end());\n        result += word;\n\n        first = s.find_first_not_of(' ', wend); // next word\n        if (first == string::npos) break;\n\n        result += ' ';\n    }\n    reverse(result.begin(), result.end());\n    s.swap(result);\n}\n\n\n// C solution in O(1) space\nvoid reverse(char *b, char *e) {\n    for (--e; e - b > 0; b++, e--) {\n        char t = *b;\n        *b = *e;\n        *e = t;\n    }\n}\n\nvoid reverseWords(char *s) {\n    char *p = s, *ws = NULL, *last = s;\n\n    while (*p && *p == ' ') p++; // skip leading space\n    ws = p;\n\n    for ( ; *p; p++) {\n        while (*p && *p != ' ') p++; // find word end\n\n        reverse(ws, p);\n        strncpy(last, ws, p-ws);\n        last += (p-ws);\n\n        while (*p && *p == ' ') p++; // for next word\n        ws = p;\n\n        if (*p == '\\0') break;\n        *last++ = ' ';\n    }\n    reverse(s, last);\n    *last = '\\0';\n}\n\nvoid test() {\n#define TEST(str) do {       \\\n    char* s = strdup(str);   \\\n    printf(\"\\\"%s\\\" => \", s); \\\n    reverseWords(s);         \\\n    printf(\"\\\"%s\\\"\\n\\n\", s); \\\n    free(s);                 \\\n    } while (0)\n\n    TEST(\"  the    blue   sky  is blue    \");\n    TEST(\"  \");\n}\n\n\nmain()\n{\n   string s;\n   reverseWords(s);\n   s=\" \";\n   reverseWords(s);\n   s=\"1 \";\n   reverseWords(s);\n   s=\"love\";\n   reverseWords(s);\n   s=\"i love cpp\";\n   reverseWords(s);\n\n   test();\n}    \n"
  },
  {
    "question_theme": "constructBinaryTreeFromPreorderAndInorderTraversal",
    "question": "/********************************************************************************** \n* \n* Given preorder and inorder traversal of a tree, construct the binary tree.\n* \n* Note:\n* You may assume that duplicates do not exist in the tree.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\n// Author : Hao Chen\n// Date   : 2014-07-09\n\n\n\n#include <stdio.h>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode *buildTree(vector<int>& preorder, int& preidx, vector<int>& inorder);\n\nTreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\n    int preidx=0;\n    return buildTree(preorder, preidx, inorder);\n}\n\nTreeNode *buildTree(vector<int>& preorder, int& preidx, vector<int>& inorder) {\n\n    if (preorder.size()<=0 || inorder.size()<=0 ) return NULL;\n\n    TreeNode *root = new TreeNode(preorder[preidx]);\n    if (inorder.size()==1){\n        return root;\n    }\n\n    int i;\n    for(i=0; i<inorder.size(); i++){\n        if (inorder[i] == preorder[preidx]){\n            break;\n        }\n    }\n\n    //error: not found\n    if (i == inorder.size()) return NULL;\n\n    if (preidx+1 >= preorder.size()){\n        return root;\n    }\n\n    \n    vector<int> v(inorder.begin(), inorder.begin()+i);\n    if (v.size()>0) {\n        preidx++;\n        root->left = buildTree(preorder, preidx, v);\n    }\n\n    v.clear();\n    v.assign(inorder.begin()+i+1, inorder.end());\n    if (v.size()>0) {\n        preidx++;\n        root->right = buildTree(preorder, preidx, v);\n    }\n\n    return root;\n}\n\nvoid printTree_pre_order(TreeNode *root)\n{\n    if (root == NULL){\n        printf(\"# \");\n        return;\n    }\n    printf(\"%c \", root->val );\n\n    printTree_pre_order(root->left);\n    printTree_pre_order(root->right);\n}\n\nvoid printTree_in_order(TreeNode *root)\n{\n    if (root == NULL){\n        printf(\"# \");\n        return;\n    }\n\n    printTree_in_order(root->left);\n    printf(\"%c \", root->val );\n    printTree_in_order(root->right);\n}\n\n\nvoid printTree_level_order(TreeNode *root)\n{\n    queue<TreeNode*> q;\n    q.push(root);\n    while (q.size()>0){\n        TreeNode* n = q.front();\n        q.pop();\n        if (n==NULL){\n            printf(\"# \");\n            continue;\n        }\n        printf(\"%c \", n->val);\n        q.push(n->left);\n        q.push(n->right);\n    }\n    printf(\"\\n\");\n}\n\n\nint main()\n{\n    int pre_order[]={'F', 'B', 'A', 'D', 'C', 'E', 'G', 'I', 'H'};\n    int  in_order[]={'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'};\n    vector<int> preorder( pre_order, pre_order + 9 );\n    vector<int>  inorder(  in_order,  in_order + 9 );\n\n    TreeNode* tree = buildTree(preorder, inorder);\n\n    printTree_level_order(tree);\n    printTree_pre_order(tree);\n    printf(\"\\n\");\n    printTree_in_order(tree);\n    printf(\"\\n\");\n    \n    return 0;\n}\n"
  },
  {
    "question_theme": "populatingNextRightPointersInEachNode",
    "question": "/********************************************************************************** \n* \n* Follow up for problem \"Populating Next Right Pointers in Each Node\".\n* What if the given tree could be any binary tree? Would your previous solution still work?\n* \n* Note:\n* You may only use constant extra space.\n* \n* For example,\n* Given the following binary tree,\n* \n*          1\n*        /  \\\n*       2    3\n*      / \\    \\\n*     4   5    7\n* \n* After calling your function, the tree should look like:\n* \n*          1 -> NULL\n*        /  \\\n*       2 -> 3 -> NULL\n*      / \\    \\\n*     4-> 5 -> 7 -> NULL\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\n// Author : Hao Chen\n// Date   : 2014-06-19\n\n\n\n#include <stdio.h>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n\nstruct TreeLinkNode {\n    int val;\n    TreeLinkNode *left, *right, *next;\n    TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}\n    TreeLinkNode() : val(0), left(NULL), right(NULL), next(NULL) {}\n};\nvoid connect(TreeLinkNode *root) {\n    if (root==NULL) return;\n\n    if (root->left && root->right){\n        root->left->next = root->right;\n    }\n\n    if (root->next) {\n        \n         TreeLinkNode *left=NULL, *right=NULL;\n         left = root->right ? root->right: root->left;\n\n         for (TreeLinkNode *p = root->next; p!=NULL; p=p->next) {\n             if (p->left){\n                 right = p->left;\n                 break;\n             }\n             if (p->right){\n                 right = p->right;\n                 break;\n             }\n         }\n         if (left){\n             left->next = right;\n         }   \n    }\n    connect(root->right);\n    connect(root->left);\n}\n\nvoid connect1(TreeLinkNode *root) {\n\n    if (root==NULL){\n        return;\n    }\n    \n    vector<TreeLinkNode*> v;\n\n    v.push_back(root);\n    \n    while(v.size()>0){\n        \n        if ( (root->left && root->left->next==NULL) || (root->right && root->right->next==NULL) ) {\n\n            if (root->left && root->right){\n                root->left->next = root->right;\n            }\n            \n            if (root->next){\n                TreeLinkNode *left=NULL, *right=NULL;\n                left = root->right ? root->right: root->left;\n                \n                for (TreeLinkNode *p = root->next; p!=NULL; p=p->next) {\n                    if (p->left){\n                        right = p->left;\n                        break;\n                    }\n                    if (p->right){\n                        right = p->right;\n                        break;\n                    }\n                }\n\n                if (left){\n                    left->next = right;\n                }   \n            }\n            if (root->left) {\n                v.push_back(root->left);\n            }\n            if (root->right) {\n                v.push_back(root->right);\n            }\n        }\n        root = v.back();\n        v.pop_back();\n    }\n}\n\nvoid connect3(TreeLinkNode *root) {\n    if(root == NULL) return;\n\n    queue<TreeLinkNode*> q;\n    TreeLinkNode *prev, *last;\n    prev = last = root;\n\n    q.push(root);\n    while(!q.empty()) {\n        TreeLinkNode* p = q.front();\n        q.pop();\n\n        prev->next = p;\n        if(p->left ) q.push(p->left);\n        if(p->right) q.push(p->right);\n\n        if(p == last) { // meets last of current level\n            // now, q contains all nodes of next level\n            last = q.back();\n            p->next = NULL; // cut down.\n            prev = q.front();\n        }\n        else {\n            prev = p;\n        }\n    }\n}\n\n// constant space\n// key point: we can use `next` pointer to represent\n//      the buffering queue of level order traversal.\nvoid connect4(TreeLinkNode *root) {\n    if(root == NULL) return;\n\n    TreeLinkNode *head, *tail;\n    TreeLinkNode *prev, *last;\n\n    head = tail = NULL;\n    prev = last = root;\n\n#define push(p) \\\n    if(head == NULL) { head = tail = p; } \\\n    else { tail->next = p; tail = p; }\n\n    push(root);\n    while(head != NULL) {\n        TreeLinkNode* p = head;\n        head = head->next; // pop\n\n        prev->next = p;\n        if(p->left ) push(p->left);\n        if(p->right) push(p->right);\n\n        if(p == last) {\n            last = tail;\n            p->next = NULL; // cut down.\n            prev = head;\n        }\n        else {\n            prev = p;\n        }\n    }\n#undef push\n}\n\nvoid printTree(TreeLinkNode *root){\n    if (root == NULL){\n        return;\n    }\n    printf(\"[%2d] : left[%d], right[%d], next[%d]\\n\",\n            root->val,\n            root->left ? root->left->val : -1,\n            root->right ? root->right->val : -1,\n            root->next?root->next->val : -1 );\n\n    printTree(root->left);\n    printTree(root->right);\n\n}\n\n\nint main()\n{\n    const int cnt = 15; \n    TreeLinkNode a[cnt];\n    for(int i=0; i<cnt; i++){\n        a[i].val = i+1;\n    } \n    \n    for(int i=0, pos=0; pos<cnt-1; i++ ){\n        a[i].left = &a[++pos];\n        a[i].right = &a[++pos];\n    }\n    a[5].left = a[5].right = NULL;\n    a[3].right = NULL;\n\n    //a[1].right = NULL;\n    //a[2].left = NULL;\n\n    //a[3].left = &a[4];\n    //a[6].right= &a[5];\n    TreeLinkNode b(100), c(200);\n    //a[3].left = &b;\n    //a[6].right = &c;\n    a[9].left = &b;\n\n    connect(&a[0]); \n\n    printTree(&a[0]);\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "partitionEqualSubsetSum",
    "question": "/*************************************************************************************** \n *\n * Given a non-empty array containing only positive integers, find if the array can be \n * partitioned into two subsets such that the sum of elements in both subsets is equal.\n * \n * \n * Note:\n * \n * Each of the array element will not exceed 100.\n * The array size will not exceed 200.\n * \n * \n * \n * Example 1:\n * \n * Input: [1, 5, 11, 5]\n * \n * Output: true\n * \n * Explanation: The array can be partitioned as [1, 5, 5] and [11].\n * \n * \n * \n * Example 2:\n * \n * Input: [1, 2, 3, 5]\n * \n * Output: false\n * \n * Explanation: The array cannot be partitioned into equal sum subsets.\n * \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/partition-equal-subset-sum/description/\n// Author : Hao Chen\n// Date   : 2018-06-24\n\n\n\nclass Solution {\npublic:\n    //back tracking\n    bool canPartitionRecrusion(vector<int>& nums, int half, int index) {\n        for (int i=index; i<nums.size(); i++){\n            int h = half - nums[i];\n            if ( h < 0 ) return false; //cannot found the solution\n            if ( h == 0 ) return true; //found the solution\n            if ( canPartitionRecrusion(nums, h, i+1) == true ) return true;\n        }\n        return false;\n    }\n\n    \n    bool canPartition(vector<int>& nums) {\n        int sum = 0;\n        for(auto n : nums) sum +=n;\n        if ( sum & 1 ) return false; // sum % 2 !=  1\n        int half = sum / 2;\n        \n        //sort the array in descending order\n        //so, the DFS could be very fast to find the answer because it's greedy.\n        std::sort(nums.begin(), nums.end(), std::greater<int>()); \n\n        //go to find a path which sum is half\n        return canPartitionRecrusion(nums, half, 0);\n    }\n};\n"
  },
  {
    "question_theme": "rotateList",
    "question": "/********************************************************************************** \n* \n* Given a list, rotate the list to the right by k places, where k is non-negative.\n* \n* For example:\n* Given 1->2->3->4->5->NULL and k = 2,\n* return 4->5->1->2->3->NULL.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/rotate-list/\n// Author : Hao Chen\n// Date   : 2014-06-20\n\n\n\n\nclass Solution {\npublic:\n    ListNode *rotateRight(ListNode *head, int k) {\n        if (!head || k<=0){\n            return head;\n        }\n        \n        //find the length of List\n        int len=1;\n        ListNode *p=head;\n        while( p->next != NULL ){\n            p = p->next;\n            len++;\n        }\n        //connect the tail to head\n        p->next = head;\n        //find the left place (take care the case - k > len)\n        k = len - k % len;\n        \n        //find the place\n        for(int i=0; i<k; i++){\n            p = p->next;\n        }\n        \n        //break the list\n        head = p->next;\n        p->next = NULL;\n        \n        return head;\n        \n    }\n};\n"
  },
  {
    "question_theme": "buddyStrings",
    "question": "/*************************************************************************************** \n *\n * Given two strings A and B of lowercase letters, return true if and only if we can \n * swap two letters in A so that the result equals B.\n * \n *  \n * \n * Example 1:\n * \n * \n * \n * Input: A = \"ab\", B = \"ba\"\n * Output: true\n * \n * \n * \n * Example 2:\n * \n * \n * Input: A = \"ab\", B = \"ab\"\n * Output: false\n * \n * \n * \n * Example 3:\n * \n * \n * Input: A = \"aa\", B = \"aa\"\n * Output: true\n * \n * \n * \n * Example 4:\n * \n * \n * Input: A = \"aaaaaaabc\", B = \"aaaaaaacb\"\n * Output: true\n * \n * \n * \n * Example 5:\n * \n * \n * Input: A = \"\", B = \"aa\"\n * Output: false\n * \n * \n *  \n * \n * Note:\n * \n * \n * \t0 <= A.length <= 20000\n * \t0 <= B.length <= 20000\n * \tA and B consist only of lowercase letters.\n * \n * \n * \n * \n * \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/buddy-strings/description/\n// Author : Hao Chen\n// Date   : 2018-06-27\n\n\n\n\n\nclass Solution {\npublic:\n    bool buddyStrings(string A, string B) {\n        if (A.size() != B.size()) return false;\n        if (A.size()<2) return false;\n        \n        bool bRepeat = false;\n        bool map[26] = {false};\n        int idx[2], diffCnt=0;\n        \n        for (int i=0; i<A.size(); i++){\n            if (map[A[i]-'a']) { bRepeat = true;}\n            map[A[i]-'a']=true;\n            if ( A[i] != B[i] ) {\n                if (diffCnt>=2) return false;\n                idx[diffCnt++] = i;\n                \n            }\n        }\n        //if A == B and there has repeated chars , then return true\n        if (diffCnt==0 && bRepeat) return true;\n        \n        return (A[idx[0]] == B[idx[1]] && A[idx[1]] == B[idx[0]]);\n        \n    }\n};\n"
  },
  {
    "question_theme": "h-Index",
    "question": "/*************************************************************************************** \n *\n * Follow up for H-Index: What if the citations array is sorted in ascending order?\n * Could you optimize your algorithm?\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/h-index-ii/\n// Author : Hao Chen\n// Date   : 2015-11-08\n\n\n\n\n\nclass Solution {\npublic:\n    // binary search - O(log(n))\n    int hIndex(vector<int>& citations) {\n        int n = citations.size();\n        int low = 0, high = n-1;\n        \n        while( low <= high ) {\n            int mid = low + (high-low)/2;\n            if (citations[mid] == n - mid) {\n                return n - mid;\n            }else if (citations[mid] > n-mid){\n                high = mid - 1;\n            }else {\n                low = mid + 1;\n            }\n        }\n        return n-low;\n    }\n};\n"
  },
  {
    "question_theme": "firstMissingPositive",
    "question": "/********************************************************************************** \n* \n* Given an unsorted integer array, find the first missing positive integer.\n* \n* For example,\n* Given [1,2,0] return 3,\n* and [3,4,-1,1] return 2.\n* \n* Your algorithm should run in O(n) time and uses constant space.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/first-missing-positive/\n// Author : Hao Chen\n// Date   : 2014-07-18\n\n\n#include <stdlib.h>\n#include <time.h>\n#include <iostream>\n#include <map>\nusing namespace std;\n\n#define INT_MAX      2147483647\n\n\nint firstMissingPositive_move(int A[], int n) {\n    if (n<=0) return 1;\n    int num;\n    for(int i=0; i<n; i++) {\n        num = A[i];\n        while (num>0 && num<n && A[num-1]!=num) {\n            swap(A[i], A[num-1]);\n            num = A[i];\n        }\n    }\n    for (int i=0; i<n; i++){\n        if (i+1 != A[i]){\n            return i+1;\n        }\n    }\n    return n+1;\n}\n\n\nint firstMissingPositive_map(int A[], int n) {\n    map<int, int> cache;\n    for(int i=0; i<n; i++){\n        cache[A[i]] = i;\n    }\n\n    //add dummy\n    if (cache.find(0)==cache.end() ) {\n        cache[0] = -1;\n    }\n\n    int miss = INT_MAX;\n    int x;\n    for (int i=-1; i<n && cache.size()>0; i++){\n\n        if (i == -1){\n            x = 0; //checking dummy\n        }else{\n            x = A[i];\n        } \n\n        if ( cache.find(x)==cache.end() ){\n            continue;\n        }\n\n        int num ;\n        // remove the ... x-3, x-2, x-1, x\n        for( num=x; cache.find(num)!=cache.end(); num--){\n            cache.erase(cache.find(num));\n        }\n        if ( num>0 && num < miss  ){\n            miss = num;\n        }\n        // remove the x+1, x+2, x+3 ...\n        for ( num=x+1; cache.find(num)!=cache.end(); num++){\n            cache.erase(cache.find(num));\n        }\n        if ( num>0 && num < miss) {\n            miss = num;\n        }\n    }\n\n\n    return miss;\n}\n\nint firstMissingPositive(int A[], int n) {\n    srand(time(0));\n    if (rand()%2){\n        return firstMissingPositive_move(A, n);\n    }\n    return firstMissingPositive_map(A, n);\n}\n\n\nvoid printArray(int a[], int n){\n    cout << \"[ \";\n    for(int i=0; i<n-1; i++) {\n        cout << a[i] << \", \";\n    }\n    cout << a[n-1] << \" ]\";\n}\n\nvoid Test(int a[], int n, int expected) {\n    printArray(a, n);\n    int ret = firstMissingPositive(a, n);\n    cout << \"\\t   missed = \" << ret << \"  \" << (ret==expected?\"passed!\":\"failed!\") << endl;\n    //printArray(a, n);\n    //cout <<endl;\n}\n\nint main()\n{\n#define TEST(a, e) Test(a, sizeof(a)/sizeof(int), e) \n\n    int a0[]={1};\n    TEST(a0, 2);\n\n    int a1[]={1,2,0};\n    TEST(a1, 3);\n\n    int a2[]={3,4,-1,1};\n    TEST(a2, 2);\n\n    int a3[]={1000,-1};\n    TEST(a3, 1);\n\n    int a4[]={1000, 200};\n    TEST(a4, 1);\n\n    int a5[]={2,5,3,-1};\n    TEST(a5, 1);\n\n    int a6[]={1, 100};\n    TEST(a6, 2);\n\n    int a7[]={7,8,9,11};\n    TEST(a7, 1);\n\n    int a8[]={4,3,2,1};\n    TEST(a8, 5);\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "happyNumber",
    "question": "/********************************************************************************** \n * \n * Write an algorithm to determine if a number is \"happy\".\n * \n * A happy number is a number defined by the following process: Starting with any positive integer, \n * replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 \n * (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this \n * process ends in 1 are happy numbers.\n * \n * Example:\u00a019 is a happy number\n * \n * 1^2 + 9^2 = 82\n * 8^2 + 2^2 = 68\n * 6^2 + 8^2 = 100\n * 1^2 + 0^2 + 0^2 = 1\n * \n * Credits:Special thanks to @mithmatt and @ts for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/happy-number/\n// Author : Hao Chen\n// Date   : 2015-06-08\n\n\n#include <stdlib.h>\n#include <iostream>\n#include <map>\nusing namespace std;\n\nint squares(int n) {\n    int result = 0;\n    int sq = 0;\n    for (; n>0; n/=10) {\n        sq = n%10;\n        result += (sq * sq);\n    }\n    return result;\n}\n\nbool isHappy(int n) {\n\n    if (n==1) return true;\n\n    map<int, bool> m;\n    m[n]=true;\n\n    while (n!=1) {\n        n = squares(n);\n        //cout << n << endl;\n        if (m.find(n) != m.end()){\n            return false;\n        }\n        m[n] = true;\n    }\n\n    return true;\n}\n\n\nint main(int argc, char** argv) \n{\n    int n = 2;\n    if (argc > 1){\n        n = atoi(argv[1]);\n    }\n    cout << n << (isHappy(n) ? \" is \" : \" isn't \") << \"a happy number\" << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "maximumProductOfWordLengths",
    "question": "/*************************************************************************************** \n *\n * Given a string array words, find the maximum value of length(word[i]) * \n * length(word[j]) where the two words do not share common letters.\n *     You may assume that each word will contain only lower case letters.\n *     If no such two words exist, return 0.\n * \n *     Example 1:\n * \n *     Given [\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"]\n *     Return 16\n *     The two words can be \"abcw\", \"xtfn\".\n * \n *     Example 2:\n * \n *     Given [\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"]\n *     Return 4\n *     The two words can be \"ab\", \"cd\".\n * \n *     Example 3:\n * \n *     Given [\"a\", \"aa\", \"aaa\", \"aaaa\"]\n *     Return 0\n *     No such pair of words.    \n * \n * Credits:Special thanks to @dietpepsi for adding this problem and creating all test \n * cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/maximum-product-of-word-lengths/\n// Author : Hao Chen\n// Date   : 2017-01-02\n\n\n\nclass Solution {\npublic:\n    //\n    // there are two algorithms:\n    //\n    // 1) compare two words is same or not \n    //    - we can use bit-mask to solve that. \n    //    - we need be careful about one word is subset of another one, such as: \"abc\" is subset of \"abcabc\"\n    //\n    // 2) find out the max product - that needs O(N^2) time complexity algorithm.\n    //\n\n    int maxProduct(vector<string>& words) {\n        //Key is the word's bitmask, and the value the max length of that bit mask\n        unordered_map<int, int> maxLens;\n        //constructing the bitmask.\n        for(auto& w: words) {\n            int mask = 0;\n            for (auto& c: w) {\n                mask = mask | ( 1 << (c-'a') );\n            }\n            if ( maxLens.find(mask) == maxLens.end() || maxLens[mask] < w.size() ) {\n                maxLens[mask] = w.size();\n            }\n        }\n        \n        //find out the max product\n        int result = 0;\n        for (auto a : maxLens) {\n            for (auto b: maxLens) {\n                // if `a` and `b` is same, then just simply continue\n                if (a.first & b.first) continue; // there are common letters\n                result = max( result, a.second * b.second );\n            }\n        }\n        \n        return result;\n    }\n};\n"
  },
  {
    "question_theme": "copyListWithRandomPointer",
    "question": "/********************************************************************************** \n* \n* A linked list is given such that each node contains an additional random pointer \n* which could point to any node in the list or null.\n* \n* Return a deep copy of the list.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/copy-list-with-random-pointer/\n// Author : Hao Chen\n// Date   : 2014-06-18\n\n\n\n\n\n\n\n\n\n\nclass Solution {\npublic:\n    RandomListNode *copyRandomList(RandomListNode *head) {\n        RandomListNode *p = NULL, *h=NULL, *t=NULL;\n        if (head == NULL){\n            return NULL;\n        }\n        \n        //creat a new node for each node and insert its next\n        p = head;\n        while ( p != NULL){\n            RandomListNode *node = new RandomListNode(p->label);\n            node->next = p->next;\n            p->next = node;\n            p = node->next;\n        }\n        \n        //copy random pointer for each new node\n        p = head;\n        while (p != NULL){\n            if (p->random != NULL){\n                p->next->random = p->random->next;\n            }\n            p = p->next->next;\n        }\n        \n        //break to two list\n        p = head;\n        h = t = head->next;\n        while ( p != NULL ){\n            p->next = p->next->next;\n            if (t->next!=NULL){\n                t->next = t->next->next;\n            }\n            \n            p = p->next;\n            t = t->next;\n        }\n        \n        return h;\n    }\n};\n\n\n \nclass MySolution {\npublic:\n    RandomListNode *copyRandomList(RandomListNode *head) {\n\n        RandomListNode *p = NULL, *h=NULL, *t=NULL;\n        //using a map to store the random pointer's postion.\n        map<RandomListNode*, int> m;\n        //construct the map\n        int pos =0;\n        for ( p = head; p != NULL; p = p->next, pos++){\n            m[p] = pos;\n        }\n        \n        //clone the linked list  (only consider the next pointer)\n        //and using a vector to store each node's postion.\n        vector<RandomListNode*> v;\n        for (p = head; p != NULL; p = p->next){\n            RandomListNode *node = new RandomListNode(p->label);\n            v.push_back(node);\n            if (h==NULL){\n                h = t = node;\n            }else{\n                t->next = node;\n                t = node;\n            }\n        }\n\n        //p => source link head \n        //t => new link head\n        //move the p and t synchronously, and \n        //     t->random = vector[ map[p->random] ];\n        for (t=h, p = head; t!=NULL && p!= NULL; p=p->next, t=t->next){\n            if (p->random!=NULL) {\n                pos = m[p->random];\n                t->random = v[pos];\n            }\n        }\n        \n        return h;\n        \n    }\n};\n"
  },
  {
    "question_theme": "differentWaysToAddParentheses",
    "question": "/********************************************************************************** \n * \n * Given a string of numbers and operators, return all possible results from computing \n * all the different possible ways to group numbers and operators. The valid operators \n * are +, - and *.\n * \n * Example 1\n * Input: \"2-1-1\". \n * ((2-1)-1) = 0\n * (2-(1-1)) = 2\n * Output: [0, 2]\n * \n * Example 2\n * Input: \"2*3-4*5\" \n * (2*(3-(4*5))) = -34\n * ((2*3)-(4*5)) = -14\n * ((2*(3-4))*5) = -10\n * (2*((3-4)*5)) = -10\n * (((2*3)-4)*5) = 10\n * Output: [-34, -14, -10, -10, 10] \n * \n * Credits:Special thanks to @mithmatt for adding this problem and creating all test \n * cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/different-ways-to-add-parentheses/\n// Author : Hao Chen\n// Date   : 2015-08-15\n\n\n#include <stdlib.h>\n#include <ctype.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\n\nbool isOperator(char ch){\n    return (ch=='+' || ch=='-' || ch=='*');\n}\n\n\n//Divide & Conque  - recursive way\nvector<int> diffWaysToCompute(string input) {\n    //if the result has been cacluated, then just get it from the cache and return \n    static map< string, vector<int> > cache;\n    if ( cache.find(input) != cache.end() ){\n        return cache[input];\n    }\n\n\n    vector<int> result; \n    for (int i=0; i<input.size(); i++){\n        char ch = input[i];\n        if (isOperator(ch)){\n            //split the input to two parts, left part and right part \n            //And recursively invoke this function.\n            string left  = input.substr(0, i);\n            string right = input.substr(i+1);\n            vector<int> lv = diffWaysToCompute(left);\n            vector<int> rv = diffWaysToCompute(right);\n\n            //merge two result to one\n            for(int li=0; li<lv.size(); li++) {\n                for(int ri=0; ri<rv.size(); ri++) {\n                    switch(ch){\n                        case '+' : result.push_back(lv[li] + rv[ri]); break;\n                        case '-' : result.push_back(lv[li] - rv[ri]); break;\n                        case '*' : result.push_back(lv[li] * rv[ri]); break;\n                    }\n                }\n            }\n\n        }\n    }\n    //if we cannot find the \"operator\" in input, \n    //which means, it is a number, just put the number into the result. \n    if (result.size()==0) {\n        result.push_back(atoi(input.c_str()));\n    }\n    \n    //cache the result, key = input, value = result;\n    cache[input] = result;\n\n    return result;\n}\n\nvoid printVector(vector<int>& v) {\n    cout << \"[\";\n    for(int i=0; i<v.size(); i++) {\n        cout << v[i] << (i==v.size()-1 ? \"]\":\", \");\n    }\n    cout << endl;\n}\n\nint main(int argc, char**argv) \n{\n    string exp = \"2*3-4*5\";\n    if ( argc > 1 ){\n        exp = argv[1];\n    }\n    vector<int> v = diffWaysToCompute(exp);\n    cout << exp << endl;\n    printVector(v);\n    return 0;\n}\n\n"
  },
  {
    "question_theme": "addDigits",
    "question": "/********************************************************************************** \n * Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\n *\n * For example:\n * Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.\n *\n * Follow up:\n * \tCould you do it without any loop/recursion in O(1) runtime?\n *\n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/add-digits/\n// Author : Timothy Lim, Hao Chen\n// Date   : 2015-10-1\n\n\n\nclass Solution {\n    public:\n\n        int addDigits(int num) {\n            switch(random()%5+1){\n                case 1: return addDigits01(num);\n                case 2: return addDigits02(num);\n                case 3: return addDigits03(num);\n                case 4: return addDigits04(num);\n                default: return addDigits05(num);\n            }\n\n        }\n\n        //regualr way\n        int addDigits01(int num) {\n            while(num > 9) {\n                int sum;\n                for(sum=0; num > 0; sum += num%10 , num/=10);\n                num = sum;\n            }\n            return num;\n\n        }\n\n        //This solution looks is very tricky, but acutally it is easy to understand.\n        //it just keep adding the last digital until the num < 10\n        int addDigits02(int num) {\n            while(num > 9) {\n                num = num / 10 + num % 10;\n            }\n            return num;\n\n        }\n\n        // Let's observe the pattern\n        //    1    1\n        //    2    2\n        //    ... ...\n        //    8    8    \n        //    9    9    \n        //    10    1\n        //    11    2\n        //    12    3    \n        //    ... ...\n        //    17    8\n        //    18    9\n        //    19    1\n        //    20    2\n        //    ...  ...\n        // It looks most of number just simply %9 is the answer, \n        // but there are some edge cases.\n        //    9%9=0 but we need 9. \n        //    18%9=0 but we need 9\n        // so we can find the solution is:\n        //    1) num <=9, return num\n        //    2) num > 9, reutrn num%9 if num%9>0\n        //                return 9 if num%9 ==0\n        int addDigits03(int num) {\n            return num >9 ? ((num %9)==0 ? 9:num%9) : num;\n        }\n\n        //But actually, we can use (num-1)%9 + 1 to make all cases right.\n        int addDigits04(int num){\n            return (num - 1) % 9 + 1;\n        }\n\n        //This solution is similar with pervious solution.\n        int addDigits05(int num){\n            return num - 9 * ((num - 1)/9);\n        }\n\n};\n"
  },
  {
    "question_theme": "insertionSortList",
    "question": "/********************************************************************************** \n* \n* Sort a linked list using insertion sort.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/insertion-sort-list/\n// Author : Hao Chen\n// Date   : 2014-07-19\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode *insertionSortList(ListNode *head) {\n    // zero or one element in list\n    if (head == NULL || head->next ==NULL){\n        return head;\n    }\n\n    ListNode *pSorted = NULL;\n    while ( head != NULL  ){\n        \n        ListNode *pHead = head;\n        \n        ListNode **ppTrail = &pSorted;\n        \n        \n        head = head->next;\n        \n        \n        while( *ppTrail!=NULL && pHead->val > (*ppTrail)->val )  {\n            ppTrail = &(*ppTrail)->next;\n        }\n        pHead->next = *ppTrail;\n        *ppTrail = pHead;\n    }\n\n    return pSorted;\n}\n\nvoid printList(ListNode* h)\n{\n    while(h!=NULL){\n        printf(\"%d \", h->val);\n        h = h->next;\n    }\n    printf(\"\\n\");\n}\n\nListNode* createList(int a[], int n)\n{\n    ListNode *head=NULL, *p=NULL;\n    for(int i=0; i<n; i++){\n        if (head == NULL){\n            head = p = new ListNode(a[i]);\n        }else{\n            p->next = new ListNode(a[i]);\n            p = p->next;\n        }\n    }\n    return head;\n}\n\n\nint main(int argc, char** argv)\n{\n    int n = 10;\n    if (argc>1){\n        n = atoi(argv[1]);\n    }\n    srand(time(NULL));\n\n    int *a = new int[n];\n    for(int i=0; i<n; i++){\n        a[i] = random()%n + 1;\n    }\n\n    ListNode *p = createList(a, n);\n    printList(p);\n    printList(insertionSortList(p));\n\n    delete[] a;\n}\n"
  },
  {
    "question_theme": "isomorphicStrings",
    "question": "/********************************************************************************** \n * \n * Given two strings s and t, determine if they are isomorphic.\n * \n * Two strings are isomorphic if the characters in s can be replaced to get t.\n * \n * All occurrences of a character must be replaced with another character while preserving \n * the order of characters. No two characters may map to the same character but a character\n *  may map to itself.\n * \n * For example,\n *\n *     Given \"egg\", \"add\", return true.\n *     \n *     Given \"foo\", \"bar\", return false.\n *     \n *     Given \"paper\", \"title\", return true.\n * \n * Note:\n * You may assume both s and t have the same length.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/isomorphic-strings/\n// Author : Hao Chen\n// Date   : 2015-06-09\n\n\n\n\nclass Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        if (s.size()!=t.size()) return false;\n        \n        const int MAXCHAR = 256;\n        char maps[MAXCHAR]={0}, mapt[MAXCHAR]={0};\n        //memset(maps, 0, sizeof(maps));\n        //memset(mapt, 0, sizeof(mapt));\n        \n        for(int i=0; i<s.size(); i++){\n            if(maps[s[i]] == 0 && mapt[t[i]] == 0){\n                maps[s[i]] = t[i];\n                mapt[t[i]] = s[i];\n                continue;\n            }\n            if(maps[s[i]] == t[i] && mapt[t[i]] == s[i]) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n};\n"
  },
  {
    "question_theme": "searchInsertPosition",
    "question": "/********************************************************************************** \n* \n* Given a sorted array and a target value, return the index if the target is found. \n* If not, return the index where it would be if it were inserted in order.\n* \n* You may assume no duplicates in the array.\n* \n* Here are few examples.\n* [1,3,5,6], 5 \u2192 2\n* [1,3,5,6], 2 \u2192 1\n* [1,3,5,6], 7 \u2192 4\n* [1,3,5,6], 0 \u2192 0\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/search-insert-position/\n// Author : Hao Chen\n// Date   : 2014-06-22\n\n\n\n#include <stdio.h>\n\n\nint binary_search(int A[], int n, int key) {\n    int low = 0;\n    int high = n-1;\n    while (low <= high){\n        int mid = low +(high-low)/2;\n        if (A[mid] == key){\n            return mid;\n        }\n        if ( key> A[mid] ) {\n            low = mid+1;\n        }else{\n            high = mid-1;\n        }\n    }\n    return low;\n}\nint searchInsert(int A[], int n, int target) {\n    if (n==0) return n;\n    return binary_search(A, n, target);\n}\n\nint main()\n{\n    int a[]={1,3,5,6};\n    printf(\"%d -> %d\\n\", 5, searchInsert(a, 4, 5));\n    printf(\"%d -> %d\\n\", 2, searchInsert(a, 4, 2));\n    printf(\"%d -> %d\\n\", 7, searchInsert(a, 4, 7));\n    printf(\"%d -> %d\\n\", 0, searchInsert(a, 4, 0));\n    return 0;\n}\n"
  },
  {
    "question_theme": "findTheDifference",
    "question": "/*************************************************************************************** \n *\n * Given two strings s and t which consist of only lowercase letters.\n * \n * String t is generated by random shuffling string s and then add one more letter at a \n * random position.\n * \n * Find the letter that was added in t.\n * \n * Example:\n * \n * Input:\n * s = \"abcd\"\n * t = \"abcde\"\n * \n * Output:\n * e\n * \n * Explanation:\n * 'e' is the letter that was added.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/find-the-difference/\n// Author : Hao Chen\n// Date   : 2016-09-08\n\n\n\nclass Solution {\npublic:\n    char findTheDifference(string s, string t) {\n        unordered_map<char, int> m;\n        for(auto c : s) m[c]++;\n        for(auto c : t) {\n            m[c]--;\n            if (m[c] < 0) return c;\n        }\n        return '\\0';\n    }\n};\n"
  },
  {
    "question_theme": "integerReplacement",
    "question": "/*************************************************************************************** \n *\n * Given a positive integer n and you can do operations as follow:\n * \n * If n is even, replace n with n/2.\n * If n is odd, you can replace n with either n + 1 or n - 1.\n * \n * What is the minimum number of replacements needed for n to become 1?\n * \n * Example 1:\n * \n * Input:\n * 8\n * \n * Output:\n * 3\n * \n * Explanation:\n * 8 -> 4 -> 2 -> 1\n * \n * Example 2:\n * \n * Input:\n * 7\n * \n * Output:\n * 4\n * \n * Explanation:\n * 7 -> 8 -> 4 -> 2 -> 1\n * or\n * 7 -> 6 -> 3 -> 2 -> 1\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/integer-replacement/\n// Author : Hao Chen\n// Date   : 2016-11-04\n\n\n\nclass Solution {\npublic:\n\n\n    int integerReplacement_recursion(int n) {\n        if ( n <= 1) return 0; // recursive exited point\n        if ( n == INT_MAX ) return 32; // special case to avoid integer overflow.\n        if ( n % 2 == 0 ) return integerReplacement(n/2) + 1;\n        return min( integerReplacement(n+1), integerReplacement(n-1) ) + 1;\n    }\n    \n    int integerReplacement_recursionWithCache(int n) {\n        static unordered_map<int, int> cache;\n        //if hitted the cache, just return the result\n        if (cache.find(n) != cache.end()) return cache[n];\n        \n        int result;\n        if ( n <= 1) return 0; // recursive exited point\n        if ( n == INT_MAX ) return 32; // special case to avoid integer overflow.\n        if ( n % 2 == 0 ) result = integerReplacement(n/2) + 1;\n        else result = min( integerReplacement(n+1), integerReplacement(n-1) ) + 1;\n        \n        //add into cache\n        cache[n] = result;\n        return result;\n    }\n    \n    int integerReplacement_simple(int n){\n        int ans = 0;\n        size_t m = n;\n        while (1 != m) {\n            if (1 == (m & 1)) {\n                if (m==3) --m; //special case\n                else m = (m&0b11^0b01) ? m + 1 : m - 1;\n            }\n            else m >>= 1;\n            ++ans;\n        }\n    return ans;\n    }\n\n    int integerReplacement(int n) {\n        return integerReplacement_recursionWithCache(n);\n        return integerReplacement_simple(n);\n    }\n};\n"
  },
  {
    "question_theme": "stringToIntegerAtoi",
    "question": "/********************************************************************************** \n* \n* Implement atoi to convert a string to an integer.\n* \n* Hint: Carefully consider all possible input cases. If you want a challenge, \n*       please do not see below and ask yourself what are the possible input cases.\n* \n* Notes: \n*   It is intended for this problem to be specified vaguely (ie, no given input specs). \n*   You are responsible to gather all the input requirements up front. \n* \n* \n* Requirements for atoi:\n* \n* The function first discards as many whitespace characters as necessary until the first \n* non-whitespace character is found. Then, starting from this character, takes an optional \n* initial plus or minus sign followed by as many numerical digits as possible, and interprets \n* them as a numerical value.\n* \n* The string can contain additional characters after those that form the integral number, \n* which are ignored and have no effect on the behavior of this function.\n* \n* If the first sequence of non-whitespace characters in str is not a valid integral number, \n* or if no such sequence exists because either str is empty or it contains only whitespace \n* characters, no conversion is performed.\n* \n* If no valid conversion could be performed, a zero value is returned. If the correct value \n* is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) \n* is returned.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/string-to-integer-atoi/\n// Author : Hao Chen\n// Date   : 2014-06-18\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#define INT_MIN     (-2147483647 - 1)\n#define INT_MAX      2147483647\n\nint atoi(const char *str) {\n    if (str==NULL || *str=='\\0'){\n        return 0;\n    }\n    \n    int ret=0;\n    \n    for(;isspace(*str); str++);\n    \n    bool neg=false;\n    if (*str=='-' || *str=='+') {\n        neg = (*str=='-') ;\n        str++;\n    }\n    \n    for(; isdigit(*str); str++) {\n        int digit = (*str-'0');\n        if(neg){\n            if( -ret < (INT_MIN + digit)/10 ) {\n                return INT_MIN;\n            }\n        }else{\n            if( ret > (INT_MAX - digit) /10 ) {\n                return INT_MAX;\n            }\n        }\n\n        ret = 10*ret + digit ;\n    }\n    \n    return neg?-ret:ret;\n}\n\n\nint main()\n{\n    printf(\"\\\"%s\\\" = %d\\n\", \"123\", atoi(\"123\"));\n    printf(\"\\\"%s\\\" = %d\\n\", \"   123\", atoi(\"    123\"));\n    printf(\"\\\"%s\\\" = %d\\n\", \"+123\", atoi(\"+123\"));\n    printf(\"\\\"%s\\\" = %d\\n\", \" -123\", atoi(\" -123\"));\n    printf(\"\\\"%s\\\" = %d\\n\", \"123ABC\", atoi(\"123ABC\"));\n    printf(\"\\\"%s\\\" = %d\\n\", \" abc123ABC\", atoi(\" abc123ABC\"));\n    printf(\"\\\"%s\\\" = %d\\n\", \"2147483647\", atoi(\"2147483647\"));\n    printf(\"\\\"%s\\\" = %d\\n\", \"-2147483648\", atoi(\"-2147483648\"));\n    printf(\"\\\"%s\\\" = %d\\n\", \"2147483648\", atoi(\"2147483648\"));\n    printf(\"\\\"%s\\\" = %d\\n\", \"-2147483649\", atoi(\"-2147483649\"));\n    return 0;\n}\n"
  },
  {
    "question_theme": "rotateFunction",
    "question": "/*************************************************************************************** \n *\n * Given an array of integers A and let n to be its length.\n * \n * Assume Bk to be an array obtained by rotating the array A k positions clock-wise, we \n * define a \"rotation function\" F on A as follow:\n * \n * F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1].\n * \n * Calculate the maximum value of F(0), F(1), ..., F(n-1). \n * \n * Note:\n * n is guaranteed to be less than 105.\n * \n * Example:\n * \n * A = [4, 3, 2, 6]\n * \n * F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\n * F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\n * F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\n * F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\n * \n * So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/rotate-function/\n// Author : Hao Chen\n// Date   : 2016-11-03\n\n\n\n\n// \n// Asumming we have 4 numbers: a, b, c, d, then\n//   F(0) = 0a + 1b + 2c + 3d\n//   F(1) = 3a + 0b + 1c + 2d\n//   F(2) = 2a + 3b + 0c + 1d\n//   F(3) = 1a + 2b + 3c + 0d\n//\n// We can see how F(n) transfrom to F(n+1) \n//   F(0) - F(1) = -3a + b + c + d  \n//   F(1) - F(2) = a + -3b + c + d\n//   F(2) - F(3) = a + b + -3c + d\n//   F(3) - F(0) = a + b + c + -3d\n//   \n// So, we can tansfrom to the following experssion: \n// \n//   F(1) = F(0) - (a+b+c+d) + 4a  \n//   F(2) = F[1] - (a+b+c+d) + 4b\n//   F(3) = F[2] - (a+b+c+d) + 4c\n// \n// Then, we can see this fomular:\n//\n//   F(n) = F(n-1) - sum(array) + len(array) * array[n-1]\n//   \nclass Solution {\npublic:    \n    int maxRotateFunction(vector<int>& A) {\n        int sum = 0;\n        int F = 0;\n        for (int i=0; i < A.size(); i++) {\n            sum += A[i];\n            F += (i * A[i]);\n        }\n        int maxF = F;\n        int len = A.size();\n        //cout << \"F(0) = \" << maxF <<endl;\n        for (int i=1; i< len; i++) {\n            F = F - sum + len * A[i-1];\n            //cout << \"F(\" << i << \") = \" << F << endl;\n            maxF = max(maxF, F);\n        }\n        \n        return maxF;\n    }\n};\n"
  },
  {
    "question_theme": "divideTwoInt",
    "question": "/********************************************************************************** \n* \n* Divide two integers without using multiplication, division and mod operator.\n* \n* If it is overflow, return MAX_INT. \n*\n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/divide-two-integers/\n// Author : Hao Chen\n// Date   : 2014-06-20\n\n\n\n#include <stdio.h>\n#include <string.h>\n#include <iostream>\nusing namespace std;\n\n#define INT_MAX     2147483647\n#define INT_MIN     (-INT_MAX - 1)\n\nint divide(int dividend, int divisor) {\n\n    int sign = (float)dividend / divisor > 0 ? 1 : -1;\n    unsigned int dvd = dividend > 0 ? dividend : -dividend;\n    unsigned int dvs = divisor > 0 ? divisor : -divisor;\n\n    unsigned int bit_num[32];\n    unsigned int i=0;\n    long long d = dvs;\n    bit_num[i] = d;\n    while( d <= dvd ){\n        bit_num[++i] = d = d << 1;\n    }\n    i--;\n\n    unsigned int result = 0;\n    while(dvd >= dvs){\n        if (dvd >= bit_num[i]){\n            dvd -= bit_num[i];\n            result += (1<<i);\n        }else{\n            i--;\n        }\n    }\n\n    //becasue need to return `int`, so we need to check it is overflowed or not.\n    if ( result > INT_MAX && sign > 0 ) {\n        return INT_MAX;\n    }\n    return (int)result * sign;\n}\n\n\nint main()\n{\n    cout << \"0/2=\" << divide(0, 2) << endl;\n    cout << \"10/2=\" << divide(10, 2) << endl;\n    cout << \"10/3=\" << divide(10, 3) << endl;\n    cout << \"10/5=\" << divide(10, 5) << endl;\n    cout << \"10/7=\" << divide(10, 7) << endl;\n    cout << \"10/10=\" << divide(10, 10) << endl;\n    cout << \"10/11=\" << divide(10, 11) << endl;\n    cout << \"-1/1=\" << divide(1, -1) << endl;\n    cout << \"1/-1=\" << divide(1, -1) << endl;\n    cout << \"-1/-1=\" << divide(-1, -1) << endl;\n    cout << \"2147483647/1=\" << divide(2147483647, 1) << endl;\n    cout << \"-2147483647/1=\" << divide(-2147483647, 1) << endl;\n    cout << \"2147483647/-1=\" << divide(2147483647, -1) << endl;\n    cout << \"-2147483647/-1=\" << divide(-2147483647, -1) << endl;\n    cout << \"2147483647/2=\" << divide(2147483647, 2) << endl;\n    cout << \"2147483647/10=\" << divide(2147483647, 10) << endl;\n    cout << \"-2147483648/1=\" << divide(-2147483648, 1) << endl;\n    cout << \"-2147483648/-1=\" << divide(-2147483648, -1) << endl;\n}\n"
  },
  {
    "question_theme": "shuffleAnArray",
    "question": "/*************************************************************************************** \n *\n * Shuffle a set of numbers without duplicates.\n * \n * Example:\n * \n * // Init an array with set 1, 2, and 3.\n * int[] nums = {1,2,3};\n * Solution solution = new Solution(nums);\n * \n * // Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must \n * equally likely to be returned.\n * solution.shuffle();\n * \n * // Resets the array back to its original configuration [1,2,3].\n * solution.reset();\n * \n * // Returns the random shuffling of array [1,2,3].\n * solution.shuffle();\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/shuffle-an-array/\n// Author : Hao Chen\n// Date   : 2016-08-24\n\n\n\nclass Solution {\npublic:\n    Solution(vector<int> nums) : _nums(nums), _solution(nums) {\n        srand(time(NULL));\n    }\n    \n    \n    vector<int> reset() {\n        return _solution = _nums;\n    }\n    \n    \n    vector<int> shuffle() {\n        //Fisher Yates\n        //https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n        \n        int i = _solution.size();\n        \n        while ( --i > 0 ) {\n            int j = rand() % (i+1);\n            swap(_solution[i], _solution[j]);\n        }\n        return _solution;\n    }\nprivate:\n    vector<int> _nums, _solution;\n};\n\n\n"
  },
  {
    "question_theme": "palindromeNumber",
    "question": "/********************************************************************************** \n* \n* Determine whether an integer is a palindrome. Do this without extra space.\n* \n* \n* Some hints:\n* \n* Could negative integers be palindromes? (ie, -1)\n* \n* If you are thinking of converting the integer to string, note the restriction of using extra space.\n* \n* You could also try reversing an integer. However, if you have solved the problem \"Reverse Integer\", \n* you know that the reversed integer might overflow. How would you handle such case?\n* \n* There is a more generic way of solving this problem.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/palindrome-number/\n// Author : Hao Chen\n// Date   : 2014-06-18\n\n\n\n#include <stdio.h>\n\nclass Solution {\npublic:\n\n    bool isPalindrome(int x) {\n        if (x<0) {\n            return false;\n        }\n        \n        int len=1;\n        for (len=1; (x/len) >= 10; len*=10 );\n        \n        while (x != 0 ) {\n            int left = x / len;\n            int right = x % 10;\n            \n            if(left!=right){\n                return false;\n            }\n            \n            x = (x%len) / 10;\n            len /= 100;\n        }\n        return true;\n    }\n    \n    bool isPalindrome2(int x) {\n        return (x>=0 && x == reverse(x));\n    }\n\nprivate:    \n    int reverse(int x) {\n        int y=0;\n\n        int n;\n        while( x!=0 ){\n            n = x%10;\n            y = y*10 + n;\n            x /= 10;\n        }\n        return y;\n    }\n};\n\n\n\nint main()\n{\n    Solution s;\n    printf(\"%d is %d\\n\", 0, s.isPalindrome(0) );\n    printf(\"%d is %d\\n\", -101, s.isPalindrome(-101) );\n    printf(\"%d is %d\\n\", 1001, s.isPalindrome(1001) );\n    printf(\"%d is %d\\n\", 1234321, s.isPalindrome(1234321) );\n    printf(\"%d is %d\\n\", 2147447412, s.isPalindrome(2147447412) );\n    printf(\"%d is %d\\n\", 2142, s.isPalindrome(2142) );\n}\n"
  },
  {
    "question_theme": "maximumProductSubarray",
    "question": "/********************************************************************************** \n* \n* Find the contiguous subarray within an array (containing at least one number) \n* which has the largest product.\n* \n* For example, given the array [2,3,-2,4],\n* the contiguous subarray [2,3] has the largest product = 6.\n* \n* More examples:\n*   \n*   Input: arr[] = {6, -3, -10, 0, 2}\n*   Output:   180  // The subarray is {6, -3, -10}\n*   \n*   Input: arr[] = {-1, -3, -10, 0, 60}\n*   Output:   60  // The subarray is {60}\n*   \n*   Input: arr[] = {-2, -3, 0, -2, -40}\n*   Output:   80  // The subarray is {-2, -40}\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/maximum-product-subarray/\n// Author : Hao Chen\n// Date   : 2014-10-09\n\n\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// The idea is similar with \"Find the subarray wich has the largest sum\"\n// (See: http://en.wikipedia.org/wiki/Maximum_subarray_problem)\n// \n// The only thing to note here is, maximum product can also be obtained by minimum (negative) product \n// ending with the previous element multiplied by this element. For example, in array {12, 2, -3, -5, -6, -2}, \n// when we are at element -2, the maximum product is multiplication of, minimum product ending with -6 and -2.\n//\nint maxProduct(int A[], int n) {\n\n    // To remember the max/min product for previous position\n    int maxPrev = A[0], minPrev = A[0];\n    // To remember the max/min product for current position\n    int maxHere = A[0], minHere = A[0];\n    // Overall maximum product\n    int maxProd = A[0];\n\n    for (int i=1; i<n; i++){\n        //max( maxPrev * A[i],  minPrev * A[i],  A[i] )\n        maxHere = max( max( maxPrev * A[i], minPrev * A[i] ), A[i] );\n        //min( maxPrev * A[i],  minPrev * A[i],  A[i] )\n        minHere = min( min( maxPrev * A[i], minPrev * A[i] ), A[i] );\n        //Keep tracking the overall maximum product\n        maxProd = max(maxHere, maxProd);\n        //Shift the current max/min product to previous variables\n        maxPrev = maxHere;\n        minPrev = minHere;\n    }\n    return maxProd;    \n}\n\n\n#define TEST(a)    cout << maxProduct( a, sizeof(a)/sizeof(int)) << endl\nint main()\n{\n    int o[] = {2,3,-2,4};\n    TEST(o);\n\n    int a[] = {-4,-3};\n    TEST(a);\n\n    int b[] = {-1, -1};\n    TEST(b);\n\n    int c[] = {-1, 0, -2};\n    TEST(c);\n}\n"
  },
  {
    "question_theme": "findMinimumInRotatedSortedArray",
    "question": "/********************************************************************************** \n* \n* Suppose a sorted array is rotated at some pivot unknown to you beforehand.\n* \n* (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\n* \n* Find the minimum element.\n* \n* You may assume no duplicate exists in the array.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/find-minimum-in-rotated-sorted-array/\n// Author : Hao Chen\n// Date   : 2014-10-20\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint findMin(vector<int> &num) {\n\n    int low=0, high=num.size()-1;\n\n    while(high-low>1){\n        int mid = low + (high-low)/2;\n        // Chek the array if it is non-rotated, then just return the first element.\n        if (num[low] < num[mid] && num[mid] < num[high]){\n            return num[low];\n        }\n\n        // The array is rotated\n        // Split it into two part, the minimal value must be the rotated part\n        \n        // if the left part is rotated, warch the left part\n        if (num[low] > num [mid]){\n            high = mid;\n            continue;\n        }\n        // if the right part is rotated, search the right part.\n        if (num[mid] > num[high]){\n            low = mid;\n            continue;\n        }\n    }\n    // the array only has 1 element\n    if (high == low) return num[low];\n\n    // the array has 2 elements\n    return num[low] < num[high] ? num[low] : num[high];\n\n}\n\n\nvoid rotate_array(int a[], int n, int pos){\n    int i, from=0;\n    pos = pos % n;\n    if (n<=0) return;\n\n    int tmp = a[0];\n\n    for(int i=0, step=0; step<n && i<pos; step++){\n        int to;\n        if (from-pos < 0) {\n            to = n-pos+from; \n        }else{\n            to = from-pos;\n        }\n        int t ;\n        t = a[to];\n        a[to] = tmp; \n        tmp = t;\n        from = to;\n        if ( to == i ){\n            i++;\n            from++;\n            tmp = a[from];\n        }\n    }\n\n}\n\nvoid printArray(int A[], int n) {\n    printf(\"{\");\n    for(int i=0; i<n; i++) {\n        printf(\"%d, \", A[i]);\n    }\n    printf(\"}\\n\");\n}\n\nint main(int argc, char** argv)\n{\n\n    int cnt=20;\n\n    if (argc>1) {\n        cnt = atoi(argv[1]);\n    }\n\n    srand(time(NULL)); \n\n    int expectedMin, actualMin;\n    int *a = new int[cnt];\n    for(int n=0; n<=cnt; n++) {\n        printf(\"--------------------------------------\\n\");\n        for(int i=0; i<cnt; i++){\n            a[i]=i;\n        }\n        expectedMin = a[0];\n        //printArray(a, cnt);\n        int rotate_pos = random() % cnt;\n        //rotate_pos=2;\n        printf(\"rotate=%d\\n\", rotate_pos);\n        rotate_array(a, cnt, rotate_pos);\n        printArray(a, cnt);\n\n        vector<int> num(a, a+cnt);\n        actualMin = findMin(num);\n        cout << \"findMin = \" << actualMin << \"   \" << (expectedMin==actualMin ? \"passed\" : \"failed\") << endl;\n\n    }\n    delete[] a;\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "longestSubstringWithoutRepeatingCharacters",
    "question": "/********************************************************************************** \n* \n* Given a string, find the length of the longest substring without repeating characters. \n* For example, the longest substring without repeating letters for \"abcabcbb\" is \"abc\", \n* which the length is 3. For \"bbbbb\" the longest substring is \"b\", with the length of 1.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/longest-substring-without-repeating-characters/\n// Author : Hao Chen\n// Date   : 2014-07-19\n\n\n\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\nint lengthOfLongestSubstring1(string s) {\n    map<char, int> m;\n    int maxLen = 0;\n    int lastRepeatPos = -1;\n    for(int i=0; i<s.size(); i++){\n        if (m.find(s[i])!=m.end() && lastRepeatPos < m[s[i]]) {\n            lastRepeatPos = m[s[i]];\n        }\n        if ( i - lastRepeatPos > maxLen ){\n            maxLen = i - lastRepeatPos;\n        }\n        m[s[i]] = i;\n    }\n    return maxLen;\n}\n//don't use <map>\nint lengthOfLongestSubstring(string s) {\n    const int MAX_CHARS = 256;\n    int m[MAX_CHARS];\n    memset(m, -1, sizeof(m));\n\n    int maxLen = 0;\n    int lastRepeatPos = -1;\n    for(int i=0; i<s.size(); i++){\n        if (m[s[i]]!=-1 && lastRepeatPos < m[s[i]]) {\n            lastRepeatPos = m[s[i]];\n        }\n        if ( i - lastRepeatPos > maxLen ){\n            maxLen = i - lastRepeatPos;\n        }\n        m[s[i]] = i;\n    }\n    return maxLen;\n}\n\nint main(int argc, char** argv)\n{\n    string s = \"abcabcbb\";\n    cout << s << \" : \" << lengthOfLongestSubstring(s) << endl;\n\n    s = \"bbbbb\";\n    cout << s << \" : \" << lengthOfLongestSubstring(s) << endl;\n\n    s = \"bbabcdb\";\n    cout << s << \" : \" << lengthOfLongestSubstring(s) << endl;\n\n    if (argc>1){\n        s = argv[1];\n        cout << s << \" : \" << lengthOfLongestSubstring(s) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "addStrings",
    "question": "/*************************************************************************************** \n *\n * Given two non-negative numbers num1 and num2 represented as string, return the sum \n * of num1 and num2.\n * \n * Note:\n * \n * The length of both num1 and num2 is \n * Both num1 and num2 contains only digits 0-9.\n * Both num1 and num2 does not contain any leading zero.\n * You must not use any built-in BigInteger library or convert the inputs to integer \n * directly.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/add-strings/\n// Author : Hao Chen\n// Date   : 2016-11-12\n\n\n\nclass Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        string& longstr  = ( num1.size() >= num2.size() ? num1 : num2 );\n        string& shortstr = ( num1.size() <  num2.size() ? num1 : num2 );\n        \n        int longlen = longstr.size();\n        int shortlen = shortstr.size();\n        \n        char carry = 0;\n        int i, j;\n        \n        string result;\n        for (i = longlen-1, j=shortlen-1; i>=0; i--, j--) {\n            int add = 0;\n            if (j>=0) {\n                add = longstr[i] + shortstr[j] - 2 * '0' + carry;\n            }else{\n                add = longstr[i] - '0' + carry;\n            }\n            carry = add/10;\n            result = char('0' + add % 10) + result;\n        }\n        \n        if (carry) {\n            result = '1' + result;\n        }\n        return result;\n    }\n};\n"
  },
  {
    "question_theme": "removeInvalidParentheses",
    "question": "/*************************************************************************************** \n *\n * Remove the minimum number of invalid parentheses in order to make the input string \n * valid. Return all possible results.\n * \n * Note: The input string may contain letters other than the parentheses ( and ). \n * \n * Examples:\n * \n * \"()())()\" -> [\"()()()\", \"(())()\"]\n * \"(a)())()\" -> [\"(a)()()\", \"(a())()\"]\n * \")(\" -> [\"\"]\n * \n * Credits:Special thanks to @hpplayer for adding this problem and creating all test \n * cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/remove-invalid-parentheses/\n// Author : Hao Chen\n// Date   : 2015-11-11\n\n\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\n//DFS \nvoid removeInvalidParenthesesHelper(string& s, int index, int pair,\n                                    int remove_left, int remove_right, \n                                    string solution, unordered_set<string>& result) {\n\n    char ch = s[index];\n\n    //recusive ending \n    if ( ch == '\\0' ) {\n        if (pair==0 && remove_left==0 && remove_right==0 ) {\n            result.insert(solution);\n        }\n        return;\n    }\n    //other char, move to next one\n    if ( ch != '(' && ch != ')' ) {\n        removeInvalidParenthesesHelper(s, index+1, pair, remove_left, remove_right, solution+ch, result);\n        return;\n    }\n    \n    //if we meet left one, and we need remove left one, \n    //then we have two choices : remove it, OR keep it.\n    if ( ch == '(' ) {\n        //revmoe it\n        if (remove_left > 0 ) { \n            removeInvalidParenthesesHelper(s, index+1, pair, remove_left-1, remove_right, solution, result);\n        }\n        //keep it\n        removeInvalidParenthesesHelper(s, index+1, pair+1, remove_left, remove_right, solution+ch, result);\n    }\n    \n    //if we meet right one, and we need to remove right one,\n    //then we have two choices as well: remove it, or keep it if there are some left already.\n    if ( ch == ')' ) {\n        if (remove_right > 0 ) {\n            removeInvalidParenthesesHelper(s, index+1, pair, remove_left, remove_right-1, solution, result);\n        }\n        if (pair > 0){\n            removeInvalidParenthesesHelper(s, index+1, pair-1, remove_left, remove_right, solution+ch, result);\n        }\n    }\n\n\n}\n\nvector<string> removeInvalidParentheses(string s) {\n\n    //Calculating how many left/right parentheses need be removed!\n    int remove_left = 0, remove_right = 0;\n    for(auto c : s) {\n        if ( c == '(' ) {\n            remove_left++;\n        }else if ( c == ')' ){\n            if (remove_left > 0) {\n                remove_left--; // if we matched\n            }else{\n                remove_right++;\n            }\n        }\n    }\n\n    unordered_set<string> result;\n    removeInvalidParenthesesHelper(s, 0, 0, remove_left, remove_right, \"\", result);\n    return vector<string>( result.begin(), result.end() );\n}\n\n\nvoid printVector(vector<string> result) {\n    for( int i=0; i<result.size(); i++) {\n        cout << i << \") \" << result[i] << endl;\n    }\n}\n\n\nint main(int argc, char** argv) {\n    string s = \"()())()\";\n    if (argc>1) {\n        s = argv[1];\n    }\n    cout << s << endl;\n    printVector( removeInvalidParentheses(s) );\n    \n    return 0;\n}\n"
  },
  {
    "question_theme": "rotateArray",
    "question": "/********************************************************************************** \n* \n* Rotate an array of n elements to the right by k steps.\n* For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. \n* \n* Note:\n* Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\n* \n* Hint:\n* Could you do it in-place with O(1) extra space?\n* \n* Related problem: Reverse Words in a String II\n* \n* Credits:Special thanks to @Freezen for adding this problem and creating all test cases.\n*               \n**********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/rotate-array/\n// Author : Hao Chen\n// Date   : 2015-03-30\n\n\n\n#include <stdlib.h>\n#include <time.h>\n#include <iostream>\nusing namespace std;\n\n\nvoid reverseArray(int nums[],int start, int end){\n    int temp;\n    while(start < end){\n        int temp = nums[start];\n        nums[start++] = nums[end];\n        nums[end--] = temp;\n    }\n}\n\n\n\nvoid rotate1(int nums[], int n, int k) {\n    if (k<=0) return;\n    k %= n; \n    reverseArray(nums, n-k, n-1);\n    reverseArray(nums, 0, n-k-1);\n    reverseArray(nums, 0, n-1);    \n}\n\n\nvoid rotate2(int nums[], int n, int k) {\n    if (k<=0) return;\n    k %= n;\n    int currIdx=0, newIdx=k;\n    int tmp1 = nums[currIdx], tmp2; \n    int origin = 0;\n\n    for(int i=0; i<n; i++){\n\n        tmp2 = nums[newIdx];\n        nums[newIdx] = tmp1;\n        tmp1 = tmp2; \n\n        currIdx = newIdx;\n\n        //if we meet a circle, move the next one\n        if (origin == currIdx) {\n            origin = ++currIdx;\n            tmp1 = nums[currIdx];\n        }\n        newIdx = (currIdx + k) % n;\n\n    } \n}\n\nvoid rotate(int nums[], int n, int k) {\n    if (random()%2==0) {\n        cout << \"[1] \";\n        return rotate1(nums, n, k);\n    }\n    cout << \"[2] \";\n    return rotate2(nums, n, k);\n}\n\nvoid printArray(int nums[], int n) {\n    cout << \"[ \" ;\n    for(int i=0; i<n; i++) {\n        cout << nums[i] << ((i==n-1)? \" \" : \", \");\n    }\n    cout << \"]\" << endl;\n}\n\nvoid initArray(int nums[], int n) {\n    for(int i=0; i<n; i++) {\n        nums[i] = i;\n    }\n}\n\n\nint main(int argc, char**argv) {\n    \n    srand(time(0));\n\n    int nums[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\n    const int n = sizeof(nums)/sizeof(int);\n\n    for (int i=0; i<n; i++) {\n        initArray(nums, n);\n        rotate(nums, n, i);\n        printArray(nums, n);\n    }\n    return 0;\n}\n"
  },
  {
    "question_theme": "implementStackUsingQueues",
    "question": "/********************************************************************************** \n * \n * Implement the following operations of a stack using queues.\n * \n * push(x) -- Push element x onto stack.\n * \n * pop() -- Removes the element on top of the stack.\n * \n * top() -- Get the top element.\n * \n * empty() -- Return whether the stack is empty.\n * \n * Notes:\n * \n * You must use only standard operations of a queue -- which means only push to back, \n * peek/pop from front, size, and is empty operations are valid.\n *\n * Depending on your language, queue may not be supported natively. You may simulate \n * a queue by using a list or deque (double-ended queue), as long as you use only \n * standard operations of a queue.\n *\n * You may assume that all operations are valid (for example, no pop or top operations \n * will be called on an empty stack).\n * \n * Update (2015-06-11):\n * The class name of the Java function had been updated to MyStack instead of Stack.\n * \n * Credits:Special thanks to @jianchao.li.fighter for adding this problem and all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/implement-stack-using-queues/\n// Author : Hao Chen\n// Date   : 2015-06-13\n\n\n\n\nclass Stack {\n    public:\n        // Push element x onto stack.\n        void push(int x) {\n            nums.push(x);\n        }\n        // Removes the element on top of the stack.\n        void pop() {\n            if (!empty()) {\n                int len = nums.size()-1;\n                //Don't treat the \"-->\" is a new operator. ;-)\n                while ( len-->0) {\n                    nums.push(nums.front());\n                    nums.pop();\n                }\n                nums.pop();\n            }\n        }\n        // Get the top element.\n        int top() {\n            return nums.back();\n        }\n        // Return whether the stack is empty.\n        bool empty() {\n            return nums.empty();\n        }\n\n    private:\n        queue<int> nums;\n};\n"
  },
  {
    "question_theme": "splitArrayLargestSum",
    "question": "/*************************************************************************************** \n *\n * Given an array which consists of non-negative integers and an integer m, you can \n * split the array into m non-empty continuous subarrays. Write an algorithm to \n * minimize the largest sum among these m subarrays.\n * \n * Note:\n * Given m satisfies the following constraint: 1 \u2264 m \u2264  length(nums) \u2264 14,000.\n * \n * Examples: \n * \n * Input:\n * nums = [7,2,5,10,8]\n * m = 2\n * \n * Output:\n * 18\n * \n * Explanation:\n * There are four ways to split nums into two subarrays.\n * The best way is to split it into [7,2,5] and [10,8],\n * where the largest sum among the two subarrays is only 18.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/split-array-largest-sum/\n// Author : Hao Chen\n// Date   : 2016-11-13\n\n\n\nclass Solution {\npublic:\n    // Idea\n    //   1) The max of the result is the sum of the whole array.\n    //   2) The min of the result is the max num among the array.\n    //   3) Then, we use Binary Search to find the resullt between the `min` and  the `max`\n    \n    int splitArray(vector<int>& nums, int m) {\n        int min = 0, max = 0;\n        for (int n : nums) {\n            min = std::max(min, n);\n            max += n;\n        }\n        while (min < max) {\n            int mid = min + (max - min) / 2;\n            if (hasSmallerSum(nums, m, mid)) max = mid;\n            else min = mid + 1;\n        }\n        return min;\n    }\n    \n    \n    // Using a specific `sum` to check wheter we can get `smaller sum`\n    // The idea here as below:\n    //   find all of possible `sub array` whose sum greater than `sum`\n    //   1) if the number of `sub array` >  m, whcih means the actual result is greater than `sum`\n    //   2) if the number of `sub array` <= m, whcih means we can have `smaller sum`\n    //\n    bool hasSmallerSum(vector<int>& nums, int m, int sum) {\n        int cnt = 1, curSum = 0;\n        for (int n : nums) {\n            curSum += n;\n            if (curSum > sum) {\n                curSum = n;\n                cnt++;\n                if (cnt > m) return false;\n            }\n        }\n        return true;\n    }\n};\n"
  },
  {
    "question_theme": "sudokuSolver",
    "question": "/********************************************************************************** \n* \n* Write a program to solve a Sudoku puzzle by filling the empty cells.\n* \n* Empty cells are indicated by the character '.'.\n* \n* You may assume that there will be only one unique solution.\n* \n* A sudoku puzzle...\n* \n* ...and its solution numbers marked in red.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/sudoku-solver/\n// Author : Hao Chen\n// Date   : 2014-09-20\n\n\n\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nconst int SodukuSize = 9;\nbool row_mask[SodukuSize][SodukuSize];\nbool col_mask[SodukuSize][SodukuSize];\nbool area_mask[SodukuSize][SodukuSize];\n\nbool initSudokuMask(vector< vector<char> > &board){\n    //reset the memory\n    memset(row_mask, false, sizeof(row_mask));\n    memset(col_mask, false, sizeof(col_mask));\n    memset(area_mask, false, sizeof(area_mask));\n\n    //check each rows and cols\n    for(int r=0; r<board.size(); r++){\n        for (int c=0; c<board[r].size(); c++){\n            if (!isdigit(board[r][c])) {\n                continue;\n            };\n            int idx =  board[r][c] - '0' - 1;\n\n            //check the rows/cols/areas\n            int area = (r/3) * 3 + (c/3);\n            if (row_mask[r][idx] || col_mask[c][idx] || area_mask[area][idx] ){\n                return false;\n            }\n            row_mask[r][idx] = col_mask[c][idx] = area_mask[area][idx] = true;\n        }\n    }\n    return true;\n\n}\n\n\nbool recursiveSudoKu(vector< vector<char> > &board, int row, int col){\n\n    if (row >= SodukuSize) {\n        return true;\n    }\n\n    if (col >= SodukuSize){\n        return recursiveSudoKu(board, row+1, 0);\n    }\n    \n    if (board[row][col] != '.'){\n        return recursiveSudoKu(board, row, col+1);    \n    }\n    //pick a number for empty cell\n    int area;\n    for(int i=0; i<SodukuSize; i++){\n        area = (row/3) * 3 + (col/3);\n        if (row_mask[row][i] || col_mask[col][i] || area_mask[area][i] ){\n            continue;\n        }\n        //set the number and sovle it recursively\n        board[row][col] = i + '1';\n        row_mask[row][i] = col_mask[col][i] = area_mask[area][i] = true;\n        if (recursiveSudoKu(board, row, col+1) == true){\n            return true;\n        }\n        //backtrace\n        board[row][col] = '.';\n        row_mask[row][i] = col_mask[col][i] = area_mask[area][i] = false;\n         \n    }\n    return false;\n}\n\n\nvoid solveSudoku(vector<vector<char> > &board) {\n    if (initSudokuMask(board) == false){\n        return;\n    }\n    recursiveSudoKu(board, 0, 0); \n}\n\n\nint main(int argc, char**argv) {\n    return 0;\n}\n"
  },
  {
    "question_theme": "integerToEnglishWords",
    "question": "/*************************************************************************************** \n *\n * Convert a non-negative integer to its english words representation. Given input is \n * guaranteed to be less than 231 - 1.\n * \n * For example,\n * \n * 123 -> \"One Hundred Twenty Three\"\n * 12345 -> \"Twelve Thousand Three Hundred Forty Five\"\n * 1234567 -> \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n * \n *   Did you see a pattern in dividing the number into chunk of words? For example, 123 \n * and 123000.\n *\n *   Group the number by thousands (3 digits). You can write a helper function that \n * takes a number less than 1000 and convert just that chunk to words.\n *\n *   There are many edge cases. What are some good test cases? Does your code work with \n * input such as 0? Or 1000010? (middle chunk is zero and should not be printed out)\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/integer-to-english-words/\n// Author : Hao Chen\n// Date   : 2015-10-22\n\n\n\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstatic string dict1[] ={\"Zero\",\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\n                 \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \n                 \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n                 \nstatic string dict2[]={\"\",\"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\" };\nstatic string dict3[]={\"Hundred\", \"Thousand\", \"Million\", \"Billion\" };\n\n\n// This function only converts the number which less than 1000\nstring numberLess1000ToWords(int num) {\n    //char n[3] = {0, 0, 0};\n    string result;\n\n    if (num == 0) {\n        return result;\n    }else if (num < 20) {\n        return dict1[num];\n    } else if (num < 100) {\n        result = dict2[num/10];\n        if (num%10 > 0) { \n            result += \" \" + dict1[num%10];\n        }\n    }else {\n        result = dict1[num/100] + \" \" + dict3[0];\n        if ( num % 100 > 0 ) {\n            result += \" \" + numberLess1000ToWords( num % 100 );\n        }\n    }\n    return result;\n}\n\nstring numberToWords(int num) {\n    //edge case\n    if (num ==0 ) return dict1[num];\n\n    vector<string> ret;\n    for( ;num > 0; num/=1000 ) {\n        ret.push_back( numberLess1000ToWords(num % 1000) );\n    }\n\n    string result=ret[0];\n    for (int i=1; i<ret.size(); i++){\n        if (ret[i].size() > 0 ){\n            if ( result.size() > 0 ) {\n                result = ret[i] + \" \" + dict3[i] + \" \" + result; \n            } else {\n                result = ret[i] + \" \" + dict3[i]; \n            }\n        }\n\n    }\n    return result;\n}\n\n\n#define TEST(num) cout << num << \" -> \\\"\" << numberToWords(num) << \"\\\"\" << endl\nint main(int argc, char** argv) \n{\n    int num = 123;\n    if (argc >1){\n        num = atoi(argv[1]);\n    }\n    TEST(num);\n\n    TEST(0);\n    TEST(1);\n    TEST(10);\n    TEST(11);\n    TEST(18);\n    TEST(20);\n    TEST(22);\n    TEST(30);\n    TEST(99);\n    TEST(100);\n    TEST(101);\n    TEST(110);\n    TEST(120);\n    TEST(256);\n    TEST(1000);\n    TEST(1001);\n    TEST(1010);\n    TEST(1110);\n    TEST(1111);\n    TEST(10000);\n    TEST(10001);\n    TEST(100000);\n    TEST(100001);\n    TEST(1000000);\n    TEST(1000001);\n    TEST(10000000);\n    TEST(10000001);\n    TEST(100000000);\n    TEST(100000001);\n    TEST(1000000000);\n    TEST(1000000001);\n    TEST(2147483647);\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "setMatrixZeroes",
    "question": "/********************************************************************************** \n* \n* Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.\n* \n* click to show follow up.\n* \n* Follow up:\n* \n* Did you use extra space?\n* A straight forward solution using O(mn) space is probably a bad idea.\n* A simple improvement uses O(m + n) space, but still not the best solution.\n* Could you devise a constant space solution?\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/set-matrix-zeroes/\n// Author : Hao Chen\n// Date   : 2014-06-23\n\n\n\nclass Solution {\npublic:\n    Solution(){\n        srand(time(NULL));\n    }\n    void setZeroes(vector<vector<int> > &matrix) {\n        if(random()%2){\n            setZeroes1(matrix);\n        }\n        setZeroes2(matrix);\n    }\n    \n    void setZeroes1(vector<vector<int> > &matrix) {\n        \n        int bRow = false, bCol=false;\n        \n        for (int r=0; r<matrix.size(); r++){\n            for(int c=0; c<matrix[r].size(); c++){\n                if (matrix[r][c]==0){\n                    if (r==0) bRow = true;\n                    if (c==0) bCol = true;\n                    matrix[0][c] = matrix[r][0] = 0;\n                }\n            }\n        }\n        \n        for (int r=1; r<matrix.size(); r++){\n            for(int c=1; c<matrix[r].size(); c++){\n                if (matrix[0][c]==0 || matrix[r][0]==0) {\n                    matrix[r][c]=0;\n                }\n            }\n        }\n        if (bRow){\n            for(int c=0; c<matrix[0].size(); c++) matrix[0][c] = 0;\n        }\n        if (bCol){\n            for(int r=0; r<matrix.size(); r++) matrix[r][0] = 0;\n        }\n\n    }\n    \n    void setZeroes2(vector<vector<int> > &matrix) {\n\n        bool *row = new bool[matrix.size()]();\n        bool *col = new bool[matrix[0].size()]();\n        for (int r=0; r<matrix.size(); r++){\n            for(int c=0; c<matrix[r].size(); c++){\n                if (matrix[r][c]==0){\n                    row[r]=true;\n                    col[c]=true;\n                }\n            }\n        }\n        \n        for (int r=0; r<matrix.size(); r++){\n            for(int c=0; c<matrix[r].size(); c++){\n                if (row[r] || col[c]) {\n                    matrix[r][c]=0;\n                }\n            }\n        }\n    }\n};\n"
  },
  {
    "question_theme": "majorityElement",
    "question": "/********************************************************************************** \n * \n * Given an integer array of size n, find all elements that appear more than \u230a n/3 \u230b times. \n * The algorithm should run in linear time and in O(1) space.\n * \n *   How many majority elements could it possibly have?\n *   Do you have a better hint? Suggest it!\n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/majority-element-ii/\n// Author : Hao Chen\n// Date   : 2015-07-03\n\n\n\nclass Solution {\npublic:\n\n    //O(n) Space compexity\n    vector<int> majorityElement01(vector<int>& nums) {\n        vector<int> result;\n        unordered_map<int, int> counts;\n        int n = nums.size();\n        for(auto item : nums){\n            counts[item]++;\n            if (counts[item] > n/3 ){\n               result.push_back(item); \n               counts[item] = -n; // Tricky: make sure the item only can be put into result once.\n            } \n        }\n        return result;\n    }\n    //We know, there could be at most two numbers can be more than 1/3\n    //so, same as Majority Element I problem, we can have two counters.\n    vector<int> majorityElement02(vector<int>& nums) {\n        if(nums.size()<=1) return nums;\n        \n        //the same algorithm as Majority Element I problem\n        int majority1=0, majority2=0, cnt1=0, cnt2=0;\n        for(auto item: nums) {\n            if (cnt1 == 0 && majority2 != item ) {\n                majority1 = item;\n                cnt1 = 1;\n            } else if (majority1 == item) {\n                cnt1++;\n            } else if (cnt2 == 0) {\n                majority2 = item;\n                cnt2 = 1;\n            } else if (majority2 == item) {\n                cnt2++;\n            } else {\n                cnt1--;\n                cnt2--;\n            }\n        }\n        //re-check it again, in case there has less than two numbers of majority\n        cnt1 = cnt2 = 0;\n        for (auto item : nums) {\n            if (majority1 == item) cnt1++;\n            else if (majority2 == item) cnt2++;\n        }\n        vector<int> result;\n        if (cnt1 > nums.size()/3) result.push_back(majority1);\n        if (cnt2 > nums.size()/3) result.push_back(majority2);\n        return result;\n        \n    }\n    \n    vector<int> majorityElement(vector<int>& nums) {\n        return majorityElement02(nums);\n        return majorityElement01(nums);\n    }\n};\n\n\n"
  },
  {
    "question_theme": "superUglyNumber",
    "question": "/*************************************************************************************** \n *\n * Write a program to find the nth super ugly number.\n * \n *     Super ugly numbers are positive numbers whose all prime factors are in the given \n * prime list\n *     primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]\n *  is the sequence of the first 12 super ugly numbers given primes\n *     = [2, 7, 13, 19] of size 4.\n * \n *     Note:\n *     (1) 1 is a super ugly number for any given primes.\n *     (2) The given numbers in primes are in ascending order.\n *     (3) 0 k \u2264 100, 0 n \u2264 106, 0 primes[i] \n * \n * Credits:Special thanks to @dietpepsi for adding this problem and creating all test \n * cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/super-ugly-number/\n// Author : Hao Chen\n// Date   : 2017-01-02\n\n\n\n// As the solution we have for the ugly number II problem\n//\n//    int nthUglyNumber(int n) {\n//\n//        int i=0, j=0, k=0;\n//        vector<int> ugly(1,1);\n//\n//        while(ugly.size() < n){\n//            int next = min(ugly[i]*2, ugly[j]*3, ugly[k]*5);\n//            if (next == ugly[i]*2) i++;\n//            if (next == ugly[j]*3) j++;\n//            if (next == ugly[k]*5) k++;\n//            ugly.push_back(next);\n//        }\n//        return ugly.back();\n//    }\n//\n// The logic of solution is exacly same for both., except that instead of 3 numbers you have k numbers to consider. \n//\n// \n//\nclass Solution {\n  \npublic:\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\n        vector<int> ugly(1, 1);\n        int len = primes.size();\n        vector<int> pos(len, 0);\n        \n        while( ugly.size() < n ) {\n            int next = INT_MAX;\n            for(int i=0; i<len; i++) {\n                next = min(next, ugly[pos[i]] * primes[i]);\n            }\n            for(int i=0; i<len; i++) {\n                if (next == ugly[pos[i]] * primes[i]) {\n                    pos[i]++;\n                }\n            }\n            ugly.push_back(next);\n        }\n        return ugly.back();\n    }\n    \n\n};\n"
  },
  {
    "question_theme": "partitionList",
    "question": "/********************************************************************************** \n* \n* Given a linked list and a value x, partition it such that all nodes less than x come \n* before nodes greater than or equal to x.\n* \n* You should preserve the original relative order of the nodes in each of the two partitions.\n* \n* For example,\n* Given 1->4->3->2->5->2 and x = 3,\n* return 1->2->2->4->3->5.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/partition-list/\n// Author : Hao Chen\n// Date   : 2014-06-21\n\n\n\n#include <stdio.h>\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode *partition(ListNode *head, int x) {\n    ListNode fakeHead(0);\n    fakeHead.next = head;\n    head = &fakeHead;\n    \n    ListNode *pos = NULL;\n    for(ListNode *p = head; p!=NULL && p->next!=NULL; ){\n        if (!pos && p->next->val >= x){\n            pos = p;\n            p=p->next;\n            continue;\n        }\n        if (pos && p->next->val < x){\n            ListNode *pNext = p->next;\n            p->next = pNext->next;\n            pNext->next = pos->next;\n            pos->next = pNext;\n            pos = pNext;\n            continue;\n        }\n        p=p->next;\n    }\n    \n    return head->next;\n}\n\nvoid printList(ListNode* h)\n{\n    while(h!=NULL){\n        printf(\"%d \", h->val);\n        h = h->next;\n    }\n    printf(\"\\n\");\n}\n\nListNode* createList(int a[], int n)\n{\n    ListNode *head=NULL, *p=NULL;\n    for(int i=0; i<n; i++){\n        if (head == NULL){\n            head = p = new ListNode(a[i]);\n        }else{\n            p->next = new ListNode(a[i]);\n            p = p->next;\n        }\n    }\n    return head;\n}\n\nint main()\n{\n    //int a[] = {1}; int x =2;\n    //int a[] = {2,3,1}; int x=2;\n    int a[] = {3,1,2}; int x=3;\n    ListNode* p = createList(a, sizeof(a)/sizeof(int)); \n    printList(p);\n    p = partition(p, x);\n    printList(p);\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "permutationSequence",
    "question": "/********************************************************************************** \n* \n* The set [1,2,3,\u2026,n] contains a total of n! unique permutations.\n* \n* By listing and labeling all of the permutations in order,\n* We get the following sequence (ie, for n = 3):\n* \n* \"123\"\n* \"132\"\n* \"213\"\n* \"231\"\n* \"312\"\n* \"321\"\n* \n* Given n and k, return the kth permutation sequence.\n* \n* Note: Given n will be between 1 and 9 inclusive.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/permutation-sequence/\n// Author : Hao Chen\n// Date   : 2014-08-22\n\n\n\n#include <stdlib.h>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\n\n\nvoid nextPermutation(vector<int>& num); \n\n\nstring getPermutation(int n, int k) {\n    vector<int> num;\n    int total = 1;\n    for(int i=1; i<=n; i++){\n        num.push_back(i);\n        total *= i;\n    }\n\n    //invalid k;\n    if( total < k ) {\n        return \"\";\n    }\n\n    // Construct the k-th permutation with a list of n numbers\n    // Idea: group all permutations according to their first number (so n groups, each of\n    // (n-1)! numbers), find the group where the k-th permutation belongs, remove the common\n    // first number from the list and append it to the resulting string, and iteratively\n    // construct the (((k-1)%(n-1)!)+1)-th permutation with the remaining n-1 numbers\n    int group = total;\n    stringstream ss;\n    while (n>0) {\n        group = group / n;\n        int idx = (k-1) / group;\n        ss << num[idx];\n        num.erase(num.begin()+idx);\n        n--;\n        //the next k also can be caculated like this: \n        //    k = (k-1)%group + 1; \n        k -= group * idx;\n    }\n\n    return ss.str();\n}\n\n\n\n\nstring getPermutation_0(int n, int k) {\n    vector<int> num;\n    int total = 1;\n    for(int i=1; i<=n; i++){\n        num.push_back(i);\n        total *= i;\n    }\n\n    //invalid k;\n    if( total < k ) {\n        return \"\";\n    }\n    int group = total / n;\n    int idx = (k-1) / group;\n    int nn = num[idx];\n    num.erase(num.begin()+idx);\n    num.insert(num.begin(), nn);\n\n    int offset = (k-1) % group;\n    for(int i=0; i<offset; i++) {\n        nextPermutation(num);\n    }\n\n    //string result;\n    stringstream ss;\n    for(int i=0; i<n; i++){\n        ss << num[i];\n    }\n\n    return ss.str();\n}\n\n\nstring getPermutation_1(int n, int k) {\n    vector<int> num;\n    for(int i=1; i<=n; i++){\n        num.push_back(i);\n    }\n\n    for(int i=1; i<k; i++) {\n        nextPermutation(num);\n    }\n\n    //string result;\n    stringstream ss;\n    for(int i=0; i<n; i++){\n        ss << num[i];\n    }\n\n    return ss.str();\n}\n\n\n\nvoid nextPermutation(vector<int>& num) {\n    if (num.size()<=1) return;\n    for (int i=num.size()-1; i>0; i-- ) {\n        if (num[i-1] < num[i]) {\n            int j = num.size() - 1;\n            while( num[i-1] > num[j] ) {\n                j--;\n            }\n            int temp = num[i-1];\n            num[i-1] = num[j];\n            num[j] = temp;\n\n            reverse(num.begin()+i, num.end());\n            return;\n        }\n    }\n\n    reverse( num.begin(), num.end() );\n}\n\n\nint main(int argc, char**argv)\n{\n    int n=3, k=6;\n    if ( argc > 2 ) {\n        n = atoi(argv[1]);\n        k = atoi(argv[2]);\n    }\n    cout << \"n = \" << n << \", k = \" << k << \" : \" << getPermutation(n, k) << endl;\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "strStr",
    "question": "/********************************************************************************** \n* \n* Implement strStr().\n* \n* Returns a pointer to the first occurrence of needle in haystack, or null if needle is not part of haystack.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/implement-strstr/\n// Author : Hao Chen\n// Date   : 2014-07-19\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nchar *strStr1(char *haystack, char *needle);\nchar *strStr2(char *haystack, char *needle);\n\nchar *strStr(char*haystack, char *needle) {\n    if (random()%2){\n        printf(\"---KMP---\\n\");\n        return strStr1(haystack, needle);\n    }\n    printf(\"---brute-force---\\n\");\n    return strStr2(haystack, needle);\n}\n//KMP\nchar *strStr1(char *haystack, char *needle) {\n    if(!haystack || !needle ) {\n        return NULL;\n    }\n    if (!*needle ) {\n        return haystack;\n    }\n\n    char *ph = haystack;\n    char *pn = needle;\n    for( ;*ph && *pn ; ph++, pn++ );\n\n    //len(haystack) < len(needle)\n    if (!*ph && *pn){\n        return NULL;    \n    }\n\n    for(ph=ph-1; *ph; haystack++, ph++) {\n        char *q=needle;\n        char *p=haystack;\n        int n=0;\n        while(*q && *p && *p==*q){\n            p++; q++;\n            if (n==0 && *p == *needle){\n                n = p - haystack;\n            }\n        }\n        if (!*q){\n            return haystack;\n        }\n        haystack += (n>0 ? n-1 : n);\n    }\n    return NULL;\n}\n\n//brute-force\nchar *strStr2(char *haystack, char *needle) {\n\n    if(!haystack || !needle ) {\n        return NULL;\n    }\n    if (!*needle ) {\n        return haystack;\n    }\n\n    char *ph = haystack;\n    char* pn = needle;\n    for( ;*ph && *pn ; ph++, pn++ );\n\n    //len(haystack) < len(needle)\n    if (!*ph && *pn){\n        return NULL;    \n    }\n    ph--;\n\n    for( ; *ph; haystack++, ph++) {\n        char *q=needle;\n        char *p=haystack;\n        while(*q && *p && *p==*q){\n            p++; q++;\n        }\n        if (!*q){\n            return haystack;\n        }\n    }\n\n    return NULL;\n}\n\nint main(int argc, char** argv)\n{\n    srand(time(0));\n    const char* haystack = \"mississippi\";\n    const char* needle = \"issi\";\n    printf(\"%s, %s : %s\\n\", haystack, needle, strStr((char*)haystack, (char*)needle));\n\n    haystack = \"mississippi\";\n    needle = \"issip\";\n    printf(\"%s, %s : %s\\n\", haystack, needle, strStr((char*)haystack, (char*)needle));\n\n\n    haystack = \"babbbbbabb\";\n    needle = \"bbab\";\n    printf(\"%s, %s : %s\\n\", haystack, needle, strStr1((char*)haystack, (char*)needle));\n\n    if (argc>2){\n        haystack = argv[1];\n        needle = argv[2];\n        printf(\"%s, %s : %s\\n\", haystack, needle, strStr((char*)haystack, (char*)needle));\n    }\n    \n    return 0;\n}\n"
  },
  {
    "question_theme": "wordBreak",
    "question": "/********************************************************************************** \n* \n* Given a string s and a dictionary of words dict, determine if s can be segmented \n* into a space-separated sequence of one or more dictionary words.\n* \n* For example, given\n* s = \"leetcode\",\n* dict = [\"leet\", \"code\"].\n* \n* Return true because \"leetcode\" can be segmented as \"leet code\".\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/word-break/\n// Author : Hao Chen\n// Date   : 2014-07-01\n\n\n\n#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nbool wordBreak(string s, set<string> &dict) {\n\n    //using an array to mark subarray from 0 to i can be broken or not\n    vector<bool> v(s.size(),false);\n\n    for(int i=0; i<s.size(); i++){\n        //check the substring from 0 to i is int dict or not\n        string w = s.substr(0,i+1);\n        v[i] = (dict.find(w)!=dict.end());\n\n        //if it is, then use greedy algorithm\n        if (v[i]) continue;\n\n        //if it is not, then break it to check\n        for(int j=0; j<i; j++){\n            //if the substring from 0 to j can be borken, then check the substring from j to i\n            if (v[j]==true){\n                w = s.substr(j+1, i-j);\n                v[i] = (dict.find(w)!=dict.end());\n                if (v[i]) break;\n            }\n        }\n    }\n    return v.size() ? v[v.size()-1] : false;\n}\n\n\nint main()\n{\n    string s; \n    set<string> dict;\n\n    s = \"a\";\n    dict.insert(\"a\");\n    cout << wordBreak(s, dict) << endl;\n    \n    dict.clear();\n    s = \"dogs\";\n    string d[]={\"dog\",\"s\",\"gs\"};\n    dict.insert(d, d+3);\n    cout << wordBreak(s, dict) << endl;\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "largestRectangleInHistogram",
    "question": "/********************************************************************************** \n * \n * Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, \n * find the area of largest rectangle in the histogram.\n * \n *                    6          \n *                  +---+        \n *               5  |   |        \n *              +---+   |        \n *              |   |   |        \n *              |   |   |        \n *              |   |   |     3  \n *              |   |   |   +---+\n *        2     |   |   | 2 |   |\n *      +---+   |   |   +---+   |\n *      |   | 1 |   |   |   |   |\n *      |   +---+   |   |   |   |\n *      |   |   |   |   |   |   |\n *      +---+---+---+---+---+---+\n *      \n * Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].\n *      \n *      \n *                    6          \n *                  +---+        \n *               5  |   |        \n *              +-------|        \n *              |-------|        \n *              |-------|        \n *              |-------|     3  \n *              |-------|   +---+\n *        2     |-------| 2 |   |\n *      +---+   |-------|---+   |\n *      |   | 1 |-------|   |   |\n *      |   +---|-------|   |   |\n *      |   |   |-------|   |   |\n *      +---+---+---+---+---+---+\n *      \n * \n * The largest rectangle is shown in the shaded area, which has area = 10 unit.\n * \n * For example,\n * Given height = [2,1,5,6,2,3],\n * return 10.\n * \n *               \n **********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/largest-rectangle-in-histogram/\n// Author : Hao Chen\n// Date   : 2014-07-20\n\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// As we know, the area = width * height\n// For every bar, the 'height' is determined by the loweset bar.\n//\n// 1) We traverse all bars from left to right, maintain a stack of bars. Every bar is pushed to stack once. \n// 2) A bar is popped from stack when a bar of smaller height is seen. \n// 3) When a bar is popped, we calculate the area with the popped bar as smallest bar. \n// 4) How do we get left and right indexes of the popped bar \u2013 \n//    the current index tells us the \u2018right index\u2019 and index of previous item in stack is the \u2018left index\u2019. \n//\n//\n// In other word, the stack only stores the incresing bars, let's see some example  \n//\n// Example 1\n// ---------\n// height = [1,2,3,4]\n//\n//    stack[] = [ 0, 1, 2, 3 ], i=4\n//\n//    1) pop 3,  area = height[3] * 1 = 4\n//    2) pop 2,  area = height[2] * 2 = 4\n//    3) pop 1,  area = height[1] * 3 = 6\n//    4) pop 0,  area = height[0] * 4 = 4\n//\n//\n// Example 2\n// ---------\n// height = [2,1,2]\n//\n//    stack[] = [ 0 ], i=1\n//    1) pop 0,  area = height[0] * 1 = 2\n//\n//    stack[] = [ 1,2 ], i=3, meet the end\n//    1) pop 2,  area = height[2] * 1 = 2\n//    2) pop 1,  area = height[1] * 3 = 3\n//\n//\n// Example 3\n// ---------\n// height =  [4,2,0,3,2,5]  \n//\n//    stack[] = [ 0 ], i=1, height[1] goes down\n//    1) pop 0,  area = height[0] * 1 = 4\n//\n//    stack[] = [ 1 ], i=2, height[2] goes down\n//    1) pop 1,  area = height[1] * 2 = 4 // <- how do we know the left?\n//                                              start from the 0 ?? \n//\n//    stack[] = [ 2, 3 ], i=4, height[4] goes down\n//    1) pop 3,  area = height[3] * 1 = 3\n//    2) pop 2,  area = height[2] * ? = 0 // <- how do we know the left? \n//                                              start from the 0 ??\n//\n//    stack[] = [ 2,4,5 ], i=6,  meet the end\n//    1) pop 5,  area = height[5] * 1 = 5\n//    2) pop 4,  area = height[4] * 3 = 6 // <- how do we know the left?\n//                                              need check the previous item.\n//    3) pop 2,  area = height[2] * ? = 4 // <- how do we know the left?\n//                                              start from the 0 ??\n//\n//    so, we can see, when the stack pop the top, the area formular is \n//\n//          height[stack_pop] *  i - stack[current_top] - 1,   if stack is not empty\n//          height[stack_pop] *  i,                            if stack is empty\n//\nint largestRectangleArea(vector<int> &height) {\n    if (height.size()<=0) return 0;\n    //Create an empty stack.\n    vector<int> stack;\n    //add a flag as a trigger if the end bar is met, and need to check the stack is empty of not .\n    height.push_back(0);\n    int maxArea = 0;\n    for(int i=0; i<height.size(); i++){\n        //If stack is empty or height[i] is higher than the bar at top of stack, then push \u2018i\u2019 to stack.\n        if ( stack.size()<=0 || height[i] >= height[stack.back()] ) {\n            stack.push_back(i);\n            continue;\n        }\n        //If this bar is smaller than the top of stack, then keep removing the top of stack while top of the stack is greater. \n        //Let the removed bar be height[top]. Calculate area of rectangle with height[top] as smallest bar. \n        //For height[top], the \u2018left index\u2019 is previous (previous to top) item in stack and \u2018right index\u2019 is \u2018i\u2019 (current index).\n        int topIdx = stack.back();\n        stack.pop_back();\n        int area = height[topIdx] * (stack.size()==0 ? i : i - stack.back() - 1 );\n        if ( area > maxArea ) {\n            maxArea = area;\n        }\n        //one more time. Because the stack might still have item.\n        i--;\n    }\n\n    return maxArea;\n}\n\nvoid printArray(vector<int> &v)\n{\n    cout << \"{\";\n    for(int i=0; i<v.size(); i++) {\n        cout << \" \" << v[i];\n    }\n    cout << \"}\" << endl;\n}\nvoid test(int a[], int n)\n{\n    vector<int> v(a, a + n);\n    printArray(v);\n    cout << largestRectangleArea(v) << endl;\n}\n\nint main()\n{\n#define TEST(a) test(a, sizeof(a)/sizeof(int))\n\n    int a0[] = {2,1,3,1};\n    TEST(a0);\n    int a1[] = {2,1,5,6,2,3};\n    TEST(a1);\n\n    return 0;\n}\n\n\n"
  },
  {
    "question_theme": "patchingArray",
    "question": "/*************************************************************************************** \n *\n * Given a sorted positive integer array nums and an integer n, add/patch elements to \n * the array such that any number in range [1, n] inclusive can be formed by the sum of \n * some elements in the array. Return the minimum number of patches required.\n * \n * Example 1:\n * nums = [1, 3], n = 6\n * Return 1.\n * \n * Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\n * Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], \n * [1,2,3].\n * Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\n * So we only need 1 patch.\n * \n * Example 2:\n * nums = [1, 5, 10], n = 20\n * Return 2.\n * The two patches can be [2, 4].\n * \n * Example 3:\n * nums = [1, 2, 2], n = 5\n * Return 0.\n * \n * Credits:Special thanks to @dietpepsi for adding this problem and creating all test \n * cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/patching-array/\n// Author : Hao Chen\n// Date   : 2016-03-01\n\n\n\n\nclass Solution {\npublic:\n    int minPatches(vector<int>& nums, int n) {\n        return minPatches_02(nums, n);\n        return minPatches_01(nums, n);\n    }\n    \n    \n    // Greedy Algorithm\n    // (Assume the array is sorted already)\n    //\n    //   Let do some observation at first,\n    //\n    //     1) if we have [1,2] then we can cover 1, 2, 3\n    //     2) if we have [1,2,3] then we can cover 1,2,3,4,5,6\n    //     So, it looks we can simply add all of nums together, then we can find out max number we can reach.\n    //\n    //     3) if we have [1,2,5], we can see \n    //       3.1) [1,2] can cover 1,2,3, but we cannot reach 4, \n    //       3.2) then we patch 4, then we have [1,2,4] which can cover 1,2,3(1+2),4,5(1+4),6(2+4), 7(1+2+4)\n    //       3.3) we can see [1,2,4] can reach to 7 - sum all of them\n    //       3.4) then [1,2,4,5], we can reach to 12 - 1,2,3,4,5,6,7,8(1+2+5),9(4+5),10(1+4+5), 11(2+4+5), 12(1+2+4+5)\n    //   \n    //   So, we can have figure out our solution\n    //\n    //      0) considering the `n` we need to cover.\n    //      1) maintain a variable we are trying to patch, suppose named `try_patch`\n    //      2) if `try_patch` >= nums[i] then, we just keep add the current array item, \n    //         and set the `try_patch` to the next patch candidate number -  `sum+1`\n    //      3) if `try_patch` < nums[i], which means we need to patch.\n    //\n    int minPatches_01(vector<int>& nums, int n) {\n        long covered = 0; //avoid integer overflow\n        int patch_cnt = 0;\n        int i = 0;\n        while (i<nums.size() ){\n            // set the `try_patch` is the next number which we cannot cover\n            int try_patch = covered + 1;\n            // if the `try_patch` can cover the current item, then just sum it, \n            // then we can have the max number we can cover so far \n            if ( try_patch >= nums[i])  {\n                covered += nums[i];  \n                i++;\n            } else { // if the `try_patch` cannot cover the current item, then we find the number we need to patch\n                patch_cnt++;\n                //cout << \"patch \" << try_patch << endl;\n                covered = covered + try_patch;\n            } \n            \n            if (covered >=n) break;\n        }\n        //for the case - [1], 7\n        //the above while-loop just process all of the numbers in the array, \n        //but we might not reach the goal, so, we need keep patching.\n        while (covered < n) {\n            int try_patch = covered + 1;\n            patch_cnt++;\n            //cout << \"patch \" << try_patch << endl;\n            covered = covered + try_patch;\n        }\n        return patch_cnt;\n    }\n    \n    \n    //The following solution just re-organizes the solution above, and make it shorter \n    int minPatches_02(vector<int>& nums, int n) {\n        long covered = 0;\n        int patch_cnt = 0;\n        int i = 0;\n        while ( covered < n){\n            if (i<nums.size() && nums[i] <= covered + 1) {\n                covered += nums[i++];\n            }else{\n                //cout << \"patch \" << covered + 1 << endl;\n                covered = 2 * covered + 1;\n                patch_cnt++;\n            }\n        }\n        return patch_cnt;\n    }\n};\n"
  },
  {
    "question_theme": "letterCombinationsOfAPhoneNumber",
    "question": "/********************************************************************************** \n* \n* Given a digit string, return all possible letter combinations that the number could represent.\n* \n* A mapping of digit to letters (just like on the telephone buttons) is given below.\n* \n* Input:Digit string \"23\"\n* Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n* \n* Note:\n* Although the above answer is in lexicographical order, your answer could be in any order you want.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/letter-combinations-of-a-phone-number/\n// Author : Hao Chen\n// Date   : 2014-07-17\n\n\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> letterCombinations(string digits) {\n    char  phone[10][4]={ {' ',  '\\0', '\\0', '\\0' }, //0\n                         {'\\0', '\\0', '\\0', '\\0' }, //1\n                         {'a',  'b',  'c',  '\\0' }, //2\n                         {'d',  'e',  'f',  '\\0' }, //3\n                         {'g',  'h',  'i',  '\\0' }, //4\n                         {'j',  'k',  'l',  '\\0' }, //5\n                         {'m',  'n',  'o',  '\\0' }, //6\n                         {'p',  'q',  'r',  's'  }, //7\n                         {'t',  'u',  'v',  '\\0' }, //8\n                         {'w',  'x',  'y',  'z'  }  //9\n                       };\n\n    vector<string> result;\n    if (digits.size()<=0){\n        result.push_back(\"\");\n        return result;\n    }\n    for( int i=0; i<digits.size(); i++ ) {\n        if (!isdigit(digits[i])) {\n            vector<string> r;\n            return r;\n        } \n        int d = digits[i] - '0';\n        if (result.size()<=0){\n            for( int j=0; j<4 && phone[d][j]!='\\0'; j++ ){\n                string s;\n                s += phone[d][j];\n                result.push_back(s);\n            }\n            continue;\n        }\n        vector<string> r;\n        for (int j=0; j<result.size(); j++){\n            for( int k=0; k<4 && phone[d][k]!='\\0'; k++ ){\n                string s = result[j] + phone[d][k];\n                //sort(s.begin(), s.end());\n                r.push_back(s); \n            }\n        }\n        result = r;\n    }\n    //sort(result.begin(), result.end());\n\n    return result; \n}\n\nvoid printVector(vector<string>& ss){\n    cout << \"{ \";\n    for(int i=0; i<ss.size(); i++){\n        if (i>0) cout << \", \"; \n        cout << ss[i];\n    }\n    cout << \" }\" << endl;\n}\n\nint main(int argc, char**argv)\n{\n    string s=\"23\";\n    if (argc>1){\n        s=argv[1];\n    }\n    vector<string> ss = letterCombinations(s);\n    printVector(ss);\n    return 0;\n}\n"
  },
  {
    "question_theme": "longestIncreasingPathInAMatrix",
    "question": "/*************************************************************************************** \n *\n * Given an integer matrix, find the length of the longest increasing path.\n * \n * From each cell, you can either move to four directions: left, right, up or down. You \n * may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not \n * allowed).\n * \n * Example 1:\n * \n * nums = [\n *   [>9, 9, 4],\n *   [>6, 6, 8],\n *   [>2,>1, 1]\n * ]\n * \n * Return 4\n * \n * The longest increasing path is [1, 2, 6, 9].\n * \n * Example 2:\n * \n * nums = [\n *   [>3,>4,>5],\n *   [ 3, 2,>6],\n *   [ 2, 2, 1]\n * ]\n * \n * Return 4\n * \n * The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n * \n * Credits:Special thanks to @dietpepsi for adding this problem and creating all test \n * cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/longest-increasing-path-in-a-matrix/\n// Author : Hao Chen\n// Date   : 2016-01-21\n\n\n\n\nclass Solution {\npublic:\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\n        int result = 0;\n        int row = matrix.size();\n        int col = row ? matrix[0].size() : 0;\n        vector<vector<int>> path = vector<vector<int>>(row, vector<int>(col, 0));\n        for (int r = 0; r < row; r++) {\n            for (int c = 0; c < col; c++) {\n                result = max(result, helper(matrix, path, row, col, r, c));\n            }\n        }\n        return result;\n    }\n    \n    int helper(vector<vector<int>>& matrix, vector<vector<int>>& path, const int row, const int col, int r, int c) {\n\n        if (path[r][c]>0) return path[r][c];\n        \n        int maxPath = 0;\n        \n        int tmp = matrix[r][c]; \n        matrix[r][c]=INT_MIN;  \n        if (r < row-1 && tmp < matrix[r+1][c]) {\n            maxPath = max(maxPath, helper(matrix, path, row, col, r+1, c));\n        }\n        if (c < col-1 && tmp < matrix[r][c+1]) {\n            maxPath = max(maxPath, helper(matrix, path, row, col, r, c+1));\n        }\n        if (r > 0 && tmp < matrix[r-1][c]) {\n            maxPath = max(maxPath, helper(matrix, path, row, col, r-1, c));\n        }\n        if (c > 0 && tmp < matrix[r][c-1]) {\n            maxPath = max(maxPath, helper(matrix, path, row, col, r, c-1));\n        }\n        matrix[r][c] = tmp;\n        path[r][c] = maxPath + 1;\n        return path[r][c];\n    }\n};\n"
  },
  {
    "question_theme": "maxPointsOnALine",
    "question": "/********************************************************************************** \n* \n* Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/max-points-on-a-line/\n// Author : Hao Chen\n// Date   : 2014-10-12\n\n\n\n#include <stdlib.h>\n#include <time.h>\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Point {\n    int x;\n    int y;\n    Point() : x(0), y(0) {}\n    Point(int a, int b) : x(a), y(b) {}\n};\n\n// O(n^2) time complexity solution\nint maxPoints(vector<Point> &points) {\n\n    #define INT_MAX 2147483647\n    #define INT_MIN (-INT_MAX - 1)\n\n    if (points.size()<=0) return 0;\n    if (points.size()<=2) return points.size();\n    \n    int maxnum = 0;\n    //using a map to find the same slope line\n    map<double, int> slopeMap;\n\n    //The algorithm here is quite straight forward.\n    //   take each point in array to caculate with others\n    //\n    //Actually the algorithm here can be optimized.\n    //   there are many duplicated calculation. \n    //   considering two points A and B, (A,B) is same with (B,A), here re-calculated.\n    for(int i=0; i<points.size(); i++) {\n        //reset teh slope map.\n        slopeMap.clear();\n        slopeMap[INT_MIN] = 0;\n        int samePointCnt = 1;\n        for (int j=0; j<points.size(); j++) {\n            if (i==j) continue; //skip the same point\n            //Caculate the slope of two points\n            int delta_x = points[i].x - points[j].x;\n            int delta_y = points[i].y - points[j].y;\n            //Special case: two points are exactly at same place\n            if (delta_y == 0 && delta_x == 0){\n                samePointCnt++;\n                continue;\n            }\n            //Special case: delta_x == 0\n            double slope = INT_MAX;\n            if (delta_x!=0) {\n                slope = 1.0*delta_y / delta_x;\n            }\n            //Count the points is same line.\n            slopeMap[slope]++;\n        }\n        //find the max number of points located at same line with points[i]\n        map<double, int>::iterator it;\n        for (it = slopeMap.begin(); it != slopeMap.end(); it++) {\n            if (maxnum < it->second + samePointCnt) {\n                maxnum = it->second + samePointCnt;\n            }\n        }\n    }\n\n    return maxnum;\n}\n\nvoid generatePoints(vector<Point> &points, int n) {\n    srand(time(0));\n    Point p;\n    for(int i=0; i<n; i++) {\n        p.x = rand() % 1;\n        p.y = rand() % 1;\n        points.push_back(p);\n    }\n}\n\nvoid printPoints(vector<Point> &points) {\n    for(int i=0; i<points.size(); i++) {\n        cout << \"(\" << points[i].x << \",\" << points[i].y << \") \";\n    }\n    cout << endl;\n}\n\n\nint main(int argc, char** argv) \n{\n    int n = 20;\n    if ( argc > 1) {\n        n = atoi(argv[1]);\n    }\n    vector<Point> points;\n    generatePoints(points, n);\n    printPoints(points);\n    cout << maxPoints(points) << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "wordLadder",
    "question": "/********************************************************************************** \n* \n* Given two words (start and end), and a dictionary, find all shortest transformation \n* sequence(s) from start to end, such that:\n* \n* Only one letter can be changed at a time\n* Each intermediate word must exist in the dictionary\n* \n* For example,\n* \n* Given:\n* start = \"hit\"\n* end = \"cog\"\n* dict = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n* \n* Return\n* \n*   [\n*     [\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],\n*     [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]\n*   ]\n* \n* Note:\n* \n* All words have the same length.\n* All words contain only lowercase alphabetic characters.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/word-ladder-ii/\n// Author : Hao Chen\n// Date   : 2014-10-13\n\n\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <unordered_set>\nusing namespace std;\n\n// Solution\n//\n//      1) Using BSF algorithm build a tree like below\n//      2) Using DSF to parse the tree to the transformation path.\n//\n// For example:\n//\n//     start = \"hit\"\n//     end = \"cog\"\n//     dict = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"dit\",\"hig\", \"dig\"]\n//\n//                      +-----+\n//        +-------------+ hit +--------------+\n//        |             +--+--+              |\n//        |                |                 |\n//     +--v--+          +--v--+           +--v--+\n//     | dit |    +-----+ hot +---+       | hig |\n//     +--+--+    |     +-----+   |       +--+--+\n//        |       |               |          |\n//        |    +--v--+         +--v--+    +--v--+\n//        +----> dot |         | lot |    | dig |\n//             +--+--+         +--+--+    +--+--+\n//                |               |          |\n//             +--v--+         +--v--+       |\n//        +----> dog |         | log |       |\n//        |    +--+--+         +--+--+       |\n//        |       |               |          |\n//        |       |    +--v--+    |          |\n//        |       +--->| cog |<-- +          |\n//        |            +-----+               |\n//        |                                  |\n//        |                                  |\n//        +----------------------------------+\n\nmap< string, unordered_set<string> >& \nbuildTree(string& start, string& end, unordered_set<string> &dict) {\n\n    static map< string, unordered_set<string> > parents;\n    parents.clear();\n\n    unordered_set<string> level[3];\n    unordered_set<string> *previousLevel = &level[0];\n    unordered_set<string> *currentLevel = &level[1];\n    unordered_set<string> *newLevel = &level[2];\n    unordered_set<string> *p =NULL;\n    currentLevel->insert(start);\n\n    bool reachEnd = false;\n\n    while( !reachEnd ) {\n        newLevel->clear();\n        for(auto it=currentLevel->begin(); it!=currentLevel->end(); it++) {    \n            for (int i=0; i<it->size(); i++) {\n                string newWord = *it;\n                for(char c='a'; c<='z'; c++){\n                    newWord[i] = c;\n                    if (newWord == end){\n                        reachEnd = true;\n                        parents[*it].insert(end);\n                        continue;\n                    }\n                    if ( dict.count(newWord)==0 || currentLevel->count(newWord)>0 || previousLevel->count(newWord)>0 ) {\n                        continue;\n                    }\n                    newLevel->insert(newWord);\n                    //parents[newWord].insert(*it);\n                    parents[*it].insert(newWord);\n                }\n            }\n        } \n        if (newLevel->empty()) break;\n\n        p = previousLevel; \n        previousLevel = currentLevel;\n        currentLevel = newLevel;\n        newLevel = p;\n    }\n\n\n    if ( !reachEnd ) {\n        parents.clear();\n    } \n    return parents;\n}\n\nvoid generatePath( string start, string end,\n        map< string, unordered_set<string> > &parents, \n        vector<string> path,\n        vector< vector<string> > &paths) {\n\n    if (parents.find(start) == parents.end()){\n        if (start == end){\n            paths.push_back(path);\n        }\n        return;\n    }\n\n    for(auto it=parents[start].begin(); it!=parents[start].end(); it++){\n        path.push_back(*it);\n        generatePath(*it, end, parents, path, paths);\n        path.pop_back();\n    }\n\n}\n\nvector< vector<string> > \nfindLadders(string start, string end, unordered_set<string> &dict) {\n\n    vector< vector<string> > ladders;\n    vector<string> ladder;\n    ladder.push_back(start);\n    if (start == end){\n        ladder.push_back(end);\n        ladders.push_back(ladder);\n        return ladders;\n    }\n\n    map< string, unordered_set<string> >& parents = buildTree(start, end, dict);\n\n    if  (parents.size()<=0) {\n        return ladders;\n    }\n\n    generatePath(start, end, parents, ladder, ladders);\n\n    return ladders;\n}\n\nvoid printLadders(vector< vector<string> > &ladders){\n    int i, j;\n    for (i=0; i<ladders.size(); i++){\n        for (j=0; j<ladders[i].size()-1; j++){\n            cout << ladders[i][j] << \" -> \";\n        }\n        cout << ladders[i][j] << endl; \n    }\n}\n\nint main(int argc, char** argv)\n{\n    string start = \"hit\";\n    string end = \"cog\";\n    //unordered_set<string> dict ({\"hot\",\"dot\",\"dog\",\"lot\",\"log\"});\n    unordered_set<string> dict ({\"bot\",\"cig\", \"cog\", \"dit\", \"dut\", \"hot\", \"hit\" ,\"dot\",\"dog\",\"lot\",\"log\"});\n\n    vector< vector<string> > ladders;\n    ladders = findLadders(start, end, dict);\n    printLadders(ladders);\n    return 0;\n}\n"
  },
  {
    "question_theme": "containsDuplicate",
    "question": "/********************************************************************************** \n * \n * Given an array of integers, find out whether there are two distinct indices i and j \n * in the array such that the difference between nums[i] and nums[j] is at most t and \n * the difference between i and j is at most k.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/contains-duplicate-iii/\n// Author : Hao Chen\n// Date   : 2015-06-12\n\n\n\n\n\nclass Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        if(nums.size() < 2 || k == 0) return false;\n        int low = 0;\n        //maintain a sliding window \n        set<long long> window;\n        for (int i=0; i<nums.size(); i++){\n            //make sure window size <= k\n            if (i - low > k) {\n                window.erase(nums[low]);\n                low++;\n            }\n            \n            // lower_bound() is the key, \n            // it returns an iterator pointing to the first element >= val \n            auto it = window.lower_bound((long long)nums[i] - (long long)t );\n            if (it != window.end() && abs((long long)nums[i] - *it) <= (long long)t) {\n                return true;\n            }\n            window.insert(nums[i]);\n        }\n        return false;\n    }\n};\n\n"
  },
  {
    "question_theme": "scrambleString",
    "question": "/********************************************************************************** \n* \n* Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.\n* \n* Below is one possible representation of s1 = \"great\":\n* \n*     great\n*    /    \\\n*   gr    eat\n*  / \\    /  \\\n* g   r  e   at\n*            / \\\n*           a   t\n* \n* To scramble the string, we may choose any non-leaf node and swap its two children.\n* \n* For example, if we choose the node \"gr\" and swap its two children, it produces a scrambled string \"rgeat\".\n* \n*     rgeat\n*    /    \\\n*   rg    eat\n*  / \\    /  \\\n* r   g  e   at\n*            / \\\n*           a   t\n* \n* We say that \"rgeat\" is a scrambled string of \"great\".\n* \n* Similarly, if we continue to swap the children of nodes \"eat\" and \"at\", it produces a scrambled string \"rgtae\".\n* \n*     rgtae\n*    /    \\\n*   rg    tae\n*  / \\    /  \\\n* r   g  ta  e\n*        / \\\n*       t   a\n* \n* We say that \"rgtae\" is a scrambled string of \"great\".\n* \n* Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/scramble-string/\n// Author : Hao Chen\n// Date   : 2014-10-09\n\n\n\n#include <stdlib.h>\n#include <time.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// The recursive way is quite simple.\n//    1) break the string to two parts: \n//          s1[0..j]   s1[j+1..n]\n//          s2[0..j]   s2[j+1..n]\n//    2) then\n//          isScramble(s1[0..j], s2[0..j]) &&  isScramble(s1[j+1..n], s2[j+1..n])\n//        OR\n//          isScramble(s1[0..j], s2[j+1, n]) &&  isScramble(s1[j+1..n], s2[0..j])\nbool isScramble_recursion(string s1, string s2) {\n\n    if (s1.size()!= s2.size() || s1.size()==0 || s2.size()==0) {\n        return false;\n    }\n    if (s1 == s2){\n        return true;\n    } \n    string ss1 = s1;\n    string ss2 = s2;\n    sort(ss1.begin(), ss1.end()); \n    sort(ss2.begin(), ss2.end()); \n    if (ss1 != ss2 ) {\n        return false;\n    }\n\n    for (int i=1; i<s1.size(); i++) {\n        if ( isScramble_recursion(s1.substr(0,i), s2.substr(0,i)) && \n             isScramble_recursion(s1.substr(i, s1.size()-i), s2.substr(i, s2.size()-i)) ) {\n            return true;\n        }\n        if ( isScramble_recursion(s1.substr(0,i), s2.substr(s2.size()-i, i)) && \n             isScramble_recursion(s1.substr(i, s1.size()-i), s2.substr(0, s2.size()-i)) ) {\n            return true;\n        }\n    }\n\n    return false;\n    \n}\n\n\nbool isScramble_dp(string s1, string s2) {\n\n    if (s1.size()!= s2.size() || s1.size()==0 || s2.size()==0) {\n        return false;\n    }\n    if (s1 == s2){\n        return true;\n    }\n\n    const int len = s1.size();    \n    \n    // dp[len+1][len][len]\n    vector< vector< vector<bool> > > dp(len+1, vector< vector<bool> >(len, vector<bool>(len) ) );\n   \n    // ignor the k=0, just for readable code.\n\n    // initialization k=1\n    for (int i=0; i<len; i++){\n        for (int j=0; j<len; j++) {\n            dp[1][i][j] = (s1[i] == s2[j]);\n        }\n    } \n    // start from k=2 to len, O(n^4) loop. \n    for (int k=2; k<=len; k++){\n        for (int i=0; i<len-k+1; i++){\n            for (int j=0; j<len-k+1; j++){\n                dp[k][i][j] = false;\n                for (int divk = 1; divk < k && dp[k][i][j]==false; divk++){\n                    dp[k][i][j] = ( dp[divk][i][j] && dp[k-divk][i+divk][j+divk] ) ||\n                                  ( dp[divk][i][j+k-divk] && dp[k-divk][i+divk][j] );\n                }\n            }\n        }\n    }\n    \n    return dp[len][0][0];\n}\n\nbool isScramble(string s1, string s2) {\n\n    srand(time(0));\n\n    if (random()%2) {\n        cout << \"---- recursion ---\" << endl;\n        return isScramble_recursion(s1, s2);\n    }\n    cout << \"---- dynamic programming ---\" << endl;\n    return isScramble_dp(s1, s2);\n}\n\nint main(int argc, char** argv)\n{\n    string s1=\"great\", s2=\"rgtae\";\n    if (argc>2){\n        s1 = argv[1];\n        s2 = argv[2];\n    }\n    cout << s1 << \", \" << s2 << endl;\n    cout << isScramble(s1, s2) << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "longestSubstringWithAtLeastKRepeatingCharacters",
    "question": "/*************************************************************************************** \n *\n * Find the length of the longest substring T of a given string (consists of lowercase \n * letters only) such that every character in T appears no less than k times.\n * \n * Example 1:\n * \n * Input:\n * s = \"aaabb\", k = 3\n * \n * Output:\n * 3\n * \n * The longest substring is \"aaa\", as 'a' is repeated 3 times.\n * \n * Example 2:\n * \n * Input:\n * s = \"ababbc\", k = 2\n * \n * Output:\n * 5\n * \n * The longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 \n * times.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/\n// Author : Hao Chen\n// Date   : 2016-09-08\n\n\n\nconst int NO_OF_CHARS = 256;\n\n\n\n\nclass Solution {\npublic:\n    int longestSubstring(string s, int k) {\n        \n        //deal with edge cases\n        if (s.size() == 0 || s.size() < k) return 0;\n        if (k==1) return s.size();\n\n        //declare a map for every char's counter\n        int count[NO_OF_CHARS];\n        memset(count , 0, sizeof(count));\n        \n        //counting every char\n        for (char ch : s) {\n            count[ch]++;\n        }\n        \n        int i=0;\n        for ( i=0; i<NO_OF_CHARS; i++) {\n            if (count[i] !=0 && count[i] < k) break;\n        }\n        //all of the chars meet the requirement\n        if ( i >= NO_OF_CHARS ) return s.size();\n        \n        // find the most infrequent char\n        char least = 0;\n        for (int c = 0; c < NO_OF_CHARS; c++) {\n            if (count[c] == 0) continue;\n            if (least == 0) {\n                least = c;\n            } else if ( count[c] < count[least]) {\n                least = c;\n            }\n        }\n        \n        //split the string and run them recursively\n        vector<string> subs;\n        split(s, least, subs);\n        \n        int res = 0;\n        for (string str: subs) {\n            res = max(res, longestSubstring(str, k));\n        }\n        return res;\n        return 0;\n    }\n    \nprivate:\n    \n    inline int max(int x, int y) { return x>y? x:y; }\n    \n    inline void split(const string &s, char delim, vector<string> &elems) {\n        stringstream ss;\n        ss.str(s);\n        string item;\n        while (getline(ss, item, delim)) {\n            cout << item << endl;\n            elems.push_back(item);\n        }\n    }\n\n\n    inline vector<string> split(const string &s, char delim) {\n        vector<string> elems;\n        split(s, delim, elems);\n        return elems;\n    }\n};\n"
  },
  {
    "question_theme": "integerBreak",
    "question": "/*************************************************************************************** \n *\n * Given a positive integer n, break it into the sum of at least two positive integers \n * and maximize the product of those integers. Return the maximum product you can get.\n * \n * For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 \n * + 4).\n * \n * Note: you may assume that n is not less than 2.\n * \n *   There is a simple O(n) solution to this problem.\n *   You may check the breaking results of n ranging from 7 to 10 to discover the \n * regularities.\n * \n * Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating \n * all test cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/integer-break/\n// Author : Hao Chen\n// Date   : 2016-05-29\n\n\n\nclass Solution {\npublic:\n    // As the hint said, checking the n with ranging from 7 to 10 to discover the regularities.\n    // n = 7,    3*4 = 12\n    // n = 8,  3*3*2 = 18\n    // n = 9,  3*3*3 = 27\n    // n = 10, 3*3*4 = 36\n    // n = 11, 3*3*3*2 = 54\n    //\n    // we can see we can break the number by 3 if it is greater than 4;\n    //\n    int integerBreak(int n) {\n        if ( n == 2 ) return 1;\n        if ( n == 3 ) return 2;\n        int result = 1;\n        while( n > 4 ) {\n            result *= 3;\n            n -= 3;\n        }\n        result *= n;\n        return result;\n    }\n};\n\n"
  },
  {
    "question_theme": "numberOfDigitOne",
    "question": "/********************************************************************************** \n * \n * Given an integer n, count the total number of digit 1 appearing in all non-negative \n * integers less than or equal to n.\n * \n * For example: \n * Given n = 13,\n * Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.\n * \n *   Beware of overflow.\n * \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/number-of-digit-one/\n// Author : Hao Chen\n// Date   : 2015-07-17\n\n\n\n\n\nclass Solution {\npublic:\n\n    int countDigitOne(int n) {\n        long long base=1, left=n, right=0, currDigit=0;\n        int numOfOne = 0;\n        while(left>0) {\n            currDigit = left % 10;\n            left = left/ 10;\n            \n            if (currDigit == 0) {\n                numOfOne += (left * base);\n            }else if (currDigit == 1) {\n                numOfOne += (left * base + right + 1);\n            }else {\n                numOfOne += ((left+1)*base);\n            }\n            \n            right = right + currDigit * base;\n            base *= 10;\n        }\n        return numOfOne;\n    }\n};\n"
  },
  {
    "question_theme": "excelSheetColumnNumber",
    "question": "/********************************************************************************** \n * \n * Related to question Excel Sheet Column Title\n * Given a column title as appear in an Excel sheet, return its corresponding column number.\n * \n * For example:\n *     A -> 1\n *     B -> 2\n *     C -> 3\n *     ...\n *     Z -> 26\n *     AA -> 27\n *     AB -> 28 \n * \n * Credits:Special thanks to @ts for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/excel-sheet-column-number/\n// Author : Hao Chen\n// Date   : 2014-12-29\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <string>\nusing namespace std;\n\n\nstring base26_int2str(long long n) {\n    string ret;\n    while(n>0){\n        char ch = 'A' + (n-1)%26;\n        ret.insert(ret.begin(), ch  );\n        n -= (n-1)%26;\n        n /= 26;\n    }\n    return ret;\n}\n\nlong long base26_str2int(string& s){\n    long long ret=0;\n    for (int i=0; i<s.size(); i++){\n        int n = s[i] - 'A' + 1;\n        ret = ret*26 + n;\n    }\n    return ret;\n}\n\n\nstring titleToNumber(int n) {\n    return base26_str2int(n);\n}\n\nint main(int argc, char**argv)\n{\n    long long n = 27; \n    if (argc>1){\n        n = atoll(argv[1]);\n    }\n    string ns = base26_int2str(n);\n    n = base26_str2int(ns);\n\n    cout << n << \" = \" << ns << endl;\n\n\n    ns = \"ABCDEFG\";\n    if (argc>2){\n        ns = argv[2];\n    }\n    cout << ns << \" = \" << base26_str2int(ns) << endl;\n}\n"
  },
  {
    "question_theme": "missingNumber",
    "question": "/*************************************************************************************** \n *\n * Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the \n * one that is missing from the array.\n * \n * For example,\n * Given nums = [0, 1, 3] return 2.\n * \n * Note:\n * Your algorithm should run in linear runtime complexity. Could you implement it using \n * only constant extra space complexity?\n * \n * Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating \n * all test cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/missing-number/\n// Author : Hao Chen\n// Date   : 2015-10-22\n\n\n\nclass Solution {\npublic:\n    // This problem can be converted to the classic problem --\n    //    `There is an array, all of numbers except one appears twice, and that one only appears once`\n    // It means, we can combin two arrays together, one is [1..n], another one is `nums`.\n    // Then, you know, we can use the XOR solve this problem.\n    \n    int missingNumber01(vector<int>& nums) {\n        int result = 0;\n        for(int i=0; i<nums.size(); i++){\n            result ^=  nums[i];\n        }\n        for(int i=1; i<=nums.size(); i++){\n            result ^=(i);\n        }\n        return result;\n    }\n    \n    // We can simplify the previous solution as below\n    int missingNumber02(vector<int>& nums) {\n        int result = 0;\n        for(int i=0; i<nums.size(); i++){\n            result = result ^ (i+1) ^ nums[i];\n        }\n        return result;\n    }\n    \n    int missingNumber(vector<int>& nums) {\n        //By Leetcode running result, they all are same performance\n        return missingNumber02(nums); //36ms\n        return missingNumber01(nums); //36ms\n    }\n};\n"
  },
  {
    "question_theme": "generateParentheses",
    "question": "/********************************************************************************** \n* \n* Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n* \n* For example, given n = 3, a solution set is:\n* \n* \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/generate-parentheses/\n// Author : Hao Chen\n// Date   : 2014-06-29\n\n\n\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nvoid generator(vector<string>& result, int left, int right, string s);\nvector<string> generateParenthesis(int n) {\n    \n    vector<string> result;\n    string s;\n    generator(result, n, n, s);\n    return result;\n}\n\nvoid generator(vector<string>& result, int left, int right, string s){\n    if (left==0 && right==0){\n        result.push_back(s);\n        return;\n    }\n    if (left>0){\n        generator(result, left-1, right, s+'(');\n    }\n    if (right>0 && right>left){\n        generator(result, left, right-1, s+')');\n    }\n}\n    \nvoid printResult(vector<string>& result)\n{\n    for(int i=0; i<result.size(); i++){\n        cout << result[i] <<endl;\n    }\n}\n\nint main(int argc, char** argv) \n{\n    int n=3;\n    if (argc>1){\n        n = atoi(argv[1]);\n    }\n    vector<string> r = generateParenthesis(n);\n    printResult(r);\n    return 0;\n}\n"
  },
  {
    "question_theme": "LRUCache",
    "question": "/********************************************************************************** \n* \n* Design and implement a data structure for Least Recently Used (LRU) cache. \n* It should support the following operations: get and set.\n* \n*    get(key) - Get the value (will always be positive) of the key if the key exists \n*               in the cache, otherwise return -1.\n*\n*    set(key, value) - Set or insert the value if the key is not already present. \n*                      When the cache reached its capacity, it should invalidate \n*                      the least recently used item before inserting a new item.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/lru-cache/\n// Author : Hao Chen\n// Date   : 2014-10-12\n\n\n\n#include <stdlib.h>\n#include <time.h>\n#include <iostream>\n#include <map>\nusing namespace std;\n\n// The idea here is quite simple:\n//    1) A Map to index the key.  O(1) key search time-complexity.\n//    2) A List to sort the cache data by accessed time.\n// \n//  Considering there are too many insert/delete opreations for the List, \n//  The ouble linked list is the good data structure to performance it.\n\nclass Node {\n    public:\n        int key;\n        int value;\n        Node *next, *prev;\n        Node(int k, int v) { key=k; value=v; next = prev = NULL; }\n        //Node(int k, int v, Node* n=NULL, Node* p=NULL): key(k), value(v), next(n), prev(p) {}\n};\n\n// the following double linked list seems a bit commplicated.\nclass DoubleLinkedList {\n\n    private:\n\n        Node *pHead, *pTail;\n        int size;\n\n\n    public:\n\n        DoubleLinkedList(){\n            pHead = pTail = NULL;\n            size = 0;\n        }\n        ~DoubleLinkedList() {\n            while(pHead!=NULL){\n                Node*p = pHead;\n                pHead = pHead->next;\n                delete p;\n            }\n        }\n\n        int Size() const {\n            return size;\n        }\n\n        Node* NewAtBegin(int key, int value) {\n            Node *n = new Node(key, value);\n            return AddAtBegin(n);\n        }\n\n        Node* NewAtEnd(int key, int value) {\n            Node *n = new Node(key, value);\n            return AddAtEnd(n);\n        }\n\n        Node* AddAtBegin(Node* n){\n            size++;\n\n            if (pHead==NULL) { \n                pHead = pTail = n; \n                return n; \n            }\n\n            n->next = pHead;\n            n->prev = NULL;\n            pHead->prev = n;\n            pHead = n;\n            return n;\n        }\n\n        Node* AddAtEnd(Node* n) {\n            size++;\n\n            if (pHead==NULL) { \n                pHead = pTail = n; \n                return n; \n            }\n\n            pTail->next = n;\n            n->prev = pTail;\n            n->next = NULL;\n            pTail = n;\n        }\n\n        void Unlink(Node* n){\n            Node* before = n->prev;\n            Node* after = n->next;\n\n            if (before){\n                before->next = after;  \n            }\n\n            if (after){ \n                after->prev = before;\n            }\n\n            if(pHead == n){\n                pHead = pHead->next;\n            }else if(pTail == n) {\n                pTail = pTail->prev;\n            }\n\n            size--;\n        }\n\n        void Delete(Node* n){\n            Unlink(n);\n            delete n;\n        }\n\n        void TakeToBegin(Node* n){\n            Unlink(n);\n            AddAtBegin(n);\n        } \n\n        Node* GetTailNode() {\n            return pTail;\n        } \n\n        void DeleteLast() {\n            Delete(pTail);\n        } \n\n        void Print(){\n            Node* p = pHead;\n            while(p!=NULL) {\n                cout << \"(\" << p->key << \",\" << p->value << \") \";\n                p = p->next;\n            }\n            cout << endl;\n        }\n};\n\n\n\nclass LRUCache{\n\n    private:\n        //cacheList - store the date\n        DoubleLinkedList cacheList;\n        //cacheMap - index the date for searching\n        map<int, Node*> cacheMap;\n        //the max capcity of cache\n        int capacity;\n\n    public:\n        LRUCache(int capacity) {\n            this->capacity = capacity;    \n        }\n        void print(){\n            cacheList.Print();\n        }\n\n        int get(int key) {\n            // The accessed node must be up-to-time -- take to the front \n            if (cacheMap.find(key) != cacheMap.end() ){\n                cacheList.TakeToBegin(cacheMap[key]);\n                return cacheMap[key]->value;\n            }\n            return -1;\n\n        }\n\n        void set(int key, int value) {\n            // key found, update the data, and take to the front \n            if (cacheMap.find(key) != cacheMap.end() ){\n                Node *p = cacheMap[key];\n                p->value = value;\n                cacheList.TakeToBegin(cacheMap[key]);\n            }else{\n                // key not found, new a node to store data\n                cacheMap[key] = cacheList.NewAtBegin(key, value);\n                // if the capacity exceed, remove the last one.\n                if( cacheList.Size() > capacity) {\n                    int key = cacheList.GetTailNode()->key; \n                    cacheMap.erase(key);\n                    cacheList.DeleteLast();\n                }\n            }\n        }\n};\n\n\nint main(int argc, char** argv) \n{\n\n    \n    srand(time(0));\n\n    int capacity = 5;\n    int test_loop_times = 10;\n    if (argc>1){\n        capacity = atoi(argv[1]);\n    }\n    if (argc>2){\n        test_loop_times = atoi(argv[1]);\n    }\n\n    LRUCache cache(capacity);\n\n    int v; \n    for(int i=0; i<test_loop_times; i++) {\n        v = i;//rand() % capacity;\n        cout << \"set \" << v << \": \";\n        cache.set(v, v);\n        cache.print();\n\n        v = rand() % capacity;\n        cout << \"get \" << v << \": \" << cache.get(v);\n        cache.print();\n\n        cout << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "question_theme": "addBinary",
    "question": "/********************************************************************************** \n* \n* Given two binary strings, return their sum (also a binary string).\n* \n* For example,\n* a = \"11\"\n* b = \"1\"\n* Return \"100\".\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/add-binary/\n// Author : Hao Chen\n// Date   : 2014-07-05\n\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstring addBinary(string a, string b) {\n    int alen = a.size();\n    int blen = b.size();\n    bool carry = false;\n    string result;\n    while( alen>0 || blen>0) {\n        int abit = alen<=0 ? 0 : a[alen-1]-'0';\n        int bbit = blen<=0 ? 0 : b[blen-1]-'0';\n        int cbit = carry ? 1 : 0;\n        result.insert(result.begin(), '0' + ((abit+bbit+cbit) & 1) );\n        carry = (abit+bbit+cbit>1);\n        alen--; blen--;\n    }\n    if (carry){\n        result.insert(result.begin(), '1');\n    }\n    return result;\n}\n\n\nint main(int argc, char** argv) \n{\n    string a = \"11\";\n    string b = \"1\";\n    if (argc>2){\n        a = argv[1];\n        b = argv[2];\n    }\n\n    cout << a << \"+\" << b << \"=\" << addBinary(a, b) << endl;\n    \n}\n"
  },
  {
    "question_theme": "cloneGraph",
    "question": "/********************************************************************************** \n* \n* Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.\n* \n* OJ's undirected graph serialization:\n* \n* Nodes are labeled uniquely.\n* \n* We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.\n* \n* As an example, consider the serialized graph {0,1,2#1,2#2,2}.\n* \n* The graph has a total of three nodes, and therefore contains three parts as separated by #.\n* \n* First node is labeled as 0. Connect node 0 to both nodes 1 and 2.\n* Second node is labeled as 1. Connect node 1 to node 2.\n* Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.\n* \n* Visually, the graph looks like the following:\n* \n*        1\n*       / \\\n*      /   \\\n*     0 --- 2\n*          / \\\n*          \\_/\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/clone-graph/\n// Author : Hao Chen\n// Date   : 2014-10-12\n\n\n\n\nclass Solution {\npublic:\n    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\n        if (node == NULL) return NULL;\n        \n        //create a map, key is source node, value is clone node.\n        map<UndirectedGraphNode*, UndirectedGraphNode*> cloneMap;\n        \n        //using queue for breadth first search\n        queue<UndirectedGraphNode*> q;\n        q.push(node);\n        \n        //clone the root\n        UndirectedGraphNode* cloneNode = new UndirectedGraphNode(node->label);\n        cloneMap[node] = cloneNode;\n        \n        //breadth first search\n        while(!q.empty()){\n            UndirectedGraphNode* n = q.front();\n            q.pop();\n            //for each neighbors\n            for(int i=0; i<n->neighbors.size(); i++){\n                UndirectedGraphNode* neighbor= n->neighbors[i];\n                //not existed in cloneMap\n                if (cloneMap.find(neighbor)==cloneMap.end()){\n                    //clone a node\n                    UndirectedGraphNode* newNode = new UndirectedGraphNode(neighbor->label);\n                    cloneMap[n]->neighbors.push_back(newNode);\n                    cloneMap[neighbor] = newNode;\n                    \n                    //put the neighbors into the queue\n                    q.push(neighbor);\n                }else{\n                    cloneMap[n]->neighbors.push_back(cloneMap[neighbor]);\n                }\n            }\n        }\n        \n        return cloneNode;\n    }\n};\n"
  },
  {
    "question_theme": "oneEditDistance",
    "question": "/*\n *    Given two strings S and T, determine if they are both one edit distance apart.\n *",
    "answer": "// Source : https://oj.leetcode.com/problems/one-edit-distance/\n// Author : Hao Chen\n// Date   : 2014-12-03\n\n\n\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <string>\nusing namespace std;\n\n\n\n\nbool isOneEditDistance(string s, string t) {\n    int len_s = s.size();\n    int len_t = t.size();\n    if (len_s==0) return len_t==1;\n    if (len_t==0) return len_s==1;\n\n\n    switch (abs(len_s-len_t)) {\n        case 0:\n            {\n                //if these two strings have same length.\n                //it means - we cannot use `add` or `delete` edit methods, just use the `replace` method\n                //So, just simply count the different char(s).\n                int cnt=0;\n                for (int i=0; i<len_s; i++){\n                    if(s[i]!=t[i]){\n                        cnt++;\n                        if(cnt>1) return false;\n                    }\n                }\n                return cnt==1;\n            }\n\n        case 1:\n            {\n                //if these two strings' length just have ONE difference.\n                //it means - we only can use `delete` edit method to delete one char in longer string.\n                //So, just remove one char in longer string, and check it whether equal to shorter string.\n                string& ss = (len_s > len_t)? s : t;\n                string& tt = (len_s < len_t)? s : t;\n                for(int i=0; i<ss.size(); i++){\n                    string tmp = ss;\n                    if (ss.erase(i,1) == tt) {\n                        return true;\n                    }\n                }\n                return false;\n\n            }\n\n        default:\n            return false;\n    }\n\n    return false;\n}\n\nint main(int argc, char** argv)\n{\n    string s=\"ab\", t=\"acb\";\n    if(argc>2){\n        s = argv[1];\n        t = argv[2];\n    }\n    cout << \"s = \\\"\" << s << \"\\\"  t = \\\"\" << t << \"\\\"  : \" << (isOneEditDistance(s,t) ? \"true\" : \"false\") << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "powerOfTwo",
    "question": "/********************************************************************************** \n * \n * Given an integer, write a function to determine if it is a power of two.\n * \n * Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating \n * all test cases.\n *               \n *               \n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/power-of-two/\n// Author : Hao Chen\n// Date   : 2015-07-16\n\n\n\n\nclass Solution {\npublic:\n\n    // count the number fo bits 1, if it only has one, then return true\n    bool isPowerOfTwo01(int n) {\n        int cnt = 0; //num of bits 1\n        for(; n>0; n>>=1){\n            if ( n & 1 ) {\n                cnt++;\n                if (cnt>1) return false;\n            }\n        }\n        return cnt==1;\n    }\n    \n    //we notice: 2^n - 1 always be 1111111...\n    //so, (2^n) & (2^n-1) always be zero\n    bool isPowerOfTwo02(int n) {\n        return n<=0 ? false : (n & (n-1)) == 0;\n    }\n    \n    bool isPowerOfTwo(int n) {\n        if (random()%2){\n            return isPowerOfTwo02(n);\n        }\n        return isPowerOfTwo01(n);\n    }\n};\n"
  },
  {
    "question_theme": "dungeonGame",
    "question": "/********************************************************************************** \n * \n * The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. \n * The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned \n * in the top-left room and must fight his way through the dungeon to rescue the princess. \n *\n * The knight has an initial health point represented by a positive integer. \n * If at any point his health point drops to 0 or below, he dies immediately. \n *\n * Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; \n * other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).\n * In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. \n * \n * Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.\n * For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path \n * RIGHT-> RIGHT -> DOWN -> DOWN.\n * \n *   \n *   +------+------+------+\n *   |      |      |      |\n *   | -2(K)|  -3  |  -3  |\n *   |      |      |      |\n *   +--------------------+\n *   |      |      |      |\n *   |  -5  | -10  |   1  |\n *   |      |      |      |\n *   +--------------------+\n *   |      |      |      |\n *   |  10  |  30  | -5(P)|\n *   |      |      |      |\n *   +------+------+------+\n *   \n * \n * Notes:\n * \n * The knight's health has no upper bound.\n * Any room can contain threats or power-ups, \n * even the first room the knight enters and the bottom-right room where the princess is imprisoned.  \n * \n * Credits:Special thanks to @stellari for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/dungeon-game/\n// Author : Hao Chen\n// Date   : 2015-01-16\n\n\n\nclass Solution {\n    public:\n        int calculateMinimumHP(vector<vector<int> > &dungeon) {\n            int row = dungeon.size();\n            int col = row>0 ? dungeon[0].size() : 0;\n            if (row<=0 || col <=0) return 0;\n\n            //dp[r][c] = min( max( dp[r+1][c] - dungeon[r][c], 1), max( dp[r][c+1] - dungeon[r][c], 1) );\n            int dp[row][col];\n            memset(dp, 0, sizeof(dp));\n\n            for(int r=row-1; r>=0; r--){\n                for (int c=col-1; c>=0; c--){\n\n                    \n\n                    if (r == row - 1 && c == col - 1 ){\n                        dp[r][c] = max(1 - dungeon[r][c], 1);\n                    }else{ \n                        int h1 = ( c == col-1  ) ? INT_MAX : max(dp[r][c+1] - dungeon[r][c], 1);\n                        int h2 =  ( r == row-1 ) ? INT_MAX : max(dp[r+1][c] - dungeon[r][c], 1);\n\n                        dp[r][c] = min( h1, h2 );\n                    }\n\n                }\n            }\n\n            return dp[0][0];\n\n\n        }\n};\n"
  },
  {
    "question_theme": "kthSmallestElementInaBST",
    "question": "/********************************************************************************** \n * \n * Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.\n * \n * Note: \n * You may assume k is always valid, 1 \u2264 k \u2264 BST's total elements.\n * \n * Follow up:\n * What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? \n * How would you optimize the kthSmallest routine?\n * \n *   Try to utilize the property of a BST.\n *   What if you could modify the BST node's structure?\n *   The optimal runtime complexity is O(height of BST).\n * \n * Credits:Special thanks to @ts for adding this problem and creating all test cases.\n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/kth-smallest-element-in-a-bst/\n// Author : Hao Chen\n// Date   : 2015-07-03\n\n\n\n\n\nclass Solution {\npublic:\n    // in-order travel - recursive way\n    int kthSmallestHelper_recursive(TreeNode* root, int& k) {\n        if (root==NULL) return 0; //this behavior is undefined!\n        \n        //in-order travel\n        int result = kthSmallestHelper_recursive(root->left, k);\n        if (k==0) return result;\n        \n        k--;\n        if (k==0) return root->val;\n        \n        \n        return kthSmallestHelper_recursive(root->right, k);\n    }\n    // in-order travel - non-recursive way\n    int kthSmallestHelper_nonRecursive(TreeNode* root, int k){\n        stack<TreeNode*> s;\n        \n        while(!s.empty() || root){\n            \n            while (root) { \n                s.push(root);\n                root = root->left;\n            }\n            \n            k--;\n            root = s.top()->right;\n\n            if (k==0) return s.top()->val;\n            \n            s.pop();\n        }\n        return -1;\n    }\n    \n    int kthSmallest(TreeNode* root, int k) {\n        //return kthSmallestHelper_nonRecursive(root, k);\n        return kthSmallestHelper_recursive(root, k);\n    }\n};\n"
  },
  {
    "question_theme": "binaryTreePostorderTraversal",
    "question": "/********************************************************************************** \n* \n* Given a binary tree, return the postorder traversal of its nodes' values.\n* \n* For example:\n* Given binary tree {1,#,2,3},\n* \n*    1\n*     \\\n*      2\n*     /\n*    3\n* \n* return [3,2,1].\n* \n* Note: Recursive solution is trivial, could you do it iteratively?\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/binary-tree-postorder-traversal/\n// Author : Hao Chen\n// Date   : 2014-07-21\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvector<int> postorderTraversal1(TreeNode *root);\nvector<int> postorderTraversal2(TreeNode *root);\n\n\n// We have two methods here.\n//   1) the first one acutally is pre-order but reversed the access order.\n//   2) the second one is the traditional one \n\nvector<int> postorderTraversal(TreeNode *root) {\n    if (random()%2){\n        cout << \"---method one---\" << endl;\n        return postorderTraversal1(root);\n    }\n    cout << \"---method two---\" << endl;\n    return postorderTraversal2(root);\n}\n\n\nvector<int> postorderTraversal1(TreeNode *root) {\n    vector<int> v;\n    vector<TreeNode*> stack;\n    if (root) {\n        stack.push_back(root);\n    }\n    while (stack.size()>0){\n        TreeNode *n = stack.back();\n        stack.pop_back();\n        v.push_back(n->val);\n        if (n->left){\n            stack.push_back(n->left);\n        } \n        if (n->right) {\n            stack.push_back(n->right);\n        }\n    }\n    std::reverse(v.begin(), v.end());  // the trick\n    return v;\n}\n\n// traditional and standard way.\n// using the stack to simulate the recursive function stack.\nvector<int> postorderTraversal2(TreeNode *root) {\n    vector<int> v;\n    vector<TreeNode*> stack;\n    TreeNode *node = root;\n    TreeNode *lastVisitNode = NULL;\n    while(stack.size()>0 || node!=NULL){\n\n        if (node != NULL){\n            // keep going the left\n            stack.push_back(node);\n            node = node->left;\n        }else{\n            TreeNode *n = stack.back();\n            // left way is finsised, keep going to the right way\n            if (n->right != NULL && lastVisitNode != n->right){\n                node = n->right;\n            }else{\n                // both left and right has been accessed.\n                stack.pop_back();\n                v.push_back(n->val);\n                lastVisitNode = n;\n            }\n        }\n    }\n    return v;\n}\n\n\nTreeNode* createTree(int a[], int n)\n{\n    if (n<=0) return NULL;\n\n    TreeNode **tree = new TreeNode*[n];\n\n    for(int i=0; i<n; i++) {\n        if (a[i]==0 ){\n            tree[i] = NULL;\n            continue;\n        }\n        tree[i] = new TreeNode(a[i]);\n    }\n    int pos=1;\n    for(int i=0; i<n && pos<n; i++) {\n        if (tree[i]){\n            tree[i]->left = tree[pos++];\n            if (pos<n){\n                tree[i]->right = tree[pos++];\n            }\n        }\n    }\n    return tree[0];\n}\n\nvoid printTree_post_order(TreeNode *root)\n{\n    if (root == NULL){\n        //cout << \"# \";\n        return ;\n    }\n    printTree_post_order(root->left);\n    printTree_post_order(root->right);\n    cout << root->val << \" \";\n}\n\n\nvoid printArray(vector<int> v)\n{\n    for(int i=0; i<v.size(); i++){\n        cout << v[i] << \" \";\n    }\n    cout << endl;\n}\n\nint main()\n{\n    srand(time(0));\n    int a[] = {1,2,3,4,5,0,6,0,0,7,8,9,0};\n    TreeNode* p = createTree(a, sizeof(a)/sizeof(int));\n    printTree_post_order(p);\n    cout << endl;\n    vector<int> v = postorderTraversal(p);\n    printArray(v);\n    cout << endl;\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "addTwoNumbers",
    "question": "/********************************************************************************** \n* \n* You are given two linked lists representing two non-negative numbers. \n* The digits are stored in reverse order and each of their nodes contain a single digit. \n* Add the two numbers and return it as a linked list.\n* \n* Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)\n* Output: 7 -> 0 -> 8\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/add-two-numbers/\n// Author : Hao Chen\n// Date   : 2014-06-18\n\n\n\n\nclass Solution {\n    \npublic:\n    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {\n        int x=0, y=0, carry=0, sum=0;\n        ListNode *h=NULL, **t=&h;\n        \n        while (l1!=NULL || l2!=NULL){\n            x = getValueAndMoveNext(l1);\n            y = getValueAndMoveNext(l2);\n            \n            sum = carry + x + y;\n            \n            ListNode *node = new ListNode(sum%10);\n            *t = node;\n            t = (&node->next);\n            \n            carry = sum/10;\n        }\n        \n        if (carry > 0) {\n            ListNode *node = new ListNode(carry%10);\n            *t = node;\n        }\n        \n        return h;\n    }\nprivate:\n    int getValueAndMoveNext(ListNode* &l){\n        int x = 0;\n        if (l != NULL){\n            x = l->val;\n            l = l->next;\n        }\n        return x;\n    }\n};\n"
  },
  {
    "question_theme": "uglyNumber",
    "question": "/*************************************************************************************** \n *\n * Write a program to find the n-th ugly number.\n * \n * Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For \n * example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.\n * \n * Note that 1 is typically treated as an ugly number.\n * \n *   The naive approach is to call isUgly for every number until you reach the nth one. \n * Most numbers are not ugly. Try to focus your effort on generating only the ugly ones.\n *\n *   An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number.\n *\n *   The key is how to maintain the order of the ugly numbers. Try a similar approach \n * of merging from three sorted lists: L1, L2, and L3.\n *\n *   Assume you have Uk, the kth ugly number. Then Uk+1 must be Min(L1 * 2, L2 * 3, L3 \n * * 5).\n * \n * Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating \n * all test cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/ugly-number-ii/\n// Author : Hao Chen\n// Date   : 2015-10-21\n\n\n\nclass Solution {\npublic:\n\n    int min(int a, int b) {\n        return a < b ? a:b;\n    }\n    \n    int min(int a, int b, int c) {\n        return min( min(a, b),  c);\n    }\n\n    //  \n    // The idea is we generate the ugly number instead of checking every number.\n    //\n    // To generate the next ugly number, we can use the existed ugly numbers to multipy 2,3,5,\n    // and get the minimal one.\n    //\n    //     Let's start from the first ugly number - [1]\n    //\n    //        [1]  next = min( 1*2=2, 1*3=3, 1*5=5) = 2\n    //\n    //     Now we have [1,2], we can see, only the second one need be multipied by 2\n    //     but both 3 and 5 still need be multipied by first one. So:\n    // \n    //        [1,2]  next = min(2*2=4, 1*3=3, 1*5=5) = 3\n    //\n    //     Now we have [1,2,3], we can see the second one need be mulityped by 2 and 3,\n    //     but the 5 still needs be multipied by first one. So:\n    //\n    //        [1,2,3]  next = min (2*2, 2*3, 1*5) = 4\n    //\n    //     and so on...\n    //\n    // So, we can see we need to maintain three indics in ugly number list, \n    // each one represents the place need be mulipied by 2,3,5.\n    //\n    // And we increase the index who's multiplication is the minimal. \n    //\n    \n    int nthUglyNumber01(int n) {\n            \n        int i=0, j=0, k=0;\n        vector<int> v(1,1);\n        \n        while(v.size() < n){\n            int next = min(v[i]*2, v[j]*3, v[k]*5);\n            if (next == v[i]*2) i++;\n            if (next == v[j]*3) j++;\n            if (next == v[k]*5) k++;\n            v.push_back(next);\n        }\n        return v.back();\n    }\n    \n    // This version just uses the static variable to cache \n    // the 3 indics and the ugly number list\n    int nthUglyNumber02(int n) {\n            \n        static int i=0, j=0, k=0;\n        static vector<int> v(1,1);\n    \n        if (v.size()>=n) return v[n-1];\n        \n        while(v.size() < n){\n            int next = min(v[i]*2, v[j]*3, v[k]*5);\n            if (next == v[i]*2) i++;\n            if (next == v[j]*3) j++;\n            if (next == v[k]*5) k++;\n            v.push_back(next);\n        }\n        return v.back();\n    }\n    \n    int nthUglyNumber(int n) {\n        return nthUglyNumber02(n); // 4ms-8ms\n        return nthUglyNumber01(n); // 28ms\n    }\n};\n"
  },
  {
    "question_theme": "additiveNumber",
    "question": "/*************************************************************************************** \n *\n * Additive number is a positive integer whose digits can form additive sequence.\n * \n * A valid additive sequence should contain at least three numbers. Except for the \n * first two numbers, each subsequent number in the sequence must be the sum of the \n * preceding two.\n * \n * For example:\n * \"112358\" is an additive number because the digits can form an additive sequence: 1, \n * 1, 2, 3, 5, 8.\n * 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n * \"199100199\" is also an additive number, the additive sequence is: 1, 99, 100, 199.\n * 1 + 99 = 100, 99 + 100 = 199\n * \n * Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, \n * 03 or 1, 02, 3 is invalid.\n * \n * Given a string represents an integer, write a function to determine if it's an \n * additive number.\n * \n * Follow up:\n * How would you handle overflow for very large input integers?\n * \n * Credits:Special thanks to @jeantimex for adding this problem and creating all test \n * cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/additive-number/\n// Author : Hao Chen\n// Date   : 2015-11-22\n\n\n\n\nclass Solution {\npublic:\n    bool isAdditiveNumber(string num) {\n        int len = num.size();\n        \n        for(int i=1; i<len/2+1; i++) {\n            string n1 = num.substr(0, i);\n            if ( n1.size()>1 && n1[0] == '0') break;\n            for(int j=i+1; j<len; j++) {\n                string n2 = num.substr(i, j-i);\n                if ( n2.size()>1 && n2[0] == '0') break;\n                string n3 = num.substr(j);\n                if (isAdditiveNumberHelper(n1, n2, n3)) return true;\n            }\n        }\n        return false;\n    }\n    \nprivate:\n    bool isAdditiveNumberHelper(string& n1, string& n2, string& n3){\n        string add = StringAdd(n1, n2);\n        \n        if (add.size() > n3.size()) return false;\n        \n        if (add == n3 ) return true;\n        \n        //split the n3 to 2 parts, and keep going.\n        string cut = n3.substr(0, add.size());\n        if (add == cut) {\n            string rest = n3.substr(add.size());\n            return isAdditiveNumberHelper(n2, add, rest);\n        }\n        return false;\n    }\n\n\n    string StringAdd(string n1, string n2) {\n        \n        if (n1.size() < n2.size()) {\n            string tmp = n1;\n            n1 = n2;\n            n2 = tmp;\n        }\n        \n        int carry=0;\n        string result;\n        for (int i=n1.size()-1, j=n2.size()-1; i>=0; i--, j--) {\n\n            int n = n1[i] - '0' + carry;\n            if ( j >= 0) {\n                n += n2[j] - '0';\n            } \n            char ch = n % 10 + '0';\n            carry = n/10;\n            result = ch + result;\n        }\n        if (carry>0) result = (char)(carry+'0') + result;\n        return result;\n        \n    }\n};\n"
  },
  {
    "question_theme": "spiralMatrix",
    "question": "/********************************************************************************** \n* \n* Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.\n* \n* For example,\n* Given n = 3,\n* \n* You should return the following matrix:\n* \n* [\n*  [ 1, 2, 3 ],\n*  [ 8, 9, 4 ],\n*  [ 7, 6, 5 ]\n* ]\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/spiral-matrix-ii/\n// Author : Hao Chen\n// Date   : 2014-06-30\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<vector<int> > generateMatrix(int n, int m);\n\nvector<vector<int> > generateMatrix(int n) {\n    return generateMatrix(n, n);\n}\n\nvector<vector<int> > generateMatrix(int n, int m) {\n    vector< vector <int> > matrix(n);\n    if (n<=0) return matrix;\n    for(int i=0; i<n; i++){\n        vector<int> v(m);\n        matrix[i] = v;\n    }\n\n    int row=n, col=m;\n    int r, c;\n    int cnt=1;\n    for (r=0, c=0; r<(row+1)/2 && c<(col+1)/2; r++, c++){\n        //top\n        for(int i=c; i<col-c; i++){\n            matrix[r][i] = cnt++;\n        }\n        //right\n        for(int i=r+1; i<row-r; i++){\n            matrix[i][col-c-1] = cnt++;\n        }\n        //bottom\n        for(int i=col-c-2; row-r-1>r && i>=c; i--){\n            matrix[row-r-1][i] = cnt++;\n        }\n        //left\n        for(int i=row-r-2; col-c-1>c && i>r; i--){\n            matrix[i][c] = cnt++;\n        }\n        \n    }\n    return matrix;\n}\n\n\nvoid printArray(vector<int> v)\n{\n    cout << \"[\";\n    for(int j=0; j<v.size(); j++) {\n        printf(\" %02d\", v[j]);\n    }\n    cout << \"]\" << endl;;\n}\n\nvoid printMatrix(vector< vector<int> > &vv)\n{\n    for(int i=0; i<vv.size(); i++) {\n        printArray(vv[i]);\n    }\n    cout << endl;\n}\n\n\nint main(int argc, char** argv)\n{\n    int n=3, m=3;\n    if (argc>1){\n        m = n = atoi(argv[1]);\n    }\n    if (argc>2){\n        m = atoi(argv[2]);\n    }\n    vector< vector<int> > matrix = generateMatrix(n, m);\n    printMatrix(matrix);\n    return 0;\n}\n"
  },
  {
    "question_theme": "removeNthNodeFromEndOfList",
    "question": "/********************************************************************************** \n* \n* Given a linked list, remove the nth node from the end of list and return its head.\n* \n* For example,\n* \n*    Given linked list: 1->2->3->4->5, and n = 2.\n* \n*    After removing the second node from the end, the linked list becomes 1->2->3->5.\n* \n* Note:\n* Given n will always be valid.\n* Try to do this in one pass.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/\n// Author : Hao Chen\n// Date   : 2014-06-21\n\n\n\n\nclass Solution {\npublic:\n    ListNode *removeNthFromEnd(ListNode *head, int n) {\n        if (head==NULL || n<=0){\n            return NULL;\n        }\n        ListNode fakeHead(0);\n        fakeHead.next=head;\n        head=&fakeHead;\n        \n        ListNode *p1, *p2;\n        p1=p2=head;\n        for(int i=0; i<n; i++){\n            if (p2==NULL) return NULL;\n            p2=p2->next;\n        }\n        while (p2->next!=NULL){\n            p2=p2->next;\n            p1=p1->next;\n        }\n        \n        p1->next = p1->next->next;\n        return head->next;\n    }\n};\n"
  },
  {
    "question_theme": "romanToInteger",
    "question": "/********************************************************************************** \n* \n* Given a roman numeral, convert it to an integer.\n* \n* Input is guaranteed to be within the range from 1 to 3999.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/roman-to-integer/\n// Author : Hao Chen\n// Date   : 2014-07-17\n\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint romanCharToInt(char ch){\n    int d = 0;\n    switch(ch){\n        case 'I':  \n            d = 1;  \n            break;  \n        case 'V':  \n            d = 5;  \n            break;  \n        case 'X':  \n            d = 10;  \n            break;  \n        case 'L':  \n            d = 50;  \n            break;  \n        case 'C':  \n            d = 100;  \n            break;  \n        case 'D':  \n            d = 500;  \n            break;  \n        case 'M':  \n            d = 1000;  \n            break;  \n    }\n    return d;\n}\nint romanToInt(string s) {\n    if (s.size()<=0) return 0;\n    int result = romanCharToInt(s[0]);\n    for (int i=1; i<s.size(); i++){\n        int prev = romanCharToInt(s[i-1]);\n        int curr = romanCharToInt(s[i]);\n        //if left<right such as : IV(4), XL(40), IX(9) ...\n        if (prev < curr) {\n            result = result - prev + (curr-prev);\n        }else{\n            result += curr;\n        }\n    }\n    return result;\n}\n\nint main(int argc, char**argv)\n{\n    string s(\"XL\");\n    if (argc>1){\n        s = argv[1];\n    }\n    cout << s << \" : \" << romanToInt(s) << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "wildcardMatching",
    "question": "/********************************************************************************** \n* \n* Implement wildcard pattern matching with support for '?' and '*'.\n* \n* '?' Matches any single character.\n* '*' Matches any sequence of characters (including the empty sequence).\n* \n* The matching should cover the entire input string (not partial).\n* \n* The function prototype should be:\n* bool isMatch(const char *s, const char *p)\n* \n* Some examples:\n* isMatch(\"aa\",\"a\") \u2192 false\n* isMatch(\"aa\",\"aa\") \u2192 true\n* isMatch(\"aaa\",\"aa\") \u2192 false\n* isMatch(\"aa\", \"*\") \u2192 true\n* isMatch(\"aa\", \"a*\") \u2192 true\n* isMatch(\"ab\", \"?*\") \u2192 true\n* isMatch(\"aab\", \"c*a*b\") \u2192 false\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/wildcard-matching/\n// Author : Hao Chen\n// Date   : 2014-07-19\n\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\n\nbool isMatch(const char *s, const char *p) {\n\n    const char *last_s = NULL; \n    const char *last_p = NULL;\n    while( *s != '\\0' ){\n        if (*p=='*'){\n            //skip the \"*\", and mark a flag\n            p++;\n            //edge case\n            if (*p=='\\0') return true;\n            //use last_s and last_p to store where the \"*\" match starts.\n            last_s = s;\n            last_p = p;\n        }else if (*p=='?' || *s == *p){\n            s++; p++;\n        }else if (last_s != NULL){ // check \"last_s\" to know whether meet \"*\" before\n            // if meet \"*\" previously, and the *s != *p\n            // reset the p, using '*' to match this situation\n            p = last_p;\n            s = ++last_s; \n        }else{\n            // *p is not wildcard char, \n            // doesn't match *s, \n            // there are no '*' wildcard matched before\n            return false;\n        }\n    }\n    //edge case: \"s\" is done, but \"p\" still have chars.\n    while (*p == '*') p++;\n    return *p == '\\0';\n}\n\n\nint main(int argc, char** argv)\n{\n    const char *s = \"aab\";\n    const char *p = \"a*a*b\";\n    cout << s << \", \" << p << \" : \" << isMatch(s, p) << endl;\n\n    s = \"abbb\";\n    p = \"a*b\";\n    cout << s << \", \" << p << \" : \" << isMatch(s, p) << endl;\n\n    s = \"abb\";\n    p = \"a*bb\";\n    cout << s << \", \" << p << \" : \" << isMatch(s, p) << endl;\n\n    s = \"abddbbb\";\n    p = \"a*d*b\";\n    cout << s << \", \" << p << \" : \" << isMatch(s, p) << endl;\n\n    s = \"abdb\";\n    p = \"a**\";\n    cout << s << \", \" << p << \" : \" << isMatch(s, p) << endl;\n\n    s = \"a\";\n    p = \"a**\";\n    cout << s << \", \" << p << \" : \" << isMatch(s, p) << endl;\n\n    \n    s = \"*aa\"; // <-- it is not a pattern, it just a string where '*' is not a wildcard\n    p = \"*a\";\n    cout << s << \", \" << p << \" : \" << isMatch(s, p) << endl;\n\n    if (argc>2){\n        s = argv[1];\n        p = argv[2];\n        cout << s << \", \" << p << \" : \" << isMatch(s, p) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "question_theme": "sentenceScreenFitting",
    "question": "/* defined(__LeeteCodeOJ_418__OJ_418__) *",
    "answer": "//\n//  OJ#418.h\n//  LeeteCodeOJ#418\n//\n//  Created by Wang Yi on 25/10/16.\n//  Copyright (c) 2016 Wang Yi. All rights reserved.\n//\n\n#ifndef __LeeteCodeOJ_418__OJ_418__\n#define __LeeteCodeOJ_418__OJ_418__\n\n#define M 10\n\n#include <stdio.h>\n#include <string>\n#include <vector>\n\nusing std::vector;\nusing std::string;\n\nint SentenceScreenFitting(char stc[][M], int row, int col, size_t l);\n\nclass Solution {\npublic:\n    int wordsTyping(vector<string>& sentence, int rows, int cols);\n};\n\n#endif \n"
  },
  {
    "question_theme": "queueReconstructionByHeight",
    "question": "/*************************************************************************************** \n *\n * Suppose you have a random list of people standing in a queue. Each person is \n * described by a pair of integers (h, k), where h is the height of the person and k is \n * the number of people in front of this person who have a height greater than or equal \n * to h. Write an algorithm to reconstruct the queue.\n * \n * Note:\n * The number of people is less than 1,100.\n * \n * Example\n * \n * Input:\n * [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]\n * \n * Output:\n * [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/queue-reconstruction-by-height/\n// Author : Hao Chen\n// Date   : 2016-11-12\n\n\n\nclass Solution {\n\npublic:\n    vector<pair<int, int>> reconstructQueue(vector<pair<int, int>>& people) {\n        //sort function\n        auto comp = [](const pair<int, int>& p1, const pair<int, int>& p2)\n                    { return p1.first == p2.first ? p1.second < p2.second : p1.first > p2.first; };\n        //sort the people with their height with descending order\n        // and if the height is same then sort by K with ascending order\n        sort(people.begin(), people.end(), comp);\n        \n        // For example:\n        // Original Queue:  [7,0], [4,4], [7,1], [5,0], [6,1], [5,2]\n        //   Sorted Queue:  [7,0], [7,1], [6,1], [5,0], [5,2], [4,4] \n        \n        \n        // Why do we need to sort like this?\n        //\n        //     ** The position of shorter people is ZERO impacted with higher people. **\n        //    \n        // and, the shortest people has no impacts to all of people. we can simpley insert it to the Kth position\n        //\n        // So, we sorted the people from highest to the shortest, then when we insert the people to another array,\n        //\n        // we always can guarantee the people is going to be inserted has nothing to do with the people has been inserted.\n        //   \n        // Let's continue the about example above\n        //\n        //    [7,0] => []                                then [7,0]\n        //    [7,1] => [7,0]                             then [7,0], [7,1]\n        //    [6,1] => [7,0], [7,1]                      then [7,0], [6,1], [7,1]\n        //    [5,0] => [7,0], [6,1], [7,1]               then [5,0], [7,0], [6,1], [7,1]\n        //    [5,2] => [5,0], [7,0], [6,1], [7,1]        then [5,0], [7,0], [5,2], [6,1], [7,1]\n        //    [4,4] => [5,0], [7,0], [5,2], [6,1], [7,1] then [5,0], [7,0], [5,2], [6,1], [4,4], [7,1]\n        //\n        // We alway can see, the people is going to be inserted has NO IMPACT with the current people.\n        //     \n        //    [6,1] => [7,0], [7,1]  \n        // \n        //    Whatever the people[6,1] placed, it has nothing to do with the people [7,0] [7,1],\n        //    So, we can just insert the people to the place he like - the `Kth` place. \n        //\n        //\n        vector<pair<int, int>> res;\n        for (auto& p : people) {\n            res.insert(res.begin() + p.second, p);\n        }\n        return res;\n    }\n};\n"
  },
  {
    "question_theme": "compareVersionNumbers",
    "question": "/********************************************************************************** \n * \n * Compare two version numbers version1 and version1.\n * If version1 > version2 return 1, if version1 < version2 return -1, otherwise return 0.\n * \n * You may assume that the version strings are non-empty and contain only digits and the . character.\n * The . character does not represent a decimal point and is used to separate number sequences.\n * For instance, 2.5 is not \"two and a half\" or \"half way to version three\", it is the fifth second-level revision of the second first-level revision.\n * \n * Here is an example of version numbers ordering:\n * 0.1 < 1.1 < 1.2 < 13.37\n * \n * Credits:Special thanks to @ts for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/compare-version-numbers/\n// Author : Hao Chen\n// Date   : 2014-12-16\n\n\n\nclass Solution {\n    public:\n        vector<int> &split(const string &s, char delim, vector<int> &elems) {\n            stringstream ss(s);\n            string item;\n            while (getline(ss, item, delim)) {\n                elems.push_back(atoi(item.c_str()));\n            }\n            return elems;\n        }\n\n\n        vector<int> split(const string &s, char delim) {\n            vector<int> elems;\n            split(s, delim, elems);\n            return elems;\n        }\n\n        void rightTrimZero(vector<int> &v){\n            while (v.back() == 0){\n                v.pop_back();\n            }\n        }\n\n        int compareVersion(string version1, string version2) {\n\n            //split the version by delimer '.'\n            vector<int> ver1 = split(version1, '.');\n            vector<int> ver2 = split(version2, '.');\n\n            //remove the right Zeros\n            rightTrimZero(ver1);\n            rightTrimZero(ver2);\n\n            //compare two versions \n            for (int i=0; i<ver1.size() && i < ver2.size(); i++) {\n                if (ver1[i] < ver2[i]){\n                    return -1;\n                }else if(ver1[i] > ver2[i]){\n                    return 1;\n                }\n            }\n\n            //if the above for-loop is not returned, which means they are equal so far\n            //then check the length.\n            if (ver1.size() > ver2.size()) {\n                return 1;\n            }else if (ver1.size() < ver2.size()) {\n                return -1;\n            }\n\n            return 0;\n\n        }\n\n};\n"
  },
  {
    "question_theme": "wiggleSubsequence",
    "question": "/*************************************************************************************** \n *\n * A sequence of numbers is called a wiggle sequence if the differences between\n * successive numbers strictly alternate between positive and negative. The first\n * difference (if one exists) may be either positive or negative. A sequence with fewer\n * than two elements is trivially a wiggle sequence.\n * \n * For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3)\n * are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are\n * not wiggle sequences, the first because its first two differences are positive and\n * the second because its last difference is zero.\n * \n * Given a sequence of integers, return the length of the longest subsequence that is a\n * wiggle sequence. A subsequence is obtained by deleting some number of elements\n * (eventually, also zero) from the original sequence, leaving the remaining elements in\n * their original order.\n * \n * Examples:\n * Input: [1,7,4,9,2,5]\n * Output: 6\n * The entire sequence is a wiggle sequence.\n * \n * Input: [1,17,5,10,13,15,10,5,16,8]\n * Output: 7\n * There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].\n * \n * Input: [1,2,3,4,5,6,7,8,9]\n * Output: 2\n * \n * Follow up:\n * Can you do it in O(n) time?\n * \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/wiggle-subsequence/\n// Author : Calinescu Valentin\n// Date   : 2016-08-08\n\n\n \n \nclass Solution {\npublic:\n    int wiggleMaxLength(vector<int>& nums) {\n        int solution = 0;//if we have an empty vector the solution is 0\n        if(nums.size())\n        {\n            solution = 1;\n            int bigger = 0;//0 is the starting point to be followed by either an increasing or decreasing sequence\n            for(int i = 1; i < nums.size(); i++)\n            {\n                if(nums[i] == nums[i - 1])\n                    continue;//we can ignore duplicates as they can always be omitted\n                else if(nums[i] > nums[i - 1])\n                {\n                    if(bigger == 0 || bigger == 2)\n                    {\n                        bigger = 1;//1 means we now have an increasing sequence\n                        solution++;\n                    }\n                }\n                else //if(nums[i] < nums[i - 1])\n                {\n                    if(bigger == 0 || bigger == 1)\n                    {\n                        bigger = 2;//2 means we now have a decreasing sequence\n                        solution++;\n                    }\n                }\n            }\n        }\n        return solution;\n    }\n};\n"
  },
  {
    "question_theme": "rangeSumQuery2D-Immutable",
    "question": "/*************************************************************************************** \n *\n * Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined \n * by its upper left corner (row1, col1) and lower right corner (row2, col2).\n * \n * The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and \n * (row2, col2) = (4, 3), which contains sum = 8.\n * \n * Example:\n * \n * Given matrix = [\n *   [3, 0, 1, 4, 2],\n *   [5, 6, 3, 2, 1],\n *   [1, 2, 0, 1, 5],\n *   [4, 1, 0, 1, 7],\n *   [1, 0, 3, 0, 5]\n * ]\n * \n * sumRegion(2, 1, 4, 3) -> 8\n * sumRegion(1, 1, 2, 2) -> 11\n * sumRegion(1, 2, 2, 4) -> 12\n * \n * Note:\n * \n * You may assume that the matrix does not change.\n * There are many calls to sumRegion function.\n * You may assume that row1 \u2264 row2 and col1 \u2264 col2.\n * \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/range-sum-query-2d-immutable/\n// Author : Hao Chen\n// Date   : 2015-11-14\n\n\n\n\n\n\nclass NumMatrix {\nprivate:\n    int row, col;\n    vector<vector<int>> sums;\npublic:\n    NumMatrix(vector<vector<int>> &matrix) {\n        row = matrix.size();\n        col = row>0 ? matrix[0].size() : 0;\n        sums = vector<vector<int>>(row+1, vector<int>(col+1, 0));\n        for(int i=1; i<=row; i++) {\n            for(int j=1; j<=col; j++) {\n                sums[i][j] = sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] + matrix[i-1][j-1];\n            }\n        }\n    }\n\n    int sumRegion(int row1, int col1, int row2, int col2) {\n        return sums[row2+1][col2+1] - sums[row2+1][col1] - sums[row1][col2+1] + sums[row1][col1];\n    }\n};\n\n\n// Your NumMatrix object will be instantiated and called as such:\n// NumMatrix numMatrix(matrix);\n// numMatrix.sumRegion(0, 1, 2, 3);\n// numMatrix.sumRegion(1, 2, 3, 4);\n"
  },
  {
    "question_theme": "countPrimes",
    "question": "/********************************************************************************** \n * \n * Description:\n * Count the number of prime numbers less than a non-negative number, n.\n * \n * Credits:Special thanks to @mithmatt for adding this problem and creating all test cases.\n * \n *   Let's start with a isPrime function. To determine if a number is prime, we need to check if \n *   it is not divisible by any number less than n. The runtime complexity of isPrime function \n *   would be O(n) and hence counting the total prime numbers up to n would be O(n2). Could we do better?\n *   \n *   As we know the number must not be divisible by any number > n / 2, we can immediately cut the total \n *   iterations half by dividing only up to n / 2. Could we still do better?\n *   \n *   Let's write down all of 12's factors:\n * \n * \t2 \u00d7 6 = 12\n * \t3 \u00d7 4 = 12\n * \t4 \u00d7 3 = 12\n * \t6 \u00d7 2 = 12\n * \n * As you can see, calculations of 4 \u00d7 3 and 6 \u00d7 2 are not necessary. Therefore, we only need to consider \n * factors up to \u221an because, if n is divisible by some number p, then n = p \u00d7 q and since p \u2264 q, we could derive that p \u2264 \u221an.\n * \n * Our total runtime has now improved to O(n1.5), which is slightly better. Is there a faster approach?\n * \n *\tpublic int countPrimes(int n) {\n *\t   int count = 0;\n *\t   for (int i = 1; i < n; i++) {\n *\t      if (isPrime(i)) count++;\n *\t   }\n *\t   return count;\n *\t}\n *\t\n *\tprivate boolean isPrime(int num) {\n *\t   if (num <= 1) return false;\n *\t   // Loop's ending condition is i * i <= num instead of i <= sqrt(num)\n *\t   // to avoid repeatedly calling an expensive function sqrt().\n *\t   for (int i = 2; i * i <= num; i++) {\n *\t      if (num % i == 0) return false;\n *\t   }\n *\t   return true;\n *\t}\n *   \n *   The Sieve of Eratosthenes is one of the most efficient ways to find all prime numbers up to n. \n *   But don't let that name scare you, I promise that the concept is surprisingly simple.\n *\n *\t[Sieve of Eratosthenes](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\n * \n *\t[https://leetcode.com/static/images/solutions/Sieve_of_Eratosthenes_animation.gif]\n *\t[http://commons.wikimedia.org/wiki/File:Sieve_of_Eratosthenes_animation.gif]\n *\n *   Sieve of Eratosthenes: algorithm steps for primes below 121. \"Sieve of Eratosthenes Animation\"() \n *   by SKopp is licensed under CC BY 2.0.\n *\n *      * [Skoop](http://de.wikipedia.org/wiki/Benutzer:SKopp)\n *\t* [CC BY 2.0](http://creativecommons.org/licenses/by/2.0/)\n * \n * We start off with a table of n numbers. Let's look at the first number, 2. We know all multiples of 2 \n * must not be primes, so we mark them off as non-primes. Then we look at the next number, 3. Similarly, \n * all multiples of 3 such as 3 \u00d7 2 = 6, 3 \u00d7 3 = 9, ... must not be primes, so we mark them off as well. \n * Now we look at the next number, 4, which was already marked off. What does this tell you? Should you \n * mark off all multiples of 4 as well?\n *   \n * 4 is not a prime because it is divisible by 2, which means all multiples of 4 must also be divisible \n * by 2 and were already marked off. So we can skip 4 immediately and go to the next number, 5. Now, \n * all multiples of 5 such as 5 \u00d7 2 = 10, 5 \u00d7 3 = 15, 5 \u00d7 4 = 20, 5 \u00d7 5 = 25, ... can be marked off. \n * There is a slight optimization here, we do not need to start from 5 \u00d7 2 = 10. Where should we start marking off?\n *   \n * In fact, we can mark off multiples of 5 starting at 5 \u00d7 5 = 25, because 5 \u00d7 2 = 10 was already marked off \n * by multiple of 2, similarly 5 \u00d7 3 = 15 was already marked off by multiple of 3. Therefore, if the current \n * number is p, we can always mark off multiples of p starting at p2, then in increments of p: p2 + p, p2 + 2p, ... \n * Now what should be the terminating loop condition?\n *   \n * It is easy to say that the terminating loop condition is p n, which is certainly correct but not efficient. \n * Do you still remember Hint #3?\n *   \n * Yes, the terminating loop condition can be p n, as all non-primes \u2265 \u221an must have already been marked off. \n * When the loop terminates, all the numbers in the table that are non-marked are prime.\n * \n * The Sieve of Eratosthenes uses an extra O(n) memory and its runtime complexity is O(n log log n). \n * For the more mathematically inclined readers, you can read more about its algorithm complexity on \n * [Wikipedia](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_complexity).\n * \n *\tpublic int countPrimes(int n) {\n *\t   boolean[] isPrime = new boolean[n];\n *\t   for (int i = 2; i < n; i++) {\n *\t      isPrime[i] = true;\n *\t   }\n *\t   // Loop's ending condition is i * i < n instead of i < sqrt(n)\n *\t   // to avoid repeatedly calling an expensive function sqrt().\n *\t   for (int i = 2; i * i < n; i++) {\n *\t      if (!isPrime[i]) continue;\n *\t      for (int j = i * i; j < n; j += i) {\n *\t         isPrime[j] = false;\n *\t      }\n *\t   }\n *\t   int count = 0;\n *\t   for (int i = 2; i < n; i++) {\n *\t      if (isPrime[i]) count++;\n *\t   }\n *\t   return count;\n *\t}\n *   \n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/count-primes/\n// Author : Hao Chen\n// Date   : 2015-06-09\n\n\n\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint countPrimes(int n) {\n    vector<bool> isPrimer(n, true);\n\n    for(int i=2; i*i<n; i++){\n        if (isPrimer[i]){\n            for(int j=i*i; j<n; j+=i){\n                isPrimer[j] = false;\n            }\n        }\n    }\n\n    int cnt = 0;\n    for(int i=2; i<n; i++){\n        if (isPrimer[i]) { \n            //cout << i << \", \";\n            cnt++;\n        }\n    }\n    return cnt;\n}\n\n\nint main(int argc, char**argv) \n{\n    int n = 100;\n    if (argc>1){\n        n = atoi(argv[1]);\n    }\n  \n    cout << endl << n << \" : \" << countPrimes(n) << endl;\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "createMaximumNumber",
    "question": "/*************************************************************************************** \n *\n * Given two arrays of length m and n with digits 0-9 representing two numbers.\n *     Create the maximum number of length k  from digits of the two. The relative \n * order of the digits\n *     from the same array must be preserved. Return an array of the k digits. You \n * should try to optimize your time and space complexity.\n * \n *     Example 1:\n * \n *     nums1 = [3, 4, 6, 5]\n *     nums2 = [9, 1, 2, 5, 8, 3]\n *     k = 5\n *     return [9, 8, 6, 5, 3]\n * \n *     Example 2:\n * \n *     nums1 = [6, 7]\n *     nums2 = [6, 0, 4]\n *     k = 5\n *     return [6, 7, 6, 0, 4]\n * \n *     Example 3:\n * \n *     nums1 = [3, 9]\n *     nums2 = [8, 9]\n *     k = 3\n *     return [9, 8, 9]\n * \n * Credits:Special thanks to @dietpepsi for adding this problem and creating all test \n * cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/create-maximum-number/\n// Author : Hao Chen\n// Date   : 2016-01-21\n\n\n\n\n\n\n\n\nclass Solution {\npublic:\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\n        vector<int> result;\n        int len1 = nums1.size();\n        int len2 = nums2.size();\n        for (int i=0; i<=k; i++){\n            if (len1 < i || len2 < k-i) continue;\n            vector<int> sub1 = findMaxSubArray(nums1, i);\n            vector<int> sub2 = findMaxSubArray(nums2, k-i);\n            vector<int> merge = mergeTwoArrays(sub1, sub2);\n            if (compareTwoArray(merge, 0, result, 0)) {\n                result = merge;\n            }\n        }\n        return result;\n    }\n    \n    \n    bool compareTwoArray(vector<int>& nums1, int start1, vector<int>& nums2, int start2) {\n        int n1 = nums1.size();\n        int n2 = nums2.size();\n        for(; start1<n1 && start2<n2; start1++, start2++){\n            if (nums1[start1] > nums2[start2]) return true;\n            if (nums1[start1] < nums2[start2]) return false;\n        }\n        //if num1 still have numbers, return true, else return false\n        return start1 < nums1.size();\n    }\n    \n    vector<int> mergeTwoArrays(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> result;\n        int len1 = nums1.size();\n        int len2 = nums2.size();\n        int pos1=0, pos2=0;\n        while ( pos1 < len1 && pos2 < len2 ){\n            // Be careful if two numbers are equal. consider the following case\n            // case 1: [6,7], [6,0,4]  - we have same item - 6\n            // case 2: [4,0,2], [2,0,3,1] - we have same item - 0\n            // which one we need to merge?\n            // We need compare the rest of array.\n            if (nums1[pos1] == nums2[pos2]){\n                result.push_back( compareTwoArray(nums1, pos1+1, nums2, pos2+1) ? \n                                    nums1[pos1++] : nums2[pos2++]);\n            }else {\n                result.push_back(nums1[pos1] > nums2[pos2] ? \n                                    nums1[pos1++] : nums2[pos2++]);\n            }\n        }\n        \n        if (pos1 < len1){\n            result.insert(result.end(), nums1.begin()+pos1, nums1.end());\n        }\n        if (pos2 < len2) {\n            result.insert(result.end(), nums2.begin()+pos2, nums2.end());\n        }\n        \n        return result;\n    }\n    \n    \n    // using a stack method to find the max sub-array\n    // k <= nums.size()\n    vector<int> findMaxSubArray(vector<int>& nums, int k) {\n        int len = nums.size();\n        if ( k >= len ) return nums;\n        vector<int> result(k, 0);\n        int idx = 0; // the postion for result array\n        for (int i=0; i<len; i++){\n            // if we met a number > the last element of result[], \n            // and we still have enough numbers,\n            // then pop up the item\n            while (idx>0 && k - idx < len - i && result[idx-1] < nums[i]) {\n                idx--;\n            }\n            //push the number into the result[]\n            if (idx < k) {\n                result[idx++] = nums[i];\n            }\n        }\n        return result;\n    }\n    \n};\n"
  },
  {
    "question_theme": "wordPattern",
    "question": "/*************************************************************************************** \n *\n * Given a pattern and a string str, find if str follows the same pattern.\n *  Here follow means a full match, such that there is a bijection between a letter in \n * pattern and a non-empty word in str.\n * \n * Examples:\n * \n * pattern = \"abba\", str = \"dog cat cat dog\" should return true.\n * pattern = \"abba\", str = \"dog cat cat fish\" should return false.\n * pattern = \"aaaa\", str = \"dog cat cat dog\" should return false.\n * pattern = \"abba\", str = \"dog dog dog dog\" should return false.\n * \n * Notes:\n * You may assume pattern contains only lowercase letters, and str contains lowercase \n * letters separated by a single space.\n * \n * Credits:Special thanks to @minglotus6 for adding this problem and creating all test \n * cases.\n *               \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/word-pattern/\n// Author : Hao Chen\n// Date   : 2015-10-22\n\n\n\nclass Solution {\n\nprivate::\n\n    vector<string> split(string str, char delimiter) {\n        vector<string> internal;\n        stringstream ss(str); // Turn the string into a stream.\n        string tok;\n        \n        while(getline(ss, tok, delimiter)) {\n            internal.push_back(tok);\n        }\n        \n        return internal;\n    }\n\npublic:\n    \n    bool wordPattern(string pattern, string str) {\n        unordered_map<char, string> dict_pattern;\n        unordered_map<string, char> dict_string;\n        \n        int len = pattern.size();\n        vector<string> strs = split(str, ' ');\n        \n        if (len != strs.size()) return false;\n        \n        for(int i=0; i<len; i++) {\n            char& ch = pattern[i];\n            string& s = strs[i];\n            \n            if ( dict_pattern.find(ch) == dict_pattern.end() ) {\n                dict_pattern[ch] = s;\n            }\n            \n            if ( dict_string.find(s) == dict_string.end() ) {\n                dict_string[s] = ch;\n            }\n            \n            if ( dict_pattern[ch] != s || dict_string[s] != ch ) {\n                return false;\n            }\n            \n        }\n        return true;\n    }\n};\n\n"
  },
  {
    "question_theme": "longestValidParentheses",
    "question": "/********************************************************************************** \n* \n* Given a string containing just the characters '(' and ')', \n* find the length of the longest valid (well-formed) parentheses substring.\n* \n* For \"(()\", the longest valid parentheses substring is \"()\", which has length = 2.\n* \n* Another example is \")()())\", where the longest valid parentheses substring is \"()()\", \n* which has length = 4.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/longest-valid-parentheses/\n// Author : Hao Chen\n// Date   : 2014-07-18\n\n\n\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint longestValidParentheses(string s) {\n    int maxLen = 0;\n    int lastError = -1;\n    vector<int> stack;\n    for(int i=0; i<s.size(); i++){\n        if (s[i] == '('){\n            stack.push_back(i);\n        }else if (s[i] == ')') {\n            if (stack.size()>0 ){\n                stack.pop_back();\n                int len;\n                if (stack.size()==0){\n                    len = i - lastError;\n                } else {\n                    len = i - stack.back();\n                }\n                if (len > maxLen) {\n                    maxLen = len;\n                }\n            }else{\n                lastError = i;\n            }\n        }\n    }\n    return maxLen;\n}\n\n\nint main(int argc, char** argv)\n{\n    string s = \")()())\";\n    if (argc>1){\n        s = argv[1];\n    }\n    cout << s << \" : \" << longestValidParentheses(s) << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "linkedListRandomNode",
    "question": "/*************************************************************************************** \n *\n * Given a singly linked list, return a random node's value from the linked list. Each \n * node must have the same probability of being chosen.\n * \n * Follow up:\n * What if the linked list is extremely large and its length is unknown to you? Could \n * you solve this efficiently without using extra space?\n * \n * Example:\n * \n * // Init a singly linked list [1,2,3].\n * ListNode head = new ListNode(1);\n * head.next = new ListNode(2);\n * head.next.next = new ListNode(3);\n * Solution solution = new Solution(head);\n * \n * // getRandom() should return either 1, 2, or 3 randomly. Each element should have \n * equal probability of returning.\n * solution.getRandom();\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/linked-list-random-node/\n// Author : Hao Chen\n// Date   : 2016-08-24\n\n\n\n\nclass Solution {\npublic:\n    \n    Solution(ListNode* head) {\n        this->head = head;\n        this->len = 0;\n        for(ListNode*p = head; p!=NULL; p=p->next, len++);\n        srand(time(NULL));\n    }\n    \n    \n    int getRandom() {\n        int pos = rand() % len;\n        ListNode *p = head;\n        for (; pos > 0; pos--, p=p->next);\n        return p->val;\n    }\n    ListNode* head;\n    int len;\n};\n\n\n"
  },
  {
    "question_theme": "symmetricTree",
    "question": "/********************************************************************************** \n* \n* Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\n* \n* For example, this binary tree is symmetric:\n* \n*     1\n*    / \\\n*   2   2\n*  / \\ / \\\n* 3  4 4  3\n* \n* But the following is not:\n* \n*     1\n*    / \\\n*   2   2\n*    \\   \\\n*    3    3\n* \n* Note:\n* Bonus points if you could solve it both recursively and iteratively.\n* \n* confused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ.\n* \n* OJ's Binary Tree Serialization:\n* \n* The serialization of a binary tree follows a level order traversal, where '#' signifies \n* a path terminator where no node exists below.\n* \n* Here's an example:\n* \n*    1\n*   / \\\n*  2   3\n*     /\n*    4\n*     \\\n*      5\n* \n* The above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\". \n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/symmetric-tree/\n// Author : Hao Chen\n// Date   : 2014-06-28\n\n\n\n\nclass Solution {\npublic:\n    Solution(){\n        srand(time(NULL));\n    }\n\n    bool isSymmetric(TreeNode *root) {\n        if (root == NULL ) return true;\n        return isSymmetric(root->left, root->right);\n        \n    }\n    \n    bool isSymmetric(TreeNode *p, TreeNode *q){\n        if (random()%2){\n           return isSymmetric1(p, q);\n        }\n        return isSymmetric2(p, q);\n    }\n    \n    bool isSymmetric1(TreeNode *p, TreeNode *q){\n        if (p==NULL && q==NULL) return true;\n        if (p==NULL || q==NULL) return false;\n        \n        return (p->val == q->val) &&\n                isSymmetric(p->left, q->right) &&\n                isSymmetric(p->right, q->left);\n    }\n    \n    bool isSymmetric2(TreeNode *p, TreeNode *q){\n\n        queue<TreeNode*> q1;\n        queue<TreeNode*> q2;\n        q1.push(p);\n        q2.push(q);\n        while(q1.size()>0 && q2.size()>0){\n            TreeNode* p1 = q1.front();\n            q1.pop();\n            TreeNode* p2 = q2.front();\n            q2.pop();\n            if (p1==NULL && p2==NULL) continue;\n            if (p1==NULL || p2==NULL) return false;\n            \n            if (p1->val != p2->val) return false;\n            \n            q1.push(p1->left);\n            q2.push(p2->right);\n\n            q1.push(p1->right);\n            q2.push(p2->left);\n\n        }\n        return true;\n        \n    }\n    \n};\n"
  },
  {
    "question_theme": "binaryTreeZigzagLevelOrderTraversal",
    "question": "/********************************************************************************** \n* \n* Given a binary tree, return the zigzag level order traversal of its nodes' values. \n* (ie, from left to right, then right to left for the next level and alternate between).\n* \n* For example:\n* Given binary tree {3,9,20,#,#,15,7},\n* \n*     3\n*    / \\\n*   9  20\n*     /  \\\n*    15   7\n* \n* return its zigzag level order traversal as:\n* \n* [\n*   [3],\n*   [20,9],\n*   [15,7]\n* ]\n* \n* confused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ.\n* \n* OJ's Binary Tree Serialization:\n* \n* The serialization of a binary tree follows a level order traversal, \n* where '#' signifies a path terminator where no node exists below.\n* \n* Here's an example:\n* \n*    1\n*   / \\\n*  2   3\n*     /\n*    4\n*     \\\n*      5\n* \n* The above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\". \n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/\n// Author : Hao Chen\n// Date   : 2014-07-05\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvector<TreeNode*> TreeToArray_level_order(TreeNode* root);\n\nvector<vector<int> > zigzagLevelOrder(TreeNode *root) {\n    if (random()%2){\n        return zigzagLevelOrder1(root);\n    }\n    return zigzagLevelOrder2(root);\n}\n\nvector<vector<int> > zigzagLevelOrder1(TreeNode *root) {\n    vector<vector<int> > result;\n    vector<TreeNode*> tree = TreeToArray_level_order(root);\n\n    int curLevelCnt = 1;\n    int nextLevelCnt = 1;\n    int level=0;\n\n    for (int i=0; i<tree.size(); i+=curLevelCnt ){\n        int cnt=0;\n        level++;\n        vector<int> v;\n        if (level%2==0){\n            for(int j=i+nextLevelCnt-1; j>=i; j--){\n                if (tree[j]){\n                    cnt += 2;\n                    v.push_back(tree[j]->val);\n                }\n            }\n        }else{\n            for(int j=i; j<i+nextLevelCnt; j++){\n                if (tree[j]){\n                    cnt += 2;\n                    v.push_back(tree[j]->val);\n                }\n            }\n        }\n        curLevelCnt = nextLevelCnt;\n        nextLevelCnt = cnt;\n        if (v.size()>0){\n            result.push_back(v);\n        }\n    }\n    return result;\n}\n\nvector<TreeNode*> TreeToArray_level_order(TreeNode* root){\n    vector <TreeNode*> result;\n\n    queue<TreeNode*> q;\n    q.push(root);\n    while (q.size()>0) {\n        TreeNode* n = q.front();\n        q.pop();\n        result.push_back(n);\n        if (n==NULL){\n            //cout << \"# \";\n            continue;\n        }\n        //cout << n->val << \" \";\n        q.push(n->left);\n        q.push(n->right);\n    }\n    //cout << endl;\n    return result;\n}\n\nvector<vector<int> > zigzagLevelOrder2(TreeNode *root) {\n    vector<vector<int> > vv;\n    if(root == NULL) return vv;\n\n    int level = 0;\n    TreeNode *last = root;\n    queue<TreeNode*> q;\n\n    q.push(root);\n    vv.push_back(vector<int>());\n    while(!q.empty()) {\n        TreeNode *p = q.front();\n        q.pop();\n\n        vv[level].insert(level%2 ? vv[level].begin() : vv[level].end(), p->val);\n        if(p->left) q.push(p->left);\n        if(p->right) q.push(p->right);\n\n        if(p == last) {\n            level++;\n            last = q.back();\n            vv.push_back(vector<int>());\n        }\n    }\n    vv.pop_back();\n\n    return vv;\n}\n\nvoid printTree_level_order(TreeNode *root)\n{\n    queue<TreeNode*> q;\n    q.push(root);\n    while (q.size()>0){\n        TreeNode* n = q.front();\n        q.pop();\n        if (n==NULL){\n            cout << \"# \";\n            continue;\n        }\n        cout << n->val << \" \";\n        q.push(n->left);\n        q.push(n->right);\n    }\n    cout << endl;\n}\n\nTreeNode* createTree(int a[], int n)\n{\n    if (n<=0) return NULL;\n\n    TreeNode **tree = new TreeNode*[n];\n\n    for(int i=0; i<n; i++) {\n        if (a[i]==0 ){\n            tree[i] = NULL;\n            continue;\n        }\n        tree[i] = new TreeNode(a[i]);\n    }\n    int pos=1;\n    for(int i=0; i<n && pos<n; i++) {\n        if (tree[i]){\n            tree[i]->left = tree[pos++];\n            if (pos<n){\n                tree[i]->right = tree[pos++];\n            }\n        }\n    }\n    return tree[0];\n}\n\nint printMatrix(vector< vector<int> > &vv)\n{\n    for(int i=0; i<vv.size(); i++) {\n        cout << \"[\";\n        for(int j=0; j<vv[i].size(); j++) {\n            cout << \" \" << vv[i][j];\n        }\n        cout << \" ]\" << endl;;\n    }\n}\n\n\nint main(int argc, char** argv)\n{\n    TreeNode *p;\n    vector< vector<int> > vv;\n\n    int a[] = {3,9,20,0,0,15,7};\n    p = createTree(a, sizeof(a)/sizeof(int));\n    printTree_level_order(p);\n    vv = zigzagLevelOrder(p);\n    printMatrix(vv);\n    cout << endl;\n\n\n    return 0;\n}\n\n"
  },
  {
    "question_theme": "burstBalloons",
    "question": "/*************************************************************************************** \n *\n * Given n balloons, indexed from 0 to n-1. Each balloon is painted with a\n *     number on it represented by array nums.\n * \n *     You are asked to burst all the balloons. If the you burst\n *     balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left\n *     and right are adjacent indices of i. After the burst, the left and right\n *     then becomes adjacent.\n * \n *     Find the maximum coins you can collect by bursting the balloons wisely.\n * \n *     Note: \n *     (1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can \n * not burst them.\n *     (2) 0 \u2264 n \u2264 500, 0 \u2264 nums[i] \u2264 100\n * \n *     Example:\n * \n *     Given [3, 1, 5, 8]\n * \n *     Return 167\n * \n *     nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\n *    coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167\n * \n * Credits:Special thanks to @dietpepsi for adding this problem and creating all test \n * cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/burst-balloons/\n// Author : Hao Chen\n// Date   : 2016-01-17\n\n\n\n\n\nclass Solution {\npublic:\n    int maxCoins(vector<int>& nums) {\n        //remove all of zero item\n        nums.erase(remove_if(nums.begin(), nums.end(), [](int n){return n==0;}), nums.end());\n        \n        //add 1 for head and tail\n        nums.insert(nums.begin(),1);\n        nums.push_back(1);\n        \n        int n = nums.size();\n        vector< vector<int> > matrix(n, vector<int>(n,0));\n        \n        return maxCoins_DP(nums, matrix);\n        return maxCoins_DC(nums, matrix, 0, n-1);\n    }\n    \n    \n    //Divide and Conquer\n    //\n    //  If we seprate the array to two part, left part and right part.\n    //\n    //  Then, we will find in this problem the left and right become adjacent \n    //  and have effects on the maxCoins in the future.\n    //\n    //  So, if we think reversely, if the balloon i is the last balloon of all to burst, \n    //  the left and right section now has well defined boundary and do not affect each other! \n    //  Therefore we can do either recursive method with memoization\n    //\n    int maxCoins_DC(vector<int>& nums, vector<vector<int>>& matrix, int low, int high) {\n        if (low + 1 == high) return 0;\n        if (matrix[low][high] > 0) return matrix[low][high];\n        int result = 0;\n        for (int i = low + 1; i < high; ++i){\n            result = max(result,  nums[low] * nums[i] * nums[high] \n                                    + maxCoins_DC(nums, matrix, low, i) \n                                    + maxCoins_DC(nums, matrix, i, high));\n        }\n        matrix[low][high] = result;\n        return result;\n    }\n    \n    //Dynamic Programming\n    // \n    //  using the same idea of above \n    //\n    int maxCoins_DP(vector<int>& nums, vector<vector<int>>& dp) {\n        int n = nums.size();\n        for (int k = 2; k < n; ++k) {\n            for (int low = 0; low < n - k; low++){\n                int high = low + k;\n                for (int i = low + 1; i < high; ++i)\n                    dp[low][high] = max( dp[low][high],\n                         nums[low] * nums[i] * nums[high] + dp[low][i] + dp[i][high]);\n            }\n        }\n        return dp[0][n - 1];\n    }\n    \nprivate:\n    void printVector(vector<int>& nums) {\n        cout << \"nums: \";\n        for (auto n: nums) {\n            cout << n << ' ';\n        }\n        cout << '\\n';\n    }\n};\n"
  },
  {
    "question_theme": "plusOne",
    "question": "/********************************************************************************** \n* \n* Given a non-negative number represented as an array of digits, plus one to the number.\n* \n* The digits are stored such that the most significant digit is at the head of the list.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/plus-one/\n// Author : Hao Chen\n// Date   : 2014-06-21\n\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> plusOne(vector<int> &digits) {\n    int carry=1;\n    vector <int> v;\n    while(digits.size()>0){\n        int x = digits.back();\n        digits.pop_back();\n        x = x + carry;\n        v.insert(v.begin(), x%10);\n        carry = x/10;\n    }\n    if (carry>0){\n        v.insert(v.begin(), carry);\n    }\n    return v;\n\n}\n\nvoid printVector(vector<int>& v)\n{\n    cout << \"{ \";\n    for(int i=0; i<v.size(); i++){\n        cout << v[i] << \" \";\n    }\n    cout << \"} \" << endl;\n}\n\n\nint main()\n{\n    int a[]={9,9,9};\n    vector<int> d(&a[0], &a[0]+sizeof(a)/sizeof(int));\n    vector<int> v = plusOne(d);\n    printVector(v);\n    return 0;\n}\n"
  },
  {
    "question_theme": "anagrams",
    "question": "/********************************************************************************** \n * \n * Given two strings s and t, write a function to determine if t is an anagram of s. \n * \n * For example,\n * s = \"anagram\", t = \"nagaram\", return true.\n * s = \"rat\", t = \"car\", return false.\n * \n * Note:\n * You may assume the string contains only lowercase alphabets.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/valid-anagram/\n// Author : Hao Chen\n// Date   : 2015-08-16\n\n\n\n\nclass Solution {\npublic:\n\n    //stupid way - but easy to understand  - 76ms\n    bool isAnagram01(string s, string t) {\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        return s == t;\n    }\n    \n    //using a map to count every chars in the string.\n    bool isAnagram02(string s, string t) {\n        int map[26] ={0} ; //only lowercase alphabets\n        //memset(map, 0, sizeof(map));\n        \n        // count each char for s\n        for (int i=0; i<s.size(); i++) {\n            map[s[i]-'a']++;\n        }\n        // decrease the count for t\n        for (int i=0; i<t.size(); i++) {\n            map[t[i]-'a']--;\n        }\n        \n        //if all alphabets is zero, then they are anagram \n        for (int i=0; i<sizeof(map)/sizeof(map[0]); i++) {\n            if (map[i]!=0) return false;\n        }\n        return true;\n    }\n    \n\n    \n    bool isAnagram(string s, string t) {\n        return isAnagram02(s,t); //12ms\n        return isAnagram01(s,t); //76ms\n    }\n    \n};\n\n\n\n"
  },
  {
    "question_theme": "maximumSubArray",
    "question": "/********************************************************************************** \n* \n* Find the contiguous subarray within an array (containing at least one number) \n* which has the largest sum.\n* \n* For example, given the array [\u22122,1,\u22123,4,\u22121,2,1,\u22125,4],\n* the contiguous subarray [4,\u22121,2,1] has the largest sum = 6.\n* \n* More practice:\n* \n* If you have figured out the O(n) solution, try coding another solution using \n* the divide and conquer approach, which is more subtle.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/maximum-subarray/\n// Author : Hao Chen\n// Date   : 2014-06-20\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define INT_MIN     (-2147483647 - 1)\n\nint maxSubArray1(int A[], int n);\nint maxSubArray2(int A[], int n); \n\nint max(int x, int y){\n    return x>y?x:y;\n}\n\nint maxSubArray(int A[], int n) {\n    if (random()%2){\n        return maxSubArray1(A, n);\n    }\n    return maxSubArray2(A, n);\n}\n\nint maxSubArray1(int A[], int n) {\n    int *sum = new int[n];\n    sum[0] = A[0];\n    int m = A[0]; \n    for (int i=1; i<n; i++){\n        sum[i] = max(A[i], A[i] + sum[i-1]);\n        m = max(m, sum[i]);\n    }\n    delete[] sum;\n    return m;\n}\n\nint maxSubArray2(int A[], int n) {\n    int m=INT_MIN;\n    int sum=0;\n    for (int i=0; i<n; i++){\n        sum += A[i];\n        m = max(sum, m);\n        if (sum<0){\n            sum = 0;\n        }\n    }\n    return m;\n}\n\nint main()\n{\n    srand(time(NULL));\n    int a[]= {-2,1,-3,4,-1,2,1,-5,4};\n    printf(\"%d\\n\", maxSubArray(a, sizeof(a)/sizeof(int)));\n    printf(\"%d\\n\", maxSubArray(a, sizeof(a)/sizeof(int)));\n    return 0;\n}\n"
  },
  {
    "question_theme": "subsets",
    "question": "/********************************************************************************** \n* \n* Given a set of distinct integers, S, return all possible subsets.\n* \n* Note:\n* \n* Elements in a subset must be in non-descending order.\n* The solution set must not contain duplicate subsets.\n* \n* For example,\n* If S = [1,2,3], a solution is:\n* \n* [\n*   [3],\n*   [1],\n*   [2],\n*   [1,2,3],\n*   [1,3],\n*   [2,3],\n*   [1,2],\n*   []\n* ]\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/subsets/\n// Author : Hao Chen\n// Date   : 2014-07-03\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid getCombination(vector<int>& v, int n, int k, vector<int>& solution, vector< vector<int> >& result );\nvector<vector<int> > combine(vector<int>& v, int k); \nvector<vector<int> > combine1(vector<int>& v, int k); \nvector<vector<int> > combine2(vector<int>& v, int k);\n\nvector<vector<int> > subsets(vector<int> &S) {\n    vector<vector<int> > result;\n    for(int i=0; i<=S.size(); i++){\n        vector<vector<int> > r = combine(S, i); \n        result.insert(result.end(), r.begin(), r.end()); \n    } \n    return result;\n}\n\n\nvector<vector<int> > combine(vector<int>& v, int k) {\n    if (random()%2){\n        cout << \"recusive method!\" << endl;\n        return combine1(v, k);\n    }\n    cout << \"non-recusive method!\" << endl;\n    return combine2(v, k);\n}\n\nvector<vector<int> > combine1(vector<int> &v, int k) {\n    vector<vector<int> > result;\n    vector<int> solution;\n    getCombination(v, v.size(), k, solution, result);\n    return result;\n}\n\nvoid getCombination(vector<int> &v, int n, int k, vector<int>& solution, vector< vector<int> >& result ){\n    if (k==0){\n        //sort to meet LeetCode requirement\n        vector<int> v = solution;\n        sort(v.begin(), v.end());\n        result.push_back(v);\n        return;\n    }\n    for(int i=n; i>0; i--){\n        solution.push_back(v[i-1]);\n        getCombination(v, i-1, k-1, solution, result);\n        solution.pop_back();\n    }\n}\n\nvector<vector<int> > combine2(vector<int> &v, int k) {\n    \n    vector<vector<int> > result;\n    vector<int> d;\n    int n = v.size();\n    for (int i=0; i<n; i++){\n        d.push_back( (i<k) ? 1 : 0 );\n    }\n\n    //1) from the left, find the [1,0] pattern, change it to [0,1]\n    //2) move all of the 1 before the pattern to the most left side\n    //3) check all of 1 move to the right\n    while(1){\n        vector<int> tmp;\n        for(int x=0; x<n; x++){\n            if (d[x]) tmp.push_back(v[x]);\n        }\n        sort(tmp.begin(), tmp.end());\n        result.push_back(tmp);\n        //step 1), find [1,0] pattern\n        int i;\n        bool found = false;\n        int ones =0;\n        for(i=0; i<n-1; i++){\n            \n            if (d[i]==1 && d[i+1]==0){\n                d[i]=0; d[i+1]=1;\n                found = true;\n                //step 2) move all of right 1 to the most left side\n                for (int j=0; j<i; j++){\n                    d[j]=( ones > 0 ) ? 1 : 0;\n                    ones--;\n                }\n                break; \n            } \n            if (d[i]==1) ones++;\n        }\n        if (!found){\n            break;\n        }\n        \n    }\n    return result;\n    \n}\n\n\n\n\nvoid printResult(vector<vector<int> >& result)\n{\n    for(int i=0; i<result.size(); i++){\n        cout << \"{\";\n        for(int j=0; j<result[i].size(); j++){\n            cout << \" \" << result[i][j];\n        }\n        cout << \" }\" <<endl;\n    }\n}\n\nvoid printArray(vector<int>& v){\n    cout << \"{\";\n    for(int i=0; i<v.size(); i++) {\n        cout << \" \" << v[i];\n    }\n    cout << \" }\" << endl;\n}\n\nint main(int argc, char** argv)\n{\n    srand(time(NULL));\n\n    int n = 3;\n    if (argc>1){\n        n = atoi(argv[1]);\n    }\n    vector<int> v;\n    for(int i=n; i>0; i--){\n        v.push_back(i);\n    }\n    printArray(v);\n    vector<vector<int> > r = subsets(v);\n    printResult(r);\n}\n"
  },
  {
    "question_theme": "intersectionOfTwoLinkedLists",
    "question": "/********************************************************************************** \n * \n * Write a program to find the node at which the intersection of two singly linked lists begins.\n * \n * For example, the following two linked lists: \n * \n *\n *    A:          a1 \u2192 a2\n *                       \u2198\n *                         c1 \u2192 c2 \u2192 c3\n *                       \u2197            \n *    B:     b1 \u2192 b2 \u2192 b3\n * \n * begin to intersect at node c1.\n * \n * Notes:\n * \n * If the two linked lists have no intersection at all, return null.\n * The linked lists must retain their original structure after the function returns. \n * You may assume there are no cycles anywhere in the entire linked structure.\n * Your code should preferably run in O(n) time and use only O(1) memory.\n *               \n **********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/intersection-of-two-linked-lists/\n// Author : Hao Chen\n// Date   : 2014-12-01\n\n\n\n\nclass Solution {\n    public:\n        ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n\n            //caculate the length of each List\n            int lenA = getListLength(headA);\n            int lenB = getListLength(headB);\n\n            if (lenA<=0 || lenB<=0 ) return NULL;\n\n            //let List A is the longest List;\n            if (lenA < lenB){\n                swap(headA, headB);\n            }\n\n            //move head of List A, make both of Lists are same length \n            for (int i=0; i<abs(lenA-lenB); i++){\n                headA = headA->next;\n            }\n\n            //synced travel both of Lists and check their nodes are same or not \n            while (headA != headB){\n                headA = headA->next;\n                headB = headB->next;\n            }\n\n            return headA;\n        }\n    private:    \n        inline int getListLength(ListNode *head){\n            int len=0;\n            while(head!=NULL){\n                head = head->next;\n                len++;\n            }\n            return len;\n        }\n};\n"
  },
  {
    "question_theme": "constructBinaryTreeFromInorderAndPostorderTraversal",
    "question": "/********************************************************************************** \n* \n* Given inorder and postorder traversal of a tree, construct the binary tree.\n* \n* Note:\n* You may assume that duplicates do not exist in the tree.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\n// Author : Hao Chen\n// Date   : 2014-07-10\n\n\n\n#include <stdio.h>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode *buildTree(vector<int> &inorder, int in_offset, vector<int> &postorder, int post_offset, int n );\n\nTreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\n    return buildTree(inorder, 0, postorder, 0, postorder.size());\n}\n\n// n - how many number,  offset - start from where?\nTreeNode *buildTree(vector<int> &inorder, int in_offset, vector<int> &postorder, int post_offset, int n ) {\n\n    if ( n<=0 || postorder.size()<=0 || inorder.size()<=0 ) return NULL;\n\n    TreeNode *root = new TreeNode(postorder[post_offset+n-1]);\n    if ( n==1 ){\n        return root;\n    }\n\n    //searching in inorder -- can be optimized by using <map>\n    int i;\n    for(i=in_offset; i<in_offset+n; i++){\n        if (inorder[i] == postorder[post_offset+n-1]){\n            break;\n        }\n    }\n\n    //error: not found\n    if (i == inorder.size()) return NULL;\n\n    int left_n = i - in_offset;\n    int right_n = in_offset + n - i - 1;\n    root->left = buildTree(inorder, in_offset, postorder, post_offset, left_n );\n    root->right = buildTree(inorder, i+1, postorder, post_offset+left_n, right_n);\n\n    return root;\n}\n\n//cause the problem: memory limited error\nTreeNode *buildTree2(vector<int> &inorder, vector<int> &postorder) {\n    \n    if (postorder.size()<=0 || inorder.size()<=0 ) return NULL;\n\n    int post_n = postorder.size();\n    TreeNode *root = new TreeNode(postorder[post_n-1]);\n    if ( inorder.size()==1 && postorder.size()==1 ){\n        return root;\n    }\n\n    //searching in inorder -- can be optimized by using <map>\n    int i;\n    for(i=0; i<inorder.size(); i++){\n        if (inorder[i] == postorder[post_n-1]){\n            break;\n        }\n    }\n\n    //error: not found\n    if (i == inorder.size()) return NULL;\n\n    \n    vector<int>   in(inorder.begin(), inorder.begin()+i);\n    vector<int> post(postorder.begin(), postorder.begin()+i);\n    if (in.size()>0) {\n        root->left = buildTree(in, post);\n    }\n\n    in.clear();\n    in.assign(inorder.begin()+i+1, inorder.end());\n    post.clear();\n    post.assign(postorder.begin()+i, postorder.end()-1);\n    if (in.size()>0) {\n        root->right = buildTree(in, post);\n    }\n\n    return root;\n}\n\nvoid printTree_pre_order(TreeNode *root)\n{\n    if (root == NULL){\n        printf(\"# \");\n        return;\n    }\n    printf(\"%c \", root->val );\n\n    printTree_pre_order(root->left);\n    printTree_pre_order(root->right);\n}\n\nvoid printTree_in_order(TreeNode *root)\n{\n    if (root == NULL){\n        printf(\"# \");\n        return;\n    }\n\n    printTree_in_order(root->left);\n    printf(\"%c \", root->val );\n    printTree_in_order(root->right);\n}\n\n\nvoid printTree_level_order(TreeNode *root)\n{\n    queue<TreeNode*> q;\n    q.push(root);\n    while (q.size()>0){\n        TreeNode* n = q.front();\n        q.pop();\n        if (n==NULL){\n            printf(\"# \");\n            continue;\n        }\n        printf(\"%c \", n->val);\n        q.push(n->left);\n        q.push(n->right);\n    }\n    printf(\"\\n\");\n}\n\n\nint main()\n{\n    int   in_order[]={'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'};\n    int post_order[]={'A', 'C', 'E', 'D', 'B', 'H', 'I', 'G', 'F'};\n    vector<int>   inorder(  in_order,  in_order + 9 );\n    vector<int> postorder( post_order, post_order + 9 );\n\n    TreeNode* tree = buildTree(inorder, postorder);\n\n    printTree_level_order(tree);\n    printTree_pre_order(tree);\n    printf(\"\\n\");\n    printTree_in_order(tree);\n    printf(\"\\n\");\n    \n    return 0;\n}\n"
  },
  {
    "question_theme": "coinChange",
    "question": "/*************************************************************************************** \n *\n * You are given coins of different denominations and a total amount of money amount. \n * Write a function to compute the fewest number of coins that you need to make up that\n * amount. If that amount of money cannot be made up by any combination of the coins,\n * return -1.\n * \n * Example 1:\n * coins = [1, 2, 5], amount = 11\n * return 3 (11 = 5 + 5 + 1)\n * \n * Example 2:\n * coins = [2], amount = 3\n * return -1.\n * \n * Note:\n * You may assume that you have an infinite number of each kind of coin.\n * \n * Credits:\n * Special thanks to @jianchao.li.fighter for adding this problem and creating all test \n * cases.\n * \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/coin-change/\n// Author : Calinescu Valentin, Hao Chen\n// Date   : 2015-12-28\n\n\n \nclass Solution {\npublic:\n    \n    int coinChange(vector<int>& coins, int amount) {\n        int sol[amount + 1];\n        sol[0] = 0;\n        for(int i = 1; i <= amount; i++)\n            sol[i] = amount + 1;\n        for(int i = 0; i < coins.size(); i++)\n        {\n            for(int j = coins[i]; j <= amount; j++)\n                sol[j] = min(sol[j], sol[j - coins[i]] + 1);\n        }\n        if(sol[amount] != amount + 1)\n            return sol[amount];\n        else\n            return -1;\n    }\n};\n\n\n//Another DP implmentation, same idea above \nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        const int MAX = amount +1;\n        vector<int> dp(amount+1, MAX);\n        dp[0]=0;\n        \n        for(int i=1; i<=amount; i++) {\n            for (int j=0; j<coins.size(); j++){\n                if (i >= coins[j]) {\n                    dp[i] = min( dp[i], dp[i-coins[j]] + 1 );\n                }\n            }\n        }\n\n        return dp[amount]==MAX ? -1 : dp[amount];\n    }\n};\n"
  },
  {
    "question_theme": "firstUniqueCharacterInAString",
    "question": "/*************************************************************************************** \n *\n * Given a string, find the first non-repeating character in it and return it's index. \n * If it doesn't exist, return -1.\n * \n * Examples:\n * \n * s = \"leetcode\"\n * return 0.\n * \n * s = \"loveleetcode\",\n * return 2.\n * \n * Note: You may assume the string contain only lowercase letters.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/first-unique-character-in-a-string/\n// Author : Hao Chen\n// Date   : 2016-08-23\n\n\n\nclass Solution {\npublic:\n    int firstUniqChar(string s) {\n        //As the question mentioned, there only have lower case chars, \n        //so the MAX_CHAR can be defined as 26, but I want this algorithm be more general for all ASCII\n        #define MAX_CHAR 256\n        #define NOT_FOUND  -1\n        #define DUPLICATION -2\n        \n        // initlize all chars status to NOT_FOUND\n        int pos_map[MAX_CHAR];\n        memset(pos_map, NOT_FOUND,sizeof(pos_map));\n        \n        // if it is the first time to find, set the status to its postion\n        // if it is the second time to find, set the status to duplication\n        // if it has already duplicated, do nothing \n        for (int i=0; i<s.size(); i++){\n            if ( pos_map[s[i]] >= 0 ) {\n                pos_map[s[i]] = DUPLICATION;\n            }else if ( pos_map[s[i]] == NOT_FOUND ) {\n                pos_map[s[i]] = i;\n            }\n        }\n        \n        // find the lowest postion\n        int pos = INT_MAX;\n        for (auto item : pos_map) {\n            cout << item << \",\";\n            if (item >= 0 && item < pos) {\n                pos = item;\n            }\n        }\n        return pos == INT_MAX ? -1 : pos;\n    }\n};\n"
  },
  {
    "question_theme": "minimumDepthOfBinaryTree",
    "question": "/********************************************************************************** \n* \n* Given a binary tree, find its minimum depth.\n* \n* The minimum depth is the number of nodes along the shortest path from the root node \n* down to the nearest leaf node.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/minimum-depth-of-binary-tree/\n// Author : Hao Chen\n// Date   : 2014-06-22\n\n\n\n\nclass Solution {\npublic:\n    int minDepth(TreeNode *root) {\n        if (root==NULL){\n            return 0;\n        }\n        if (root->left==NULL && root->right==NULL){\n            return 1;\n        }\n        int left=INT_MAX;\n        if (root->left){\n            left = minDepth(root->left) + 1 ;\n        }\n        int right=INT_MAX;\n        if (root->right){\n            right = minDepth(root->right) + 1;\n        }\n        \n        return left<right ? left : right;\n        \n    }\n};\n"
  },
  {
    "question_theme": "palindromePartitioning",
    "question": "/********************************************************************************** \n* \n* Given a string s, partition s such that every substring of the partition is a palindrome.\n* \n* Return the minimum cuts needed for a palindrome partitioning of s.\n* \n* For example, given s = \"aab\",\n* Return 1 since the palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/palindrome-partitioning-ii/\n// Author : Hao Chen\n// Date   : 2014-08-24\n\n\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nbool isPalindrome(string &s, int start, int end);\nvoid minCutHelper(string &s, int start, int steps, int& min );\nint minCutHelper(string &s, int steps, int& minSteps );\nint minCut_DP(string& s); \n\nint minCut(string s) {\n    #define INT_MAX 2147483647\n    if(s.size()<=1) return 0;\n\n    int min = INT_MAX;\n    \n    //minCutHelper(s, 0, 0, min);\n    //return min-1;\n\n    //int m =  minCutHelper(s, 0, min);\n    //return m-1;\n\n    return minCut_DP(s);\n}\n\n\n\n\nint minCut_DP(string& s) {\n    //res[] is for minimal cut DP\n    vector<int>res(s.size(),0);\n    //mp[][] is for palindrome checking DP\n    bool mp[s.size()][s.size()];\n\n    //construct the pailndrome checking matrix\n    //  1) matrix[i][j] = true;     if (i==j)                   -- only one char\n    //  2) matrix[i][j] = true;     if (i==j+1) && s[i]==s[j]   -- only two chars\n    //  3) matrix[i][j] = matrix[i+1][j-1];   if s[i]==s[j]     -- more than two chars\n    //\n    //note:  1) and 2) can be combined together\n    for (int i=s.size()-1;i>=0;i--){\n        for (int j=i;j<s.size();j++){\n            if ((s[i]==s[j]) && (j-i<2 || mp[i+1][j-1])){\n                mp[i][j]=true;\n            }else{\n                mp[i][j]=false;\n            }\n        }\n    }\n    //minimal cut dp\n    for (int i=0;i<s.size();i++){\n        //if s[0..i] is palindrome, then no need to cut\n        if (mp[0][i] == true){\n            res[i]=0;\n        }else{\n            // if s[0..i] isn't palindrome \n            // then, for each 0 to i, find a \"j\" which meets two conditions:\n            //    a) s[j+1..i] are palindrome.\n            //    b) res[j]+1 is minimal   \n            int ms = s.size();\n            for (int j=0; j<i; j++){\n                if (mp[j+1][i] && ms>res[j]+1 ) {\n                    ms=res[j]+1;\n                } \n            }\n            res[i]=ms;\n        }\n    }\n    return res[s.size()-1];\n}\n\n//More Optimized DFS -  Time Limit Exceeded\nint minCutHelper(string &s, int steps, int& minSteps ) {\n\n    // remove the steps if it's greater than minSteps \n    if (minSteps <= steps) {\n        return -2;\n    }\n    // adding the cache to remove the duplicated calculation\n    static map<string, int> cache;\n    if ( cache.find(s)!=cache.end() ){\n        if (s.size()>0)\n            cout << s << \":\" << cache[s] << endl;\n        return cache[s];\n    }\n    if (s.size()==0) {\n        if (minSteps > steps){\n            minSteps = steps;\n        }\n        cache[s] = 0;\n        return 0;\n    }\n\n\n    int min = INT_MAX;\n    string subs;\n    int m; \n    for( int i=s.size()-1; i>=0; i-- ) {\n        //remove the steps which greater than minSteps\n        if ( i < s.size()-1 && minSteps - steps <= 1) {\n            break;\n        }\n        if ( isPalindrome(s, 0, i) ){\n            //if ( i == s.size()-1 ) {\n            //    m = 1;\n            //}else{\n            subs = s.substr(i+1, s.size()-i-1);\n            m = minCutHelper(subs, steps+1, minSteps) + 1;\n            //}\n            if (m < 0) continue;\n            cache[subs] = m-1;\n            if (min > m ){\n                min = m;\n            }\n        }\n    }\n    return min;\n}\n\n\n//Optimized DFS -  Time Limit Exceeded\nvoid minCutHelper(string &s, int start, int steps, int& min ) {\n\n    if (start == s.size()) {\n        if (steps < min) {\n            min = steps;\n            return;\n        }\n    }\n\n    //GREED: find the biggest palindrome first\n    for(int i=s.size()-1; i>=start; i--){\n        //cut unnecessary DFS \n        if ( min > steps && isPalindrome(s, start, i)) {\n            minCutHelper(s, i+1, steps+1, min );\n        }\n    }\n}\n\n//traditional palindrome checking function.\nbool isPalindrome(string &s, int start, int end)  {  \n\n    while(start < end)  {  \n        if(s[start] != s[end]) { \n\n            return false;  \n        }\n        start++; end--;  \n    }  \n\n    return true;  \n}  \n\n//ababababababababababababcbabababababababababababa\n//fifgbeajcacehiicccfecbfhhgfiiecdcjjffbghdidbhbdbfbfjccgbbdcjheccfbhafehieabbdfeigbiaggchaeghaijfbjhi\n//aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\nint main(int argc, char** argv)\n{\n    string s(\"aab\");\n    if ( argc > 1 ){\n        s = argv[1];\n    }\n\n    cout << s << \" : \" << minCut(s) << endl;\n\n}\n"
  },
  {
    "question_theme": "reverseNodesInKGroup",
    "question": "/********************************************************************************** \n* \n* Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.\n* \n* If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n* \n* You may not alter the values in the nodes, only nodes itself may be changed.\n* \n* Only constant memory is allowed.\n* \n* For example,\n* Given this linked list: 1->2->3->4->5\n* \n* For k = 2, you should return: 2->1->4->3->5\n* \n* For k = 3, you should return: 3->2->1->4->5\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/reverse-nodes-in-k-group/\n// Author : Hao Chen\n// Date   : 2014-07-05\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode *reverseList(ListNode *&head, int k);\n\nListNode *reverseKGroup(ListNode *head, int k) {\n\n    if (k<=0) return head;\n    ListNode fake(0);\n    fake.next = head;\n    ListNode* p = &fake;\n\n    while(p){\n        p->next = reverseList(p->next, k);\n        for(int i=0; p && i<k; i++){\n            p = p->next;\n        }\n    }\n\n    return fake.next;\n}\n\nListNode *reverseList(ListNode *&head, int k){\n    ListNode* pEnd=head;\n    while (pEnd && k>0){\n        pEnd = pEnd->next;\n        k--;\n    }\n    if (k>0) return head;\n\n    ListNode *pHead=pEnd, *p=head;\n    while(p != pEnd){\n        ListNode *q = p->next;\n        p->next = pHead;\n        pHead = p;\n        p = q;\n    }\n    return pHead;\n}\n\nvoid printList(ListNode* h)\n{\n    while(h!=NULL){\n        printf(\"%d \", h->val);\n        h = h->next;\n    }\n    printf(\"\\n\");\n}\n\nListNode* createList(int a[], int n)\n{\n    ListNode *head=NULL, *p=NULL;\n    for(int i=0; i<n; i++){\n        if (head == NULL){\n            head = p = new ListNode(a[i]);\n        }else{\n            p->next = new ListNode(a[i]);\n            p = p->next;\n        }\n    }\n    return head;\n}\n\n\nint main(int argc, char** argv)\n{\n    int a[] = {1,2,3,4,5,6,7,8,9,10};\n    ListNode* pList = createList(a, sizeof(a)/sizeof(int));\n\n    int k =2;\n    if (argc>1){\n        k = atoi(argv[1]);\n    }\n\n    pList = reverseKGroup(pList, k);\n    printList(pList);\n    \n    return 0;\n}\n"
  },
  {
    "question_theme": "randomPickIndex",
    "question": "/*************************************************************************************** \n *\n * Given an array of integers with possible duplicates, randomly output the index of a \n * given target number. You can assume that the given target number must exist in the \n * array.\n * \n * Note:\n * The array size can be very large. Solution that uses too much extra space will not \n * pass the judge.\n * \n * Example:\n * \n * int[] nums = new int[] {1,2,3,3,3};\n * Solution solution = new Solution(nums);\n * \n * // pick(3) should return either index 2, 3, or 4 randomly. Each index should have \n * equal probability of returning.\n * solution.pick(3);\n * \n * // pick(1) should return 0. Since in the array only nums[0] is equal to 1.\n * solution.pick(1);\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/random-pick-index/\n// Author : Hao Chen\n// Date   : 2016-11-04\n\n\n\nclass Solution {\nprivate:\n    vector<int> nums;    \npublic:\n    Solution(vector<int> nums) {\n        srand(time(0));\n        this->nums = nums;\n    }\n    \n    int pick(int target) {\n\t// we just randomly pick a number from the array,\n        // if the number is target just return the index.\n        // otherwise, keep picking the number randomly.\n        while(true) {\n            int idx = rand() % nums.size();\n            if ( target == nums[idx] ) {\n                return idx;\n            }\n        }\n    }\n};\n\n\n"
  },
  {
    "question_theme": "nQueens",
    "question": "/********************************************************************************** \n* \n* Follow up for N-Queens problem.\n* \n* Now, instead outputting board configurations, return the total number of distinct solutions.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/n-queens-ii/\n// Author : Hao Chen\n// Date   : 2014-08-22\n\n\n\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint totalNQueens(int n); \nvoid solveNQueensRecursive(int n, int currentRow, vector<int>& solution, int& result); \nbool isValid(int attemptedColumn, int attemptedRow, vector<int> &queenInColumn); \n\n\nint totalNQueens(int n) {\n    int result=0;\n    vector<int> solution(n);\n\n    solveNQueensRecursive(n, 0, solution, result);\n\n    return result;    \n}\n\n// the solution is same as the \"N Queens\" problem.\nvoid solveNQueensRecursive(int n, int currentRow, vector<int>& solution, int& result) {\n\n    for (int i = 0; i < n; i++) {\n        if (isValid(i, currentRow, solution) ) {\n            if (currentRow+1 == n){\n                result++;\n                continue;\n            }\n            solution[currentRow] = i;\n            solveNQueensRecursive(n, currentRow+1, solution, result);\n        }\n    } \n}\n\n\nbool isValid(int attemptedColumn, int attemptedRow, vector<int> &queenInColumn) {\n\n    for(int i=0; i<attemptedRow; i++) {\n        if (attemptedColumn == queenInColumn[i]  || \n            abs(attemptedColumn - queenInColumn[i]) == abs(attemptedRow - i)) {\n            return false;\n        } \n    }\n    return true;\n}\n\n\n\nint main(int argc, char** argv)\n{\n    int n = 8;\n    if (argc>1){\n        n = atoi(argv[1]);\n    }\n    \n    int result = totalNQueens(n);\n    \n    cout << n << \" Queens, total = \" << result << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "question_theme": "validParentheses",
    "question": "/********************************************************************************** \n* \n* Given a string containing just the characters '(', ')', '{', '}', '[' and ']', \n* determine if the input string is valid.\n* \n* The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid \n* but \"(]\" and \"([)]\" are not.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/valid-parentheses/\n// Author : Hao Chen\n// Date   : 2014-06-30\n\n\n\n#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nbool isValid(string s) {\n    stack<char> st;\n    for(auto ch : s) {\n        if (ch=='{' || ch =='[' || ch=='(' ) {\n            st.push(ch);\n        }else if (ch=='}' || ch ==']' || ch == ')' ){\n            if (st.empty()) return false;\n            char sch = st.top();\n            if ( (sch=='{' && ch =='}') || (sch=='[' && ch==']') || (sch=='(' && ch==')' ) ){\n                st.pop();\n            }else {\n                return false;\n            }\n        }else{\n            return false;\n        }\n    }\n    return st.empty();\n}\n\nint main(int argc, char**argv)\n{\n    string s = \"{{}{[]()}}\";\n    if (argc>1){\n        s = argv[1];\n    }\n    cout << \"str = \\\"\" << (s) << \"\\\"\" << endl;\n    cout << isValid(s) << endl;\n}\n"
  },
  {
    "question_theme": "largestNumber",
    "question": "/********************************************************************************** \n * \n * Given a list of non negative integers, arrange them such that they form the largest number.\n * \n * For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.\n * \n * Note: The result may be very large, so you need to return a string instead of an integer.\n * \n * Credits:Special thanks to @ts for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/largest-number/\n// Author : Hao Chen\n// Date   : 2015-01-16\n\n\n\nclass Solution {\n    public:\n\n        //compare function\n        static bool comp (string& s1, string& s2) { return s1+s2 > s2+s1; }\n\n        string largestNumber(vector<int> &num) {\n\n            //convert int to string\n            vector<string> v;\n            for (int i=0; i<num.size(); i++) {\n                v.push_back(to_string(num[i]));\n            }\n\n            //sort the string\n            sort(v.begin(), v.end(), comp);\n\n            //generate the result\n            string result;\n            for(int i=0; i<v.size(); i++ ){\n                result+=v[i];\n            }\n\n            //special case: start with zero (e.g. [0, 0])\n            if (result[0]=='0') return \"0\";\n\n            return result;\n        }\n};\n"
  },
  {
    "question_theme": "palindromeLinkedList",
    "question": "/********************************************************************************** \n * \n * Given a singly linked list, determine if it is a palindrome.\n * \n * Follow up:\n * Could you do it in O(n) time and O(1) space?\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/palindrome-linked-list/\n// Author : Hao Chen\n// Date   : 2015-07-17\n\n\n\n\nclass Solution {\npublic:\n    ListNode* findMiddle(ListNode* head) {\n        ListNode *p1=head, *p2=head;\n        while(p2 && p2->next){\n            p1 = p1->next;\n            p2 = p2->next->next;\n        }\n        return p1;\n    }\n    \n    ListNode* reverseLink(ListNode* head) {\n        ListNode* p=NULL;\n        \n        while (head) {\n            ListNode* q = head->next;\n            head->next = p;\n            p = head;\n            head = q;\n        }\n        return p;\n    }\n    \n    bool isPalindrome(ListNode* head) {\n        ListNode* pMid = findMiddle(head);\n        ListNode* pRev = reverseLink(pMid); \n        for(;head!=pMid; head=head->next, pRev=pRev->next) {\n            if (head->val != pRev->val) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n"
  },
  {
    "question_theme": "readNCharactersGivenRead4",
    "question": "/********************************************************************************** \n * \n * The API: int read4(char *buf) reads 4 characters at a time from a file.\n * \n * The return value is the actual number of characters read. \n * For example, it returns 3 if there is only 3 characters left in the file.\n * \n * By using the read4 API, implement the function int read(char *buf, int n) \n * that reads n characters from the file.\n * \n * Note:\n *   The read function will only be called once for each test case.\n * \n **********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/read-n-characters-given-read4/\n// Author : Hao Chen\n// Date   : 2014-11-20\n\n\n\n\n// Forward declaration of the read4 API.\nint read4(char *buf);\n\nclass Solution {\n    public:\n        \n        int read(char *buf, int n) {\n            srand(time(0));\n            if (rand()%2){\n                return read1(buf, n);\n            }\n            return read2(buf, n);\n        }\n\n        //read the data in-place. potential out-of-boundary issue\n        int read1(char *buf, int n) {\n            int len = 0;\n            int size = 0;\n\n            // `buf` could be accessed out-of-boundary \n            while(len <=n && (size = read4(buf))>0){\n                size = len + size > n ?  n - len : size;\n                len += size;\n                buf += size;\n            }\n            return  len;\n        }\n\n        //using a temp-buffer to avoid peotential out-of-boundary issue\n        int read2(char *buf, int n) {\n            char _buf[4];   // the buffer for read4()\n            int _n = 0;     // the return for read4()\n            int len = 0;    // total buffer read from read4()\n            int size = 0;   // how many bytes need be copied from `_buf` to `buf`\n            while((_n = read4(_buf)) > 0){\n                //check the space of `buf` whether full or not\n                size = len + _n > n ? n-len : _n;\n                strncpy(buf+len, _buf, size);\n                len += size;\n                //buffer is full\n                if (len>=n){\n                    break;\n                }\n            }\n            return len;\n        }\n};\n"
  },
  {
    "question_theme": "reverseVowelsOfAString",
    "question": "/*************************************************************************************** \n *\n * Write a function that takes a string as input and reverse only the vowels of a \n * string.\n * \n * Example 1:\n * Given s = \"hello\", return \"holle\".\n * \n * Example 2:\n * Given s = \"leetcode\", return \"leotcede\".\n * \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/reverse-vowels-of-a-string/\n// Author : Calinescu Valentin, Hao Chen\n// Date   : 2016-04-30\n\n\n\n//Author: Calinescu Valentin\nclass Solution {\npublic:\n    string reverseVowels(string s) {\n        list <char> vowels;\n        set <char> vows;\n        vows.insert('a');\n        vows.insert('A');\n        vows.insert('e');\n        vows.insert('E');\n        vows.insert('i');\n        vows.insert('I');\n        vows.insert('o');\n        vows.insert('O');\n        vows.insert('u');\n        vows.insert('U');\n        string result;\n        for(int i = 0; i < s.size(); i++)\n        {\n            if(vows.find(s[i]) != vows.end())\n                vowels.push_back(s[i]);\n        }\n        for(int i = 0; i < s.size(); i++)\n        {\n            if(vows.find(s[i]) != vows.end())\n            {\n                result.push_back(vowels.back());\n                vowels.pop_back();\n            }\n            else\n                result.push_back(s[i]);\n        }\n        return result;\n    }\n};\n\n\n// Author: Hao Chen\n// 1) preset a dictionary table to look up vowels\n// 2) we have two pointer, the `left` one search vowels from the beginning to then end, the `right` one search from the end to the beginning.\n// 3) swap the left one and the right one until left >= right.\nclass Solution {\nprivate:\n   bool vowelsTable[256];\npublic:\n    Solution(){\n        memset(vowelsTable, 0, sizeof(vowelsTable));\n        vowelsTable['a']=true;\n        vowelsTable['e']=true;\n        vowelsTable['i']=true;\n        vowelsTable['o']=true;\n        vowelsTable['u']=true;\n        \n        vowelsTable['A']=true;\n        vowelsTable['E']=true;\n        vowelsTable['I']=true;\n        vowelsTable['O']=true;\n        vowelsTable['U']=true;\n    }\n    bool isVowels(char ch) {\n        return vowelsTable[ch];\n    }\n    string reverseVowels(string s) {\n        int left=0, right=s.size()-1;\n        while ( left < right ) {\n            while( !isVowels( s[left]) ) left++;\n            while( !isVowels( s[right] ) ) right--;\n            if (left >= right) break;\n            swap(s[left], s[right]);\n            left++; right--;\n        }\n        return s;\n    }\n};\n"
  },
  {
    "question_theme": "sumOfTwoIntegers",
    "question": "/*************************************************************************************** \n *\n * Calculate the sum of two integers a and b, but you are not allowed to use the \n * operator + and -.\n * \n * Example:\n * Given a = 1 and b = 2, return 3.\n * \n * \n * Credits:Special thanks to @fujiaozhu for adding this problem and creating all test \n * cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/sum-of-two-integers/description/\n// Author : Hao Chen\n// Date   : 2018-06-25\n\n\n\nclass Solution {\npublic:\n    int getSum(int x, int y) {\n        // Iterate till there is no carry  \n        while (y != 0) {\n            // carry now contains common \n            //set bits of x and y\n            int carry = x & y;  \n\n            // Sum of bits of x and y where at \n            //least one of the bits is not set\n            x = x ^ y; \n\n            // Carry is shifted by one so that adding\n            // it to x gives the required sum\n            y = carry << 1;\n        }\n        return x;\n    }\n};\n\n"
  },
  {
    "question_theme": "candy",
    "question": "/********************************************************************************** \n* \n* There are N children standing in a line. Each child is assigned a rating value. \n* \n* You are giving candies to these children subjected to the following requirements:\n* \n* Each child must have at least one candy.\n* Children with a higher rating get more candies than their neighbors.\n* \n* What is the minimum candies you must give?\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/candy/\n// Author : Hao Chen\n// Date   : 2014-10-12\n\n\n\n#include <stdlib.h>\n#include <time.h>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nvoid print(vector<int> &v);\n\n\nint candy(vector<int> &ratings) {\n\n    vector<int> candyCnt(ratings.size()) ;\n    //allocate candies, considering the minimal rating on the left\n    candyCnt[0] = 1;\n    for(int i = 1; i < ratings.size(); i++){\n        candyCnt[i] = ratings[i] > ratings[i-1] ? candyCnt[i-1]+1 : 1;\n    }\n    print(candyCnt); \n    //modify the allocation, considering the minimal rating on the right\n    int totalCandy = candyCnt[ratings.size()-1];\n    for(int i = ratings.size()-2; i >= 0; i--){\n        candyCnt[i] = (ratings[i] > ratings[i+1] && candyCnt[i+1]+1 > candyCnt[i]) ? candyCnt[i+1]+1 : candyCnt[i];\n        //count total candies by the way\n        totalCandy += candyCnt[i];\n    }\n    print(candyCnt);\n    return totalCandy;\n}\n\nvoid generateRatings(vector<int> &ratings, int n) {\n    srand(time(0));\n    for (int i=0; i<n; i++) {\n        ratings.push_back(rand()%10);\n    }\n}\n\nvoid print(vector<int> &v) {\n    for(int i=0; i<v.size(); i++){\n        cout << v[i] << \" \";\n    }\n    cout << endl;\n}\n\nint main(int argc, char**argv)\n{\n    int n = 10;\n    if (argc>1){\n        n = atoi(argv[1]);\n    }   \n    vector<int> ratings;\n    generateRatings(ratings, n);\n    print(ratings);\n\n    cout << candy(ratings) << endl;\n\n    cout << \"--------------------\" << endl;\n    int r[] = { 5, 6, 7, 4, 1, 2, 3, 2, 1, 7 };\n    vector<int> ra(r, r+sizeof(r)/sizeof(r[0]));\n    print(ra);\n    cout << candy(ra) << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "intersectionOfTwoArrays",
    "question": "/*************************************************************************************** \n *\n * Given two arrays, write a function to compute their intersection.\n * \n * Example:\n * Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].\n * \n * Note:\n * Each element in the result should appear as many times as it shows in both arrays.\n * The result can be in any order.\n * \n * Follow up:\n * What if the given array is already sorted? How would you optimize your algorithm?\n * What if nums1's size is small compared to num2's size? Which algorithm is better?\n * What if elements of nums2 are stored on disk, and the memory is limited such that you\n * cannot load all elements into the memory at once?\n * \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/intersection-of-two-arrays-ii/\n// Author : Calinescu Valentin, Hao Chen\n// Date   : 2016-05-22\n\n\n \n \n  \nclass Solution { // O(NlogN + MlogM)\npublic:\n    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n        sort(nums1.begin(), nums1.end());//we sort both vectors in order to intersect\n        sort(nums2.begin(), nums2.end());//them later in O(N + M), where N = nums1.size()\n        vector <int> solution;                                         //M = nums2.size() \n        int index = 0;\n        bool finished = false;\n        for(int i = 0; i < nums1.size() && !finished; i++)\n        {\n            while(index < nums2.size() && nums1[i] > nums2[index])//we skip over the\n                index++;//smaller elements in nums2\n            if(index == nums2.size())//we have reached the end of nums2 so we have no more\n                finished = true;//elements to add to the intersection\n            else if(nums1[i] == nums2[index])//we found a common element\n            {\n                solution.push_back(nums1[i]);\n                index++;\n            }\n        }\n        return solution;\n    }\n};\n\n\n\n\n\n\nclass Solution {\npublic:\n    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n        unordered_map<int, int> m;\n        for (auto n: nums1) {\n            m[n]++;\n        }\n        vector<int> result;\n        for (auto n:nums2){\n            if (m.find(n) != m.end() && m[n]>0 ){\n                result.push_back(n);\n                m[n]--;\n            }                    \n        }\n        return result;\n    }\n};\n"
  },
  {
    "question_theme": "permutations",
    "question": "/********************************************************************************** \n* \n* Given a collection of numbers, return all possible permutations.\n* \n* For example,\n* [1,2,3] have the following permutations:\n* [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/permutations/\n// Author : Hao Chen\n// Date   : 2014-06-21\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\n\n\nvector<vector<int> > permute(vector<int> &num) {\n    \n    vector<vector<int> > vv;\n    vv.push_back(num);\n\n    if (num.size() <2){\n        return vv;\n    }\n        \n    int pos=0;\n    while(pos<num.size()-1){\n        int size = vv.size();\n        for(int i=0; i<size; i++){\n            //take each number to the first place\n            for (int j=pos+1; j<vv[i].size(); j++) {\n                vector<int> v = vv[i];\n                int t = v[j]; \n                v[j] = v[pos];\n                v[pos] = t;\n                vv.push_back(v);\n            }\n        }\n        pos++;\n    }\n    return vv;\n}\n\nint main(int argc, char** argv)\n{\n    int n = 3;\n    if (argc>1){\n       n = atoi(argv[1]); \n    }\n\n    vector<int> v;\n    for (int i=0; i<n; i++) {\n        v.push_back(i+1);\n    }\n    vector<vector<int> > vv;\n    vv = permute(v);\n    \n    for(int i=0; i<vv.size(); i++) {\n        cout << \"{ \";\n        for(int j=0; j<vv[i].size(); j++){\n            cout << vv[i][j] << \" \";\n        }\n        cout << \"}\" <<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "removeLinkedListElements",
    "question": "/********************************************************************************** \n * \n * Remove all elements from a linked list of integers that have value val.\n * \n * Example\n * Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6,  val = 6\n * Return: 1 --> 2 --> 3 --> 4 --> 5\n * \n * Credits:Special thanks to @mithmatt for adding this problem and creating all test cases.\n *               \n **********************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/remove-linked-list-elements/\n// Author : Hao Chen\n// Date   : 2015-06-09\n\n\n\n\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        static ListNode dummy(-1);\n        dummy.next = head;\n        ListNode *p = &dummy;\n        \n        while( p->next) {\n            if (p->next->val == val) {\n                p->next = p->next->next;\n            }else{\n                p = p->next;\n            }\n        }\n        \n        return dummy.next;\n    }\n};\n\n\n"
  },
  {
    "question_theme": "medianOfTwoSortedArrays",
    "question": "/********************************************************************************** \n* \n* There are two sorted arrays A and B of size m and n respectively. \n* Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/median-of-two-sorted-arrays/\n// Author : Hao Chen\n// Date   : 2014-07-22\n\n\n\n#include <stdio.h>\n\n// Classical binary search algorithm, but slightly different\n// if cannot find the key, return the position where can insert the key \nint binarySearch(int A[], int low, int high, int key){\n    while(low<=high){\n        int mid = low + (high - low)/2;\n        if (key == A[mid]) return mid;\n        if (key > A[mid]){\n            low = mid + 1;\n        }else {\n            high = mid -1;\n        }\n    }\n    return low;\n}\n\n//Notes:\n// I feel the following methods is quite complicated, it should have a better high clear and readable solution\ndouble findMedianSortedArrayHelper(int A[], int m, int B[], int n, int lowA, int highA, int lowB, int highB) {\n\n    // Take the A[middle], search its position in B array\n    int mid = lowA + (highA - lowA)/2;\n    int pos = binarySearch(B, lowB, highB, A[mid]);\n    int num = mid + pos;\n    // If the A[middle] in B is B's middle place, then we can have the result\n    if (num == (m+n)/2){\n        // If two arrays total length is odd, just simply return the A[mid]\n        // Why not return the B[pos] instead ? \n        //   suppose A={ 1,3,5 } B={ 2,4 }, then mid=1, pos=1\n        //   suppose A={ 3,5 }   B={1,2,4}, then mid=0, pos=2\n        //   suppose A={ 1,3,4,5 }   B={2}, then mid=1, pos=1\n        // You can see, the `pos` is the place A[mid] can be inserted, so return A[mid]\n        if ((m+n)%2==1){\n            return A[mid];\n        }\n        \n        // If tow arrys total length is even, then we have to find the next one.\n        int next;\n\n        // If both `mid` and `pos` are not the first postion.\n        // Then, find max(A[mid-1], B[pos-1]). \n        // Because the `mid` is the second middle number, we need to find the first middle number\n        // Be careful about the edge case\n        if (mid>0 && pos>0){ \n            next = A[mid-1]>B[pos-1] ? A[mid-1] : B[pos-1];\n        }else if(pos>0){\n            next = B[pos-1];\n        }else if(mid>0){\n            next = A[mid-1];\n        }\n        \n        return (A[mid] + next)/2.0;\n    }\n    // if A[mid] is in the left middle place of the whole two arrays\n    //\n    //         A(len=16)        B(len=10)\n    //     [................] [...........]\n    //            ^             ^\n    //           mid=7         pos=1\n    //\n    //  move the `low` pointer to the \"middle\" position, do next iteration.\n    if (num < (m+n)/2){\n        lowA = mid + 1;\n        lowB = pos; \n        if ( highA - lowA > highB - lowB ) {\n            return findMedianSortedArrayHelper(A, m, B, n, lowA, highA, lowB, highB);\n        }\n        return findMedianSortedArrayHelper(B, n, A, m, lowB, highB, lowA, highA);\n    }\n    // if A[mid] is in the right middle place of the whole two arrays\n    if (num > (m+n)/2) {\n        highA = mid - 1;\n        highB = pos-1;\n        if ( highA - lowA > highB - lowB ) {\n            return findMedianSortedArrayHelper(A, m, B, n, lowA, highA, lowB, highB);\n        }\n        return findMedianSortedArrayHelper(B, n, A, m, lowB, highB, lowA, highA);\n    }\n\n}\n\ndouble findMedianSortedArrays(int A[], int m, int B[], int n) {\n\n    //checking the edge cases\n    if ( m==0 && n==0 ) return 0.0;\n\n    //if the length of array is odd, return the middle one\n    //if the length of array is even, return the average of the middle two numbers\n    if ( m==0 ) return n%2==1 ? B[n/2] : (B[n/2-1] + B[n/2])/2.0;\n    if ( n==0 ) return m%2==1 ? A[m/2] : (A[m/2-1] + A[m/2])/2.0;\n    \n    \n    //let the longer array be A, and the shoter array be B\n    if ( m > n ){\n        return findMedianSortedArrayHelper(A, m, B, n, 0, m-1, 0, n-1);\n    }\n        \n    return findMedianSortedArrayHelper(B, n, A, m, 0, n-1, 0, m-1);\n}\n\n\nint main()\n{\n    int r1[] = {1};\n    int r2[] = {2};\n \n    int n1 = sizeof(r1)/sizeof(r1[0]);\n    int n2 = sizeof(r2)/sizeof(r2[0]);\n\n    printf(\"Median is 1.5 = %f\\n\", findMedianSortedArrays(r1, n1, r2, n2));\n\n    int ar1[] = {1, 12, 15, 26, 38};\n    int ar2[] = {2, 13, 17, 30, 45, 50};\n \n    n1 = sizeof(ar1)/sizeof(ar1[0]);\n    n2 = sizeof(ar2)/sizeof(ar2[0]);\n\n    printf(\"Median is 17 = %f\\n\", findMedianSortedArrays(ar1, n1, ar2, n2));\n\n    int ar11[] = {1, 12, 15, 26, 38};\n    int ar21[] = {2, 13, 17, 30, 45 };\n \n    n1 = sizeof(ar11)/sizeof(ar11[0]);\n    n2 = sizeof(ar21)/sizeof(ar21[0]);\n\n    printf(\"Median is 16 = %f\\n\", findMedianSortedArrays(ar11, n1, ar21, n2));\n\n    int a1[] = {1, 2, 5, 6, 8 };\n    int a2[] = {13, 17, 30, 45, 50};\n \n    n1 = sizeof(a1)/sizeof(a1[0]);\n    n2 = sizeof(a2)/sizeof(a2[0]);\n\n    printf(\"Median is 10.5 = %f\\n\", findMedianSortedArrays(a1, n1, a2, n2));\n\n    int a10[] = {1, 2, 5, 6, 8, 9, 10 };\n    int a20[] = {13, 17, 30, 45, 50};\n \n    n1 = sizeof(a10)/sizeof(a10[0]);\n    n2 = sizeof(a20)/sizeof(a20[0]);\n\n    printf(\"Median is 9.5 = %f\\n\", findMedianSortedArrays(a10, n1, a20, n2));\n\n    int a11[] = {1, 2, 5, 6, 8, 9 };\n    int a21[] = {13, 17, 30, 45, 50};\n \n    n1 = sizeof(a11)/sizeof(a11[0]);\n    n2 = sizeof(a21)/sizeof(a21[0]);\n\n    printf(\"Median is 9 = %f\\n\", findMedianSortedArrays(a11, n1, a21, n2));\n\n    int a12[] = {1, 2, 5, 6, 8 };\n    int a22[] = {11, 13, 17, 30, 45, 50};\n \n    n1 = sizeof(a12)/sizeof(a12[0]);\n    n2 = sizeof(a22)/sizeof(a22[0]);\n\n    printf(\"Median is 11 = %f\\n\", findMedianSortedArrays(a12, n1, a22, n2));\n\n    int b1[] = {1 };\n    int b2[] = {2,3,4};\n \n    n1 = sizeof(b1)/sizeof(b1[0]);\n    n2 = sizeof(b2)/sizeof(b2[0]);\n\n    printf(\"Median is 2.5 = %f\\n\", findMedianSortedArrays(b1, n1, b2, n2));\n    return 0;\n}\n"
  },
  {
    "question_theme": "countingBits",
    "question": "/*************************************************************************************** \n *\n * Given a non negative integer number num. For every numbers i in the range 0 \u2264 i \u2264 \n * num calculate the number of 1's in their binary representation and return them as an \n * array.\n * \n * Example:\n * For num = 5 you should return [0,1,1,2,1,2].\n * \n * Follow up:\n * \n * It is very easy to come up with a solution with run time O(n*sizeof(integer)). But \n * can you do it in linear time O(n) /possibly in a single pass?\n * Space complexity should be O(n).\n * Can you do it like a boss? Do it without using any builtin function like \n * __builtin_popcount  in c++ or in any other language.\n * \n *   You should make use of what you have produced already.\n *   Divide the numbers in ranges like [2-3], [4-7], [8-15] and so on. And try to \n * generate new range from previous.\n *   Or does the odd/even status of the number help you in calculating the number of 1s?\n * \n * Credits:Special thanks to @ syedee  for adding this problem and creating all test \n * cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/counting-bits/\n// Author : Hao Chen\n// Date   : 2016-05-30\n\n\n\nclass Solution {\npublic:\n    \n    vector<int> countBits(int num) {\n        vector<int> bits_cnt(num+1, 0); \n        \n        for (int i=1; i<=num; i++) {\n            bits_cnt[i] = bits_cnt[i & (i-1)] + 1;\n        }\n        return bits_cnt;\n    }\n};\n"
  },
  {
    "question_theme": "evaluateDivision",
    "question": "/*************************************************************************************** \n *\n * Equations are given in the format A / B = k, where  A and B are variables \n * represented as strings, and k is a real number (floating point number). Given some \n * queries, return the answers. If the answer does not exist, return -1.0.\n * \n * Example:\n * Given  a / b = 2.0, b / c = 3.0. queries are:  a / c = ?,  b / a = ?, a / e = ?,  a \n * / a = ?, x / x = ? . return  [6.0, 0.5, -1.0, 1.0, -1.0 ].\n * \n * The input is:  vector<pair<string, string>> equations, vector<double>& values, \n * vector<pair<string, string>> queries , where equations.size() == values.size(), and \n * the values are positive. This represents the equations. Return  vector<double>.\n * \n * According to the example above:\n * equations = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\n * values = [2.0, 3.0],\n * queries = [ [\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"] ]. \n * \n * The input is always valid. You may assume that evaluating the queries will result in \n * no division by zero and there is no contradiction.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/evaluate-division/\n// Author : Hao Chen\n// Date   : 2016-11-05\n\n\n\nclass Solution {\nprivate:\n    bool dfs( unordered_map<string, unordered_map<string, double>>& m, \n              unordered_map<string, bool>& visited, \n              string& start, string& end, double& res  ) {\n                 \n        if ( m.find(start) == m.end() || m.find(end) == m.end() ) return false;\n        if ( start == end ) return true;\n        \n        for (auto it = m[start].begin(); it != m[start].end(); ++it) {\n           \n            auto key = it->first;\n            auto value = it->second;\n            \n            // already visited, skip it.\n            if (visited.find(key) != visited.end() ) {\n                continue;\n            }\n            \n            visited[key] = true;\n            double old = res;\n            res *= value;\n            \n            if (dfs(m, visited, key, end, res)) {\n                return true;\n            }\n            //didn't find the result, reset the current result, and go to next one\n            res = old;\n            visited.erase(key);\n        }\n        \n        return false;\n    }\npublic:\n    vector<double> calcEquation(vector<pair<string, string>> equations, \n                                vector<double>& values, \n                                vector<pair<string, string>> queries) {\n        \n        unordered_map<string, unordered_map<string, double>> m;\n        for(int i=0; i<equations.size(); i++) {\n           auto first = equations[i].first;\n           auto second = equations[i].second;\n           m[first][second] = values[i];\n           m[second][first] = 1.0 / values[i];\n        }\n        \n        \n        vector<double> result;\n        for(auto q : queries) {\n            string start = q.first;\n            string end = q.second;\n            \n            unordered_map<string, bool> visited;\n            visited[start] = true;\n            double res = 1.0;\n            \n            if(dfs(m, visited, start, end, res)) {\n                result.push_back(res);\n            } else {\n                result.push_back(-1.0);\n            }\n        }\n        \n        return result;\n    }\n};\n"
  },
  {
    "question_theme": "fizzBuzz",
    "question": "/*************************************************************************************** \n *\n * Write a program that outputs the string representation of numbers from 1 to n.\n * \n * But for multiples of three it should output \u201cFizz\u201d instead of the number and for the \n * multiples of five output \u201cBuzz\u201d. For numbers which are multiples of both three and \n * five output \u201cFizzBuzz\u201d.\n * \n * Example:\n * \n * n = 15,\n * \n * Return:\n * [\n *     \"1\",\n *     \"2\",\n *     \"Fizz\",\n *     \"4\",\n *     \"Buzz\",\n *     \"Fizz\",\n *     \"7\",\n *     \"8\",\n *     \"Fizz\",\n *     \"Buzz\",\n *     \"11\",\n *     \"Fizz\",\n *     \"13\",\n *     \"14\",\n *     \"FizzBuzz\"\n * ]\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/fizz-buzz/\n// Author : Hao Chen\n// Date   : 2016-11-13\n\n\n\nclass Solution {\npublic:\n    vector<string> fizzBuzz_old_school_way(int n) {\n        vector<string> result;\n        for (int i=1; i<=n; i++) {\n            if ( i%3 == 0 && i%5 ==0 ) {\n                result.push_back(\"FizzBuzz\");\n            }else if (i%3 == 0) {\n                result.push_back(\"Fizz\");\n            }else if (i%5 == 0) {\n                result.push_back(\"Buzz\");\n            }else{\n                result.push_back(std::to_string(i));\n            }\n        }\n        return result;\n    }\n    \n    \n    class FizzBuzz {\n        public:\n            FizzBuzz() : x(0) {}\n            \n            string operator()() {\n                x++; \n                if ( x%3 == 0 && x%5 ==0 ) {\n                    return (\"FizzBuzz\");\n                }else if (x%3 == 0) {\n                    return (\"Fizz\");\n                }else if (x%5 == 0) {\n                    return(\"Buzz\");\n                }\n                return std::to_string(x);\n            }\n            \n        private:\n            int x;\n    };\n    \n    vector<string> fizzBuzz_cpp_way(int n) {\n        vector<string> result(n);\n        generate(result.begin(), result.end(), FizzBuzz());\n        return result;\n    }\n    \n    vector<string> fizzBuzz(int n) {\n        \n        //both method has same performance\n        \n        if (rand() % 2 == 0) {\n            return fizzBuzz_cpp_way(n); \n        }\n        return fizzBuzz_old_school_way(n);   \n    }\n};\n"
  },
  {
    "question_theme": "palindromePairs",
    "question": "/*************************************************************************************** \n *\n * Given a list of unique words, find all pairs of distinct indices (i, j) in the given \n * list, so that the concatenation of the two words, i.e. words[i] + words[j] is a \n * palindrome.\n * \n *     Example 1:\n *     Given words = [\"bat\", \"tab\", \"cat\"]\n *     Return [[0, 1], [1, 0]]\n *     The palindromes are [\"battab\", \"tabbat\"]\n * \n *     Example 2:\n *     Given words = [\"abcd\", \"dcba\", \"lls\", \"s\", \"sssll\"]\n *     Return [[0, 1], [1, 0], [3, 2], [2, 4]]\n *     The palindromes are [\"dcbaabcd\", \"abcddcba\", \"slls\", \"llssssll\"]\n * \n * Credits:Special thanks to @dietpepsi for adding this problem and creating all test \n * cases.\n *       \n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/palindrome-pairs/\n// Author : Hao Chen\n// Date   : 2017-03-22\n\n\n\nclass Solution {\npublic:\n    bool isPalindrome(string& str) {\n        int left = 0, right = str.size() - 1;\n        while( left < right) {\n            if (str[left++] != str[right--]) return false;\n        }\n        return true;\n    }\n    vector<vector<int>> palindromePairs(vector<string>& words) {\n        unordered_map<string, int> dict;\n        for(int i=0; i<words.size(); i++){\n            string w = words[i];\n            reverse(w.begin(), w.end());\n            dict[w] = i;\n        }\n        \n        \n        vector<vector<int>> result;\n        \n        //egde case: deal with empty string \n        if ( dict.find(\"\") != dict.end() ) {\n            for(int i=0; i<words.size(); i++) {\n                if ( isPalindrome(words[i]) && dict[\"\"] != i ) {\n                    result.push_back( { dict[\"\"], i } );\n                }\n            }\n        }\n        \n        for(int i=0; i<words.size(); i++) {\n            for (int j=0; j<words[i].size(); j++) {\n                //split the word to 2 parts\n                string left = words[i].substr(0, j);\n                string right = words[i].substr(j, words[i].size() - j);\n                \n                // if the `left` is found, which means there is a words has reversed sequence with it.\n                // then we can check the `right` part is Palindrome or not. \n                if ( dict.find(left) != dict.end() && isPalindrome(right) && dict[left] != i ) {\n                    result.push_back( { i, dict[left] } );\n                }\n                \n                if (dict.find(right) != dict.end() && isPalindrome(left) && dict[right] != i ) {\n                    result.push_back( { dict[right], i } );\n                }\n            }\n\n        }\n        \n        return result;\n    }\n    \n};\n\n"
  },
  {
    "question_theme": "integerToRoman",
    "question": "/********************************************************************************** \n* \n* Given an integer, convert it to a roman numeral.\n* \n* Input is guaranteed to be within the range from 1 to 3999.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/integer-to-roman/\n// Author : Hao Chen\n// Date   : 2014-07-17\n\n\n\n#include <stdlib.h>\n#include <string>\n#include <iostream>\nusing namespace std;\n\n//greeding algorithm\nstring intToRoman(int num) {\n    string symbol[] =   {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};    \n    int value[]     =   {1000,900,500,400, 100, 90,  50, 40,  10, 9,   5,  4,   1}; \n    string result;\n\n    for(int i=0; num!=0; i++){\n        while(num >= value[i]){\n            num -= value[i];\n            result+=symbol[i];\n        }\n    }\n\n    return result;\n}\n\n\nint main(int argc, char** argv)\n{\n    int num = 1234;\n    if (argc>0){\n        num = atoi(argv[1]);\n    }    \n\n    cout << num << \" : \" << intToRoman(num) << endl;\n    return 0;\n}\n"
  },
  {
    "question_theme": "rotateImage",
    "question": "/********************************************************************************** \n* \n* You are given an n x n 2D matrix representing an image.\n* Rotate the image by 90 degrees (clockwise).\n* Follow up:\n* Could you do this in-place?\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/rotate-image/\n// Author : Hao Chen\n// Date   : 2014-06-27\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid rotate(vector<vector<int> > &matrix) {\n\n    int n = matrix.size();\n\n    for( int i=0; i<n/2; i++ ){\n        int low=i, high=n-i-1;\n        for (int j=low; j<high; j++){\n            int tmp;\n            tmp = matrix[i][j];\n            // left to top \n            matrix[i][j] = matrix[n-j-1][i];\n            // bottom to left\n            matrix[n-j-1][i] = matrix[n-i-1][n-j-1];\n            // right to bottom\n            matrix[n-i-1][n-j-1] = matrix[j][n-i-1];\n            // top to right\n            matrix[j][n-i-1] = tmp;\n        }\n    }\n}\n\nvoid printMatrix(vector<vector<int> > &matrix) \n{\n    for(int i=0; i<matrix.size(); i++){\n        for(int j=0; j< matrix[i].size(); j++) {\n            printf(\"%3d \", matrix[i][j]) ;\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\n\nint main(int argc, char** argv)\n{\n    int n = 2;\n    if (argc>1){\n        n = atoi(argv[1]);\n    }\n    vector< vector<int> > matrix;\n    for (int i=1; i<=n; i++) {\n        vector<int> v;\n        for(int j=1; j<=n; j++){\n            v.push_back( (i-1)*n + j );\n        }\n        matrix.push_back(v);\n    }\n\n    printMatrix(matrix);\n    rotate(matrix);\n    printMatrix(matrix);\n\n    return 0;\n}\n"
  },
  {
    "question_theme": "fractionToRecurringDecimal",
    "question": "/********************************************************************************** \n* \n* Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\n* \n* If the fractional part is repeating, enclose the repeating part in parentheses.\n* \n* For example,\n* \n* Given numerator = 1, denominator = 2, return \"0.5\".\n* Given numerator = 2, denominator = 1, return \"2\".\n* Given numerator = 2, denominator = 3, return \"0.(6)\".\n* \n* Credits:Special thanks to @Shangrila for adding this problem and creating all test cases.\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/fraction-to-recurring-decimal/\n// Author : Hao Chen\n// Date   : 2014-12-16\n\n\n\n#include <stdlib.h>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <map>\nusing namespace std;\n\n\n\n\nstring fractionToDecimal(int numerator, int denominator) {\n    string result;\n    //deal with the `ZERO` cases\n    if (denominator == 0){ return result; }\n    if (numerator == 0) { return \"0\"; }\n\n    //using long long type make sure there has no integer overflow\n    long long n = numerator;\n    long long d = denominator;\n\n    //deal with negtive cases \n    bool sign = ((float)numerator/denominator >= 0);\n    if ( n < 0 ){ n = -n; }\n    if ( d < 0 ){ d = -d; }\n    if (sign == false){\n        result.push_back('-');\n    }\n\n    long long remainder = n % d;\n    long long division = n / d;\n    ostringstream oss;\n    oss << division;\n    result += oss.str();\n    if (remainder == 0){\n        return result;\n    }\n    //remainder has value, the result is a float\n    result.push_back('.');\n\n    //using a map to record all of reminders and their position.\n    //if the reminder appeared before, which means the repeated loop begin, \n    //then, get the place from map to insert \"(\".\n    //(In C++11, it's better to use unordered_map )\n    map<long long, int> rec;\n\n    for (int pos=result.size(); remainder!=0; pos++, remainder=(remainder*10)%d ) {\n        if (rec.find(remainder) != rec.end()) {\n            result.insert(result.begin()+rec[remainder], '(');\n            result.push_back(')');\n            return result;\n        }\n        rec[remainder] = pos;\n        result.push_back((remainder*10)/d + '0');\n    }\n\n    return result;\n}\n\n\nvoid test(int num, int deno)\n{\n    cout << \"numerator: \" << num << \"\\tdenominator: \" << deno << \"\\tresult: \" << fractionToDecimal(num, deno) << endl;\n}\n\nint main(int argc, char** argv)\n{\n    test(1, 2);\n    test(10, 2);\n    test(100, 2);\n    test(1, 3);\n    test(100, 3);\n    test(1, 6);\n    test(100, 6);\n    test(-1, 4);\n    test(1, -3);\n    test(-1, -6);\n    test(25, 99);\n    test(1, 7);\n    test(10, 7);\n    test(100, 7);\n    test(1, 17);\n    test(1, 1024);\n    test( -2147483648, -1999);\n    test(-1, -2147483648);\n\n\n    if (argc > 2) {\n        int num = atoi(argv[1]);\n        int deno = atoi(argv[2]);\n        test(num, deno);\n    }\n    return 0;\n}\n"
  },
  {
    "question_theme": "oddEvenLinkedList",
    "question": "/*************************************************************************************** \n *\n * Given a singly linked list, group all odd nodes together followed by the even nodes. \n * Please note here we are talking about the node number and not the value in the nodes.\n * \n * You should try to do it in place. The program should run in O(1) space complexity \n * and O(nodes) time complexity.\n * \n * Example:\n * Given 1->2->3->4->5->NULL,\n * return 1->3->5->2->4->NULL.\n * \n * Note:\n * The relative order inside both the even and odd groups should remain as it was in \n * the input. \n * The first node is considered odd, the second node even and so on ...\n * \n * Credits:Special thanks to @aadarshjajodia for adding this problem and creating all \n * test cases.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/odd-even-linked-list/\n// Author : Hao Chen\n// Date   : 2016-01-16\n\n\n\n\nclass Solution {\npublic:\n    ListNode* oddEvenList(ListNode* head) {\n        if (!head) return head;\n        ListNode* pOdd = head;\n        ListNode* p = head->next;\n        ListNode* pNext = NULL;\n        while(p && (pNext=p->next)) {\n            \n            p->next = pNext->next;\n            pNext->next = pOdd->next;\n            pOdd->next = pNext;\n            \n            p = p->next;\n            pOdd = pOdd->next;\n        \n        }\n        return head;\n    }\n};\n"
  },
  {
    "question_theme": "binaryTreePreorderTraversal",
    "question": "/********************************************************************************** \n* \n* Given a binary tree, return the preorder traversal of its nodes' values.\n* \n* For example:\n* Given binary tree {1,#,2,3},\n* \n*    1\n*     \\\n*      2\n*     /\n*    3\n* \n* return [1,2,3].\n* \n* Note: Recursive solution is trivial, could you do it iteratively?\n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/binary-tree-preorder-traversal/\n// Author : Hao Chen\n// Date   : 2014-07-21\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvector<int> preorderTraversal1(TreeNode *root);\nvector<int> preorderTraversal2(TreeNode *root);\n\nvector<int> preorderTraversal(TreeNode *root) {\n    if (random()%2){\n        cout << \"---method one---\" << endl;\n        return preorderTraversal1(root);\n    }\n    cout << \"---method two---\" << endl;\n    return preorderTraversal2(root);\n}\n\nvector<int> preorderTraversal1(TreeNode *root) {\n    vector<int> v;\n    vector<TreeNode*> stack;\n    if (root) {\n        stack.push_back(root);\n    }\n    while (stack.size()>0){\n        TreeNode* n = stack.back();\n        v.push_back(n->val);\n        stack.pop_back();\n        if (n->right){\n            stack.push_back(n->right);\n        }\n        if (n->left){\n            stack.push_back(n->left);\n        }\n    }\n    return v;\n}\n\nvector<int> preorderTraversal2(TreeNode *root) {\n    vector<int> v;\n    vector<TreeNode*> stack;\n    stack.push_back((TreeNode*)NULL);\n    TreeNode *top = root;\n    while(top!=NULL){\n        v.push_back(top->val);\n        if (top->right !=NULL){\n            stack.push_back(top->right);\n        }\n\n        if (top->left != NULL){\n            stack.push_back(top->left);\n        }\n\n        top = stack.back();\n        stack.pop_back();\n    }\n    return v;\n}\n\nTreeNode* createTree(int a[], int n)\n{\n    if (n<=0) return NULL;\n\n    TreeNode **tree = new TreeNode*[n];\n\n    for(int i=0; i<n; i++) {\n        if (a[i]==0 ){\n            tree[i] = NULL;\n            continue;\n        }\n        tree[i] = new TreeNode(a[i]);\n    }\n    int pos=1;\n    for(int i=0; i<n && pos<n; i++) {\n        if (tree[i]){\n            tree[i]->left = tree[pos++];\n            if (pos<n){\n                tree[i]->right = tree[pos++];\n            }\n        }\n    }\n    return tree[0];\n}\n\nvoid printTree_pre_order(TreeNode *root)\n{\n    if (root == NULL){\n        //cout << \"# \";\n        return ;\n    }\n    cout << root->val << \" \";\n    printTree_pre_order(root->left);\n    printTree_pre_order(root->right);\n}\n\n\nvoid printArray(vector<int> v)\n{\n    for(int i=0; i<v.size(); i++){\n        cout << v[i] << \" \";\n    }\n    cout << endl;\n}\n\nint main()\n{\n    srand(time(0));\n    int a[] = {1,2,3,4,5,0,6,0,0,7,8,9,0};\n    TreeNode* p = createTree(a, sizeof(a)/sizeof(int));\n    printTree_pre_order(p);\n    cout << endl;\n    vector<int> v = preorderTraversal(p);\n    printArray(v);\n    cout << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "question_theme": "thirdMaximumNumber",
    "question": "/*************************************************************************************** \n *\n * Given a non-empty array of integers, return the third maximum number in this array. \n * If it does not exist, return the maximum number. The time complexity must be in O(n).\n * \n * Example 1:\n * \n * Input: [3, 2, 1]\n * \n * Output: 1\n * \n * Explanation: The third maximum is 1.\n * \n * Example 2:\n * \n * Input: [1, 2]\n * \n * Output: 2\n * \n * Explanation: The third maximum does not exist, so the maximum (2) is returned \n * instead.\n * \n * Example 3:\n * \n * Input: [2, 2, 3, 1]\n * \n * Output: 1\n * \n * Explanation: Note that the third maximum here means the third maximum distinct \n * number.\n * Both numbers with value 2 are both considered as second maximum.\n ***************************************************************************************",
    "answer": "// Source : https://leetcode.com/problems/third-maximum-number/\n// Author : Hao Chen\n// Date   : 2016-11-12\n\n\n\nclass Solution {\npublic:\n    int nMax(vector<int>& nums, int n) {\n        set<int> topN;\n        for(auto num : nums) {\n            topN.insert(num);\n            if (topN.size() > n) topN.erase(topN.begin());\n        }\n        return (topN.size() >= n) ? *(topN.begin()) : *(topN.rbegin());\n    }\n    int thirdMax(vector<int>& nums) {\n        return nMax(nums, 3);\n    }\n};\n"
  },
  {
    "question_theme": "decodeWays",
    "question": "/********************************************************************************** \n* \n* A message containing letters from A-Z is being encoded to numbers using the following mapping:\n* \n* 'A' -> 1\n* 'B' -> 2\n* ...\n* 'Z' -> 26\n* \n* Given an encoded message containing digits, determine the total number of ways to decode it.\n* \n* For example,\n* Given encoded message \"12\",\n* it could be decoded as \"AB\" (1 2) or \"L\" (12).\n* \n* The number of ways decoding \"12\" is 2.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/decode-ways/\n// Author : Hao Chen\n// Date   : 2014-07-16\n\n\n\n#include <iostream>\n#include <string>\n#include <string.h>\nusing namespace std;\n\n\n//Count[i] = Count[i-1]              if S[i-1] is a valid char (not '0')\n//         = Count[i-1]+ Count[i-2]  if S[i-1] and S[i-2] together is still a valid char (10 to 26).\n\nint check(char ch){\n    //check 0 or not\n    return (!isdigit(ch) || ch=='0') ? 0 : 1;\n}\n\nint check(char ch1, char ch2){\n    //check it's between 10 and 26\n    return (ch1=='1' || (ch1=='2' && ch2<='6')) ? 1: 0;\n}\n\nint numDecodings(string s) {\n    if (s.size()<=0) return 0;\n    if (s.size()==1) return check(s[0]);\n   \n    int* dp = new int[s.size()];\n    memset(dp, 0, s.size()*sizeof(int));\n\n    dp[0] = check(s[0]);\n    dp[1] = check(s[0]) *  check(s[1]) + check(s[0], s[1]) ;\n    for (int i=2; i<s.size(); i++) {\n        if (!isdigit(s[i])) break; \n        if (check(s[i])) {\n            dp[i] = dp[i-1];\n        }\n        if (check(s[i-1], s[i])) {\n            dp[i] += dp[i-2];\n        }\n    \n    }\n    int result = dp[s.size()-1];\n    delete[] dp;\n    return result;\n}\n\n\nint main(int argc, char**argv)\n{\n    string s = \"123\";\n    if (argc>1){\n        s = argv[1];\n    }\n    cout << \"\\\"\" << s << \"\\\" : \" << numDecodings(s) << endl; \n    return 0;\n}\n"
  },
  {
    "question_theme": "balancedBinaryTree",
    "question": "/********************************************************************************** \n* \n* Given a binary tree, determine if it is height-balanced.\n* \n* For this problem, a height-balanced binary tree is defined as a binary tree in which \n* the depth of the two subtrees of every node never differ by more than 1.\n* \n*               \n**********************************************************************************",
    "answer": "// Source : https://oj.leetcode.com/problems/balanced-binary-tree/\n// Author : Hao Chen\n// Date   : 2014-06-28\n\n\n\n\nclass Solution {\npublic:\n    bool isBalanced(TreeNode *root) {\n        int height=0;\n        return isBalancedUtil(root, height);\n    }\n\n    bool isBalancedUtil(TreeNode* root, int& height){\n       if(root==NULL){\n          height=0;\n          return true;\n       }\n       int lh=0, rh=0;\n       bool isLeft = isBalancedUtil(root->left, lh);\n       bool isRight = isBalancedUtil(root->right, rh);\n       height = (lh > rh ? lh : rh) + 1;\n       return (abs(lh-rh)<=1 && isLeft && isRight);\n    }\n\n};\n\n//Notes: \n// I think the above solution should be more efficent than the below, \n//  but for leetcode, the below solution needs 60ms, the above needs 88ms\nclass Solution {\npublic:\n    bool isBalanced(TreeNode *root) {\n        if (root==NULL) return true;\n        \n        int left = treeDepth(root->left); \n        int right = treeDepth(root->right);\n        \n        if (left-right>1 || left-right < -1) {\n            return false;\n        }\n        return isBalanced(root->left) && isBalanced(root->right);\n    }\n    \n    int treeDepth(TreeNode *root) {\n        if (root==NULL){\n            return 0;\n        }\n\n        int left=1, right=1;\n        \n        left += treeDepth(root->left);\n        right += treeDepth(root->right);\n        \n        return left>right?left:right;\n    }\n\n};\n"
  }
]